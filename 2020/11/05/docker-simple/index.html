<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>docker 简单介绍 | J. Xu</title><meta name="author" content="Jinzhong Xu"><meta name="copyright" content="Jinzhong Xu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="docker 容器技术使得开发测试非常方便，自 2013 年发布至今，一直广受瞩目。软件开发最大的麻烦事之一，就是环境配置。虚拟机虽然能够解决上面问题，但是有如下缺点：1.资源占用多，2.冗余步骤多，3. 启动慢；由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。Linux 容器不是模拟一个完整的操作系统，而是对进程">
<meta property="og:type" content="article">
<meta property="og:title" content="docker 简单介绍">
<meta property="og:url" content="https://xujinzh.github.io/2020/11/05/docker-simple/index.html">
<meta property="og:site_name" content="J. Xu">
<meta property="og:description" content="docker 容器技术使得开发测试非常方便，自 2013 年发布至今，一直广受瞩目。软件开发最大的麻烦事之一，就是环境配置。虚拟机虽然能够解决上面问题，但是有如下缺点：1.资源占用多，2.冗余步骤多，3. 启动慢；由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。Linux 容器不是模拟一个完整的操作系统，而是对进程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xujinzh.github.io/img/c29.jpg">
<meta property="article:published_time" content="2020-11-05T03:26:08.000Z">
<meta property="article:modified_time" content="2024-02-07T05:44:07.463Z">
<meta property="article:author" content="Jinzhong Xu">
<meta property="article:tag" content="docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xujinzh.github.io/img/c29.jpg"><link rel="shortcut icon" href="/img/letter-j.png"><link rel="canonical" href="https://xujinzh.github.io/2020/11/05/docker-simple/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'docker 简单介绍',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-07 13:44:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/silence.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">390</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">302</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="J. Xu"><img class="site-icon" src="/img/letter-j.png"/><span class="site-name">J. Xu</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">docker 简单介绍</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-05T03:26:08.000Z" title="发表于 2020-11-05 11:26:08">2020-11-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-07T05:44:07.463Z" title="更新于 2024-02-07 13:44:07">2024-02-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/technology/">technology</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="docker 简单介绍"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>docker 容器技术使得开发测试非常方便，自 2013 年发布至今，一直广受瞩目。软件开发最大的麻烦事之一，就是环境配置。虚拟机虽然能够解决上面问题，但是有如下缺点：1.<strong>资源占用多</strong>，2.<strong>冗余步骤多</strong>，3. <strong>启动慢</strong>；由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。<strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong> 或者说，在正常进程的外面套了一个<a target="_blank" rel="noopener" href="https://opensource.com/article/18/1/history-low-level-container-runtimes">保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。由于容器是进程级别的，相比虚拟机有很多优势。1. <strong>启动快</strong>, 2, <strong>资源占用少</strong>,3. <strong>体积小</strong>. 总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。<strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong> 它是目前最流行的 Linux 容器解决方案。下面介绍2020年08月以后，如何安装使用 docker，本篇以 Windows 10 wsl 2 Ubuntu-20.04 为例。</p>
<span id="more"></span>

<h1 id="Docker-的主要用途，目前有三大类："><a href="#Docker-的主要用途，目前有三大类：" class="headerlink" title="Docker 的主要用途，目前有三大类："></a>Docker 的主要用途，目前有三大类：</h1><p><strong>（1）提供一次性的环境。</strong> 比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境；</p>
<p><strong>（2）提供弹性的云服务。</strong> 因为 Docker 容器可以随开随关，很适合动态扩容和缩容；</p>
<p><strong>（3）组建微服务架构。</strong> 通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p>
<h1 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h1><h2 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment"># 安装 apt 依赖包，用于通过HTTPS来获取仓库</span></span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br><span class="line"><span class="comment"># 添加 Docker 的官方 GPG 密钥：</span></span><br><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="comment"># 验证秘钥</span></span><br><span class="line">sudo apt-key fingerprint 0EBFCD88</span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">&quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">  stable&quot;</span></span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install docker-ce docker-ce-cli containerd.io</span><br><span class="line">sudo service docker status</span><br><span class="line">sudo service docker restart</span><br><span class="line"><span class="comment"># 把常用用户添加到 docker 组，这样运行 docker 命令时不需要添加 sudo，但需重启终端。注意，service 命令时仍然需要 sudo</span></span><br><span class="line"><span class="comment"># 添加指定用户</span></span><br><span class="line">sudo usermod -a -G docker jinzhongxu</span><br><span class="line"><span class="comment"># 添加当前用户</span></span><br><span class="line">sudo usermod -a -G docker <span class="variable">$USER</span></span><br><span class="line"><span class="comment"># newgrp 命令用于在登录会话期间更改当前组 ID。用户的环境将被重新初始化</span></span><br><span class="line">newgrp docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试运行 hello world 镜像</span></span><br><span class="line">sudo docker run hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证是否安装成功。查看版本信息</span></span><br><span class="line">docker version</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>

<h2 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h2><p>除了在线安装外，有时候，离线安装也是很常见的。如内网服务器（不方便连接互联网）等。下面介绍在 Debian&#x2F;Ubuntu 系统中安装的方法。</p>
<p>Debian 系统请访问 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/debian/">Docker 官网</a>，并在 <strong>Install from a package</strong> 一节中，打开网址：<a target="_blank" rel="noopener" href="https://download.docker.com/linux/debian/dists/">https://download.docker.com/linux/debian/dists/</a> ，然后选择自己服务器版本，进入 <code>pool/stable</code>，选择 <code>amd64, armhf, arm64, s390x</code> 下载 <code>.deb</code> ，注意需要下载 4 个 <code>.deb</code>，分别是 <code>docker-ce, docker-ce-cli, containerd.io, docker-compose-plugin</code>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载必要的包</span></span><br><span class="line">wget https://download.docker.com/linux/debian/dists/buster/pool/stable/amd64/docker-ce_20.10.9\~3-0\~debian-buster_amd64.deb</span><br><span class="line">wget https://download.docker.com/linux/debian/dists/buster/pool/stable/amd64/docker-ce-cli_20.10.9\~3-0\~debian-buster_amd64.deb</span><br><span class="line">wget https://download.docker.com/linux/debian/dists/buster/pool/stable/amd64/containerd.io_1.4.3-1_amd64.deb</span><br><span class="line">wget https://download.docker.com/linux/debian/dists/buster/pool/stable/amd64/docker-compose-plugin_2.6.0\~debian-buster_amd64.deb</span><br><span class="line"><span class="comment"># 安装软件包</span></span><br><span class="line">sudo dpkg -i *deb</span><br></pre></td></tr></table></figure>

<p>Ubuntu 系统请访问 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/ubuntu/">Docker 官网</a>，并在 <strong>Install from a package</strong> 一节中，打开网址：<a target="_blank" rel="noopener" href="https://download.docker.com/linux/ubuntu/dists/">https://download.docker.com/linux/ubuntu/dists/</a> ，然后选择自己服务器版本，进入 <code>pool/stable</code>，选择 <code>amd64, armhf, arm64, s390x</code> 下载 <code>.deb</code> ，注意需要下载 4 个 <code>.deb</code>，分别是 <code>docker-ce, docker-ce-cli, containerd.io, docker-compose-plugin</code>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载必要的包</span></span><br><span class="line">wget https://download.docker.com/linux/ubuntu/dists/bionic/pool/stable/amd64/docker-ce_20.10.9~3-0~ubuntu-bionic_amd64.deb</span><br><span class="line">wget https://download.docker.com/linux/ubuntu/dists/bionic/pool/stable/amd64/docker-ce-cli_20.10.9\~3-0\~ubuntu-bionic_amd64.deb</span><br><span class="line">wget https://download.docker.com/linux/ubuntu/dists/bionic/pool/stable/amd64/containerd.io_1.4.6-1_amd64.deb</span><br><span class="line">wget https://download.docker.com/linux/ubuntu/dists/bionic/pool/stable/amd64/docker-compose-plugin_2.6.0\~ubuntu-bionic_amd64.deb</span><br><span class="line"><span class="comment"># 安装软件包</span></span><br><span class="line">sudo dpkg -i *deb</span><br></pre></td></tr></table></figure>

<ul>
<li><em>CentOS 等其他系统请访问 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/debian/">Docker 官网</a> 获取安装方法。</em></li>
</ul>
<h1 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h1><p>docker compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。下载地址： <a target="_blank" rel="noopener" href="https://github.com/docker/compose/releases">github docker compose</a></p>
<p>Compose 使用的三个步骤：</p>
<ol>
<li>使用 Dockerfile 定义应用程序的环境。</li>
<li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li>
<li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li>
</ol>
<h2 id="docker-compose-安装"><a href="#docker-compose-安装" class="headerlink" title="docker-compose 安装"></a>docker-compose 安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/docker/compose/releases/download/v2.10.2/docker-compose-linux-x86_64</span><br><span class="line">sudo <span class="built_in">mv</span> docker-compose-linux-x86_64 /usr/local/bin/docker-compose</span><br><span class="line">sudo <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br><span class="line">docker-compose -v</span><br></pre></td></tr></table></figure>

<h2 id="命令行容器自动生成-docker-compose-yml"><a href="#命令行容器自动生成-docker-compose-yml" class="headerlink" title="命令行容器自动生成 docker-compose.yml"></a>命令行容器自动生成 docker-compose.yml</h2><p>使用 ghcr.io&#x2F;red5d&#x2F;docker-autocompose 来对命令行运行的容器生成 docker-compose.yml 文件，方便下次使用 docker-compose 运行。生成的配置文件包含非常丰富的参数，可以根据个人情况删除、更改。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于单个容器</span></span><br><span class="line">docker run --<span class="built_in">rm</span> -v /var/run/docker.sock:/var/run/docker.sock ghcr.io/red5d/docker-autocompose registry &gt; docker-compose.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于多个容器，容器间的启动依赖需要手动增加</span></span><br><span class="line">docker run --<span class="built_in">rm</span> -v /var/run/docker.sock:/var/run/docker.sock ghcr.io/red5d/docker-autocompose redmine-redmine-1 redmine-mariadb-1 &gt; docker-compose.yml</span><br></pre></td></tr></table></figure>


<h1 id="中文显示"><a href="#中文显示" class="headerlink" title="中文显示"></a>中文显示</h1><p>在 docker 镜像中运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LC_ALL=<span class="string">&quot;C.UTF-8&quot;</span></span><br></pre></td></tr></table></figure>
<p>此时，命令行可正常查看中文。在命令行设置，可对当前用户所有终端生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export LC_ALL=&quot;C.UTF-8&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>如下设置，可对全局生效，默认 root 用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export LC_ALL=&quot;C.UTF-8&quot;&#x27;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<p>建议在创建容器时直接设置语言：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name python -e LANG=<span class="string">&quot;C.UTF-8&quot;</span> ubuntu:python /bin/bash</span><br></pre></td></tr></table></figure>


<h1 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h1><p>默认运行的容器时区都是 UTC，想要改为 CST，方法如下：</p>
<ol>
<li>在构建镜像时，设置时区： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV TZ=Asia/Shanghai</span><br><span class="line">RUN ...</span><br></pre></td></tr></table></figure></li>
<li>docker-compose 配置文件中，设置时区： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一：</span></span><br><span class="line">environment:</span><br><span class="line">- SET_CONTAINER_TIMEZONE=<span class="literal">true</span></span><br><span class="line">- CONTAINER_TIMEZONE=Asia/Shanghai</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 方式二：</span></span><br><span class="line">environment:</span><br><span class="line">- TZ=Asia/Shanghai</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>在启动容器时，更改时区： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -e TZ=Asia/Shanghai ...</span><br></pre></td></tr></table></figure></li>
<li>对运行的容器更改时区： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把宿主机的时区配置拷贝到容器中，假设我的容器名为 colab</span></span><br><span class="line"><span class="comment"># /usr/share/zoneinfo/Asia/Shanghai -&gt; ../PRC</span></span><br><span class="line">docker <span class="built_in">cp</span> /usr/share/zoneinfo/PRC colab:/etc/localtime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启容器</span></span><br><span class="line">docker restart colab</span><br></pre></td></tr></table></figure></li>
</ol>
<p>查看时区：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span></span><br></pre></td></tr></table></figure>
<p>如果上面方法不管用，那么请直接在容器中安装 tzdata：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装时选择地区和时区</span></span><br><span class="line">apt update &amp;&amp; apt install tzdata -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者手动更改时区</span></span><br><span class="line">dpkg-reconfigure tzdata</span><br></pre></td></tr></table></figure>

<h1 id="docker-中使用-GPU"><a href="#docker-中使用-GPU" class="headerlink" title="docker 中使用 GPU"></a>docker 中使用 GPU</h1><p>想要在 docker 容器中使用宿主机的 GPU，除了<a href="https://xujinzh.github.io/2019/12/21/dl-gpu/">宿主机配置 CUDA 环境</a>和安装 docker 外，还需要安装如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">curl -s -L https://nvidia.github.io/nvidia-container-runtime/gpgkey | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">distribution=$(. /etc/os-release;<span class="built_in">echo</span> $ID<span class="variable">$VERSION_ID</span>)</span><br><span class="line"></span><br><span class="line">curl -s -L https://nvidia.github.io/nvidia-container-runtime/<span class="variable">$distribution</span>/nvidia-container-runtime.list | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/nvidia-container-runtime.list</span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install nvidia-container-runtime nvidia-container-toolkit -y</span><br><span class="line"></span><br><span class="line">sudo systemctl stop docker.service</span><br><span class="line">sudo systemctl stop docker.socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把运行时添加到 docker 中</span></span><br><span class="line"><span class="comment"># 或者把运行时添加到配置文件中，方法参见下一节 docker 使用: /etc/docker/daemon.json</span></span><br><span class="line">dockerd --add-runtime=nvidia=/usr/bin/nvidia-container-runtime</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker.service</span><br></pre></td></tr></table></figure>

<p>另一种方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Nvidia Docker</span></span><br><span class="line">sudo apt install curl -y</span><br><span class="line">distribution=$(. /etc/os-release;<span class="built_in">echo</span> $ID<span class="variable">$VERSION_ID</span>)</span><br><span class="line">curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -</span><br><span class="line">curl -s -L https://nvidia.github.io/nvidia-docker/<span class="variable">$distribution</span>/nvidia-docker.list | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/nvidia-docker.list</span><br><span class="line"></span><br><span class="line">sudo apt update &amp;&amp; sudo apt install -y nvidia-container-toolkit</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>当安装完 <code>nvidia-container-toolkit</code> 后，运行时有时会出现：<code>nvidia-container-cli: ldcache error: open failed: /sbin/ldconfig.real: no such file or directory: unknown.</code>，解决方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以 root 身份执行</span></span><br><span class="line"><span class="built_in">ln</span> -s /sbin/ldconfig /sbin/ldconfig.real</span><br></pre></td></tr></table></figure>

<p>创建容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以镜像 ubuntu-xjz:v1 或 &#123;IMAGE ID&#125; 创建容器 ubuntu-xjz-python</span></span><br><span class="line"><span class="comment"># 映射容器端口 80 到主机端口 9092</span></span><br><span class="line"><span class="comment"># 使用多GPU训练深度学习模型，请添加 --shm-size 8G</span></span><br><span class="line"><span class="comment"># 把主机的目录 /home/jinzhongxu/Documents 挂载到容器目录 /data</span></span><br><span class="line"><span class="comment"># 不存在挂载点则自动创建</span></span><br><span class="line">docker run -itd --name <span class="string">&#x27;ubuntu-xjz-python&#x27;</span> -p 9092:80 --gpus=all --shm-size 8G -v /home/jinzhongxu/Documents:/data ubuntu-xjz:v1 /bin/bash</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">docker run -itd --name <span class="string">&#x27;ubuntu-xjz-python&#x27;</span> -p 9092:80 --gpus all --shm-size 8G -v /home/jinzhongxu/Documents:/data ubuntu-xjz:v1 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定特定 GPU，如 device=1 表示第 2 个 GPU，注意编号从 0 开始，对应 nvidia-smi -L 列出的编号</span></span><br><span class="line">docker run -itd --name <span class="string">&#x27;ubuntu-xjz-python&#x27;</span> -p 9092:80 --gpus <span class="string">&quot;device=1&quot;</span> --shm-size 8G -v /home/jinzhongxu/Documents:/data ubuntu-xjz:v1 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定两个 GPU，如第 2，3 个 GPU</span></span><br><span class="line">docker run -itd --name <span class="string">&#x27;ubuntu-xjz-python&#x27;</span> -p 9092:80 --gpus <span class="string">&#x27;&quot;device=1,2&quot;&#x27;</span> --shm-size 8G -v /home/jinzhongxu/Documents:/data ubuntu-xjz:v1 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定前两个 GPU</span></span><br><span class="line">docker run -itd --name <span class="string">&#x27;ubuntu-xjz-python&#x27;</span> -p 9092:80 --gpus 2 --shm-size 8G -v /home/jinzhongxu/Documents:/data ubuntu-xjz:v1 /bin/bash</span><br></pre></td></tr></table></figure>

<p>测试在 docker 容器中是否可以使用 GPU</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nvidia/cuda:10.2-base 根据驱动版本进行选择，如 nvidia/cuda:11.0-base</span></span><br><span class="line">docker run --gpus all --<span class="built_in">rm</span> nvidia/cuda:10.2-base nvidia-smi</span><br><span class="line"><span class="comment"># or 只罗列 GPU 名称</span></span><br><span class="line">docker run --gpus all --<span class="built_in">rm</span> nvidia/cuda:10.2-base nvidia-smi -L</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 runtime</span></span><br><span class="line">docker run --runtime=nvidia -e NVIDIA_VISIBLE_DEVICES=all --shm-size 8G --<span class="built_in">rm</span> nvidia/cuda:10.2-base nvidia-smi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 GPU，注意编号从 0 开始，对应 nvidia-smi -L 列出的编号</span></span><br><span class="line">docker run --runtime=nvidia -e NVIDIA_VISIBLE_DEVICES=1,2 --shm-size 8G --<span class="built_in">rm</span> nvidia/cuda:10.2-base nvidia-smi</span><br></pre></td></tr></table></figure>
<p>打印出 GPU 信息说明验证成功，<code>--gpus</code> 和 <code>-e NVIDIA_VISIBLE_DEVICES</code> 都能实现指定 GPU，但后者 api 接口更容易。更多请访问 <a target="_blank" rel="noopener" href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/user-guide.html">NVIDIA 官网教程</a>.</p>
<h1 id="docker-使用"><a href="#docker-使用" class="headerlink" title="docker 使用"></a>docker 使用</h1><p>因 docker hub 在国外，为了加速访问需要给 docker 添加国内镜像，方法如下，打开如下文件，没有则自动创建：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<p>添加如下内容</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">                       <span class="string">&quot;https://registry.docker-cn.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">                       <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">                       <span class="string">&quot;https://mirror.baidubce.com&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;192.168.199.100:5000&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;debug&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;experimental&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;runtimes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;nvidia&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nvidia-container-runtime&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;runtimeArgs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol>
<li>insecure-registries 为你本地网络私有仓库地址，根据个人情况设置；</li>
<li>runtimes 为容器调用宿主机服务器 GPU 运行时，根据个人情况设置。</li>
</ol>
<p>测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tensorflow/tensorflow:latest</span><br></pre></td></tr></table></figure>

<h1 id="image"><a href="#image" class="headerlink" title="image"></a>image</h1><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 docker 官方拉取 image 文件 hello-world</span></span><br><span class="line">docker image pull hello-world</span><br><span class="line"><span class="comment"># 运行这个 image 文件。该命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的 docker image pull 命令并不是必需的步骤。</span></span><br><span class="line">docker container run hello-world</span><br><span class="line"><span class="comment"># 查看下载到本地的镜像文件</span></span><br><span class="line">docker image <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 为本地的 image 标注用户名和版本。username 为 hub.docker.com 或 cloud.docker.com 注册的账户</span></span><br><span class="line">docker image tag (IMAGE ID) (username)/(repository):(tag)</span><br><span class="line"><span class="comment"># 也可以不标注用户名，重新构建一下 image 文件。</span></span><br><span class="line">docker image build -t (username)/(repository):(tag) .</span><br><span class="line"><span class="comment"># 发布 image 文件。</span></span><br><span class="line">docker image push (username)/(repository):(tag)</span><br><span class="line"><span class="comment"># 删除不需要的本地镜像文件</span></span><br><span class="line">docker image <span class="built_in">rm</span> (IMAGE ID)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看虚悬镜像（仓库名和标签都是none）的镜像，一般是无用或错误的镜像</span></span><br><span class="line">docker image <span class="built_in">ls</span> -f dangling=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 删除所有虚悬镜像</span></span><br><span class="line">docker image prune</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像名以registr开头的镜像</span></span><br><span class="line">docker images -f reference=<span class="string">&quot;registr*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多请允许命令</span></span><br><span class="line">docker image --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<h1 id="container"><a href="#container" class="headerlink" title="container"></a>container</h1><p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器 (Container) 文件。</strong> 也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line">docker container <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 只查看容器ID</span></span><br><span class="line">docker ps -q</span><br><span class="line"><span class="comment"># 查看基于镜像ubuntu启动的所有容器</span></span><br><span class="line">docker ps -f ancestor=ubuntu</span><br><span class="line"><span class="comment"># 查看容器名是myubuntu的容器，这里用*匹配所有字符</span></span><br><span class="line">docker ps -f name=<span class="string">&quot;myubunt*&quot;</span></span><br><span class="line"><span class="comment"># 查看退出的容器</span></span><br><span class="line">docker ps -a -f status=exited</span><br><span class="line"><span class="comment"># 查看所有运行过的容器，包括正在运行的和停止运行的</span></span><br><span class="line">docker ps -a</span><br><span class="line">docker container <span class="built_in">ls</span> -all</span><br><span class="line"><span class="comment"># 把运行的容器关闭. 相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</span></span><br><span class="line">docker stop &#123;CONTAINER ID&#125;</span><br><span class="line">docker container stop &#123;CONTAINER ID&#125;</span><br><span class="line"><span class="comment"># 把运行的容器关闭. 相当于向容器里面的主进程发出 SIGKILL 信号</span></span><br><span class="line">docker <span class="built_in">kill</span> &#123;CONTAINER ID&#125;</span><br><span class="line">docker container <span class="built_in">kill</span> &#123;CONTAINER ID&#125;</span><br><span class="line"><span class="comment"># 把停止运行的容器打开</span></span><br><span class="line">docker start &#123;CONTAINER ID&#125;</span><br><span class="line">docker container start &#123;CONTAINER ID&#125;</span><br><span class="line"><span class="comment"># 查看 docker 容器的输出，即容器里面 Shell 的标准输出。</span></span><br><span class="line">docker container logs &#123;CONTAINER ID&#125;</span><br><span class="line"><span class="comment"># 从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</span></span><br><span class="line">docker container <span class="built_in">cp</span> &#123;CONTAINER ID&#125;:&#123;/path/to/file&#125; .</span><br><span class="line"><span class="comment"># 进入运行中的ubuntu容器</span></span><br><span class="line"><span class="comment"># 推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。</span></span><br><span class="line"><span class="comment"># 使用 docker attach &#123;CONTAINER ID&#125;，当退出容器终端时，将导致容器停止。</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &#123;CONTAINER ID&#125; /bin/bash</span><br><span class="line"><span class="comment"># 进入容器时指定登陆用户</span></span><br><span class="line">docker <span class="built_in">exec</span> -it -u root &#123;CONTAINER ID&#125; /bin/bash</span><br><span class="line"><span class="comment"># 拷贝 docker 容器中的文件，注意此时不要求容器为启动状态</span></span><br><span class="line">docker <span class="built_in">cp</span> &#123;CONTAINER ID&#125;:/opt/bitnami/redmine/config/settings.yml settings.yml</span><br><span class="line"><span class="comment"># 以后台（-d）方式打开新的容器并命名，-t 表示分配伪终端tty，-i 表示以交互模式打开，-p 表示把本机端口8000映射到容器端口80</span></span><br><span class="line">docker run -itd --name=<span class="string">&#x27;centos&#x27;</span> -p 8000:80 &#123;IMAGE ID&#125; /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使容器不联网</span></span><br><span class="line">docker run --network none &#123;IMAGE ID&#125; /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复用卷挂载</span></span><br><span class="line">docker run --name myubuntu -v /tmp:/tmp ubuntu:22.04</span><br><span class="line">docker run --name hello --volumes-from myubuntu ubuntu:22.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除不需要的容器</span></span><br><span class="line">docker container <span class="built_in">rm</span> &#123;CONTAINER ID&#125;</span><br><span class="line"><span class="comment"># 把容器转存镜像</span></span><br><span class="line"><span class="comment"># -a 提交的镜像作者；-m 说明文字；cv-ubuntu 镜像名；v1 镜像标签</span></span><br><span class="line">docker commit -a <span class="string">&quot;jinzhongxu&quot;</span> -m <span class="string">&quot;my new cv image&quot;</span> &#123;CONTAINER ID&#125; cv-ubuntu:v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有的容器 -f 表示 force 强制删除 -q 表示只列出容器ID</span></span><br><span class="line">docker container <span class="built_in">rm</span> -f <span class="variable">$&#123;docker ps -aq&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多请允许如下命令</span></span><br><span class="line">docker container --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p>注意:</p>
<ol>
<li>CONTAINER ID 和 IMAGE ID 只需要输入前几个字符，只要能够唯一识别它们；</li>
<li>docker image 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。image 文件可以看作是容器的模板；</li>
<li>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image；</li>
<li>一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作；</li>
</ol>
<p>docker container 设置自启动一般推荐使用 always 参数：–restart&#x3D;always，更多参数取值如下：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--restart</span><br><span class="line">	no</span><br><span class="line">		默认策略，在容器退出时不重启容器</span><br><span class="line">	on-failure</span><br><span class="line">		在容器非正常退出时（退出状态非0），才会重启容器</span><br><span class="line">	on-failure:3</span><br><span class="line">		在容器非正常退出时重启容器，最多重启3次</span><br><span class="line">	always</span><br><span class="line">		在容器退出时总是重启容器</span><br></pre></td></tr></table></figure>

<p>具体的开启自启和取消自启的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启自启</span></span><br><span class="line">docker update --restart=always &#123;CONTAINER ID&#125;</span><br><span class="line"><span class="comment"># 取消自启</span></span><br><span class="line">docker update --restart=no &#123;CONTAINER ID&#125;</span><br></pre></td></tr></table></figure>

<h1 id="制作-docker-image"><a href="#制作-docker-image" class="headerlink" title="制作 docker image"></a>制作 docker image</h1><p>需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image. Docker 根据 该文件生成二进制的 image 文件。</p>
<p>首先，克隆项目</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/xxx/demos.git</span><br><span class="line"><span class="built_in">cd</span> demos</span><br></pre></td></tr></table></figure>

<p>在项目的根目录下，新建一个文本文件<code>.dockerignore</code>, 把要排除的文件或文件夹路径按行写到文件里，参考如下，即说明那些不需要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure>

<p>在项目的根目录下，新建一个文本文件 Dockerfile，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:11</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br><span class="line">CMD node demos/01.js</span><br></pre></td></tr></table></figure>

<p>说明如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:11：该 image 文件继承官方的 node image，冒号表示标签，这里标签是 11，即 11 版本的 node。</span><br><span class="line">COPY . /app：将当前目录下的所有文件（除了.dockerignore 排除的路径），都拷贝进入 image 文件的/app目录。</span><br><span class="line">WORKDIR /app：指定接下来的工作路径为 /app。</span><br><span class="line">RUN npm install：在/app目录下，运行 npm install 命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</span><br><span class="line">EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。</span><br><span class="line">CMD node demos/01.js：表示容器启动后自动执行 node demos/01.js。RUN命令与CMD命令的区别在哪里？简单说，RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个 RUN 命令，但是只能有一个 CMD 命令。注意，指定了 CMD 命令以后，docker container run 命令就不能附加命令了（比如前面的 /bin/bash），否则它会覆盖 CMD 命令。</span><br></pre></td></tr></table></figure>

<p>创建 image 文件. 有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t demo .</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker image build -t demo:0.0.1 .</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latest</code>. 最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</p>
<p>如果运行成功，就可以看到新生成的 image 文件<code>demo</code>了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p>发布 image 的命令参考上面。</p>
<h2 id="常见保留字"><a href="#常见保留字" class="headerlink" title="常见保留字"></a>常见保留字</h2><ul>
<li>FROM: <code>FROME ubuntu:22.04</code> 构建新镜像基于的基础镜像。Dockerfile中第一条必须是 FROM</li>
<li>MAINTAINER: <code>MAINTAINER xjz xjz@gmail.com</code> 镜像维护者姓名和邮箱</li>
<li>RUN: <code>RUN apt install vim -y</code> 容器构建时（docker build）执行的命令，支持两种格式，一种是shell（等同于终端中执行的SHELL命令<code>RUN apt install vim -y</code>），一种是exec命令<code>RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;]</code>，后两个为参数，等同于 <code>RUN ./test.php dev offline</code></li>
<li>ENV: <code>ENV MYPATH /usr/local</code> 配置环境变量，指定 <code>export MYPATH=/usr/local</code></li>
<li>WORKDIR: <code>WORKDIR /usr/local</code> 指定在创建容器后，终端默认登录的工作目录</li>
<li>USER: <code>USER root</code> 指定该镜像以什么用户执行，不指定，默认为 root</li>
<li>VOLUME: <code>VOLUME [&quot;/tmp&quot;, &quot;/tmp&quot;]</code> 作用同 <code>-v /tmp:/tmp</code>，指定挂载目录</li>
<li>ADD: <code>ADD java.tar.gz /usr/local/java</code> 把本地压缩包拷贝到镜像，并会自动解压缩tar压缩包。添加时并重命名<code>ADD docker_boot-0.0.1-SNAPSHOT.jar hello_docker.jar</code></li>
<li>COPY: <code>COPY java /usr/local/java</code> 把本地文件夹拷贝到镜像，不解压</li>
<li>EXPOSE: <code>EXPOSE 80</code> 启动容器是暴露的端口</li>
<li>CMD: <code>CMD ./start-jupyter.sh</code> or <code>CMD [&quot;./start-jupyter.sh&quot;, &quot;run&quot;]</code> 容器启动命令，也支持shell命令和exec命令。指定容器启动后要做的事情。Dockerfile中可以有多个CMD指令，<strong>但只有最后一个生效，CMD会被docker run之后的参数替换</strong></li>
<li>ENTRYPOINT: <code>ENTRYPOINT [&quot;/bin/ping&quot;, &quot;-c&quot;, &quot;3&quot;]</code> 也是用来指定一个容器启动时要运行的命令，类似于CMD，但是ENTRYPOINT不会被docker run后面的命令覆盖，如果docker run后面的命令行参数会被当作参数送给ENTRYPOINT指令指定的程序。其实ENTRYPOINT也可以被覆盖：<code>docker run --entrypoint hostname ubuntu:22.04</code>。有些命令运行后就退出了，如<code>/etc/init.d/ssh start</code>，有些命令会一直运行，如<code>/bin/bash</code>。如果想要容器启动后一直运行应该选择常驻（一直运行）的命令作为ENTRYPOINT或CMD，如上面的<code>/bin/bash</code>，或者最后增加上常驻命令。</li>
</ul>
<p>ENTRYPOINT 和 CMD 搭配使用，ENTRYPOINT 用作执行命令，CMD用作传参数例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只有ENTRYPOINT和CMD都用Exec表示法, 才能得到预期的效果</span></span><br><span class="line">ENTRYPPOINT [<span class="string">&quot;/bin/ping&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;3&quot;</span>]</span><br><span class="line">CMD [<span class="string">&quot;localhost&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>执行时，可以在docker run后指定新参数覆盖CMD参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it myubuntu:v1.0 www.baidu.com</span><br></pre></td></tr></table></figure>


<h1 id="docker-network"><a href="#docker-network" class="headerlink" title="docker network"></a>docker network</h1><p>docker 服务默认会创建一个docker0网桥（其上有一个docker0内部接口），该网桥网络的名称为docker0，它在内核层联通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。docker默认指定docker0接口的IP地址和子网掩码，让主机和容器之间可以通过网桥相互图像。</p>
<p>docker network 分为 bridge, host, none, container 和自建网络。</p>
<ul>
<li>bridge: 为每一个容器分配、设置IP等，并将容器连接到一个docker0。即虚拟网桥模式，<strong>默认为该模式</strong>：<code>docker run ubuntu</code>。网桥docker0创建一对对等虚拟设备接口，一个叫veth（宿主机docker0），一个叫eth0（容器内），两者一一匹配。整个宿主机的网桥模式都是docker0，类似一个交换机有一堆接口，每个接口都叫做veth，在本地主机和容器内创建一个虚拟接口，并让他们彼此联通，这样一对接口叫做veth pari.</li>
<li>host: 容器将不会虚拟出自己的网卡，配置自己的IP等，而是直接使用宿主机的IP和端口与外界通信，不在需要额外进行NAT转换。与宿主机公用一个network namespace，容器不会虚拟出自己的网卡：<code>docker run --network host ubuntu</code></li>
<li>none: 容器有独立的 Network namespace，但并没有对其进行任何网络设置，如分配veth pair和网桥连接、IP等，不常用：<code>docker run --network none ubuntu</code></li>
<li>container: 新创建的容器不会创建自己的网卡和配置自己的IP，而是和一个指定的容器共享IP、端口范围等：<code>docker run --network container:容器名或者容器ID</code>。当指定的共享容器关闭时，当前的容器网络也会断开，只会存在本地回环127.0.0.1。</li>
<li>自建网络：<code>docker network create mybridge</code>，使用自建网络:<code>docker run --network mybridge ubuntu</code>，使用自建网络的好处是除了使用可变的IP互相PING通或连接通外，还可以使用容器名进行PING通或连接上。当容器IP发生改变不会影响使用容器名PING通。建议使用这种方式。</li>
</ul>
<p>使用bridge模式当容器关闭后重启可能会导致容器IP发生改变，原IP会分配给关闭期间新创建的容器。需要注意。</p>
<h1 id="容器导出和导入镜像"><a href="#容器导出和导入镜像" class="headerlink" title="容器导出和导入镜像"></a>容器导出和导入镜像</h1><p>本节演示从拉取基镜像，然后增加个人内容，从容器导出镜像文件(Export a container’s filesystem as a tar archive，不建议这样导出镜像)。把导出的镜像文件拷贝到新的电脑上，然后再导入使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取最新 Ubuntu 镜像</span></span><br><span class="line">docker pull ubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment">#REPOSITORY   TAG       IMAGE ID       CREATED       SIZE</span></span><br><span class="line"><span class="comment">#ubuntu       latest    df5de72bdb3b   10 days ago   77.8MB</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行镜像 ubuntu</span></span><br><span class="line">docker run -itd --name=<span class="string">&#x27;ubuntu-base&#x27;</span> df5de72bdb3b /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看运行的镜像</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment">#CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES</span></span><br><span class="line"><span class="comment">#d090dfda0f04   df5d      &quot;/bin/bash&quot;   4 seconds ago   Up 2 seconds             ubuntu-base</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入镜像并进行操作</span></span><br><span class="line">docker <span class="built_in">exec</span> -it d090 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出容器到压缩文件中</span></span><br><span class="line">docker <span class="built_in">export</span> d090dfda0f04 &gt; myubuntu.tar</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">docker <span class="built_in">export</span> -o myubuntu.tar d090dfda0f04</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">docker container <span class="built_in">export</span> -o myubuntu.tar d090dfda0f04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把压缩文件导入成新镜像</span></span><br><span class="line"><span class="comment"># myubuntu.tar 为压缩文件</span></span><br><span class="line"><span class="comment"># my/ubuntu 为导入后的镜像仓库源REPOSITORY</span></span><br><span class="line"><span class="comment"># v1 为导入后的镜像标签tag</span></span><br><span class="line"><span class="built_in">cat</span> myubuntu.tar | docker import - my/ubuntu:v1</span><br><span class="line"><span class="comment"># or </span></span><br><span class="line">docker import myubuntu.tar my/ubuntu:v1</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">docker image import myubuntu.tar my/ubuntu:v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看导入的镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment">#REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span></span><br><span class="line"><span class="comment">#my/ubuntu    v1        6c5e97787cfc   3 seconds ago   77.8MB</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行新镜像</span></span><br><span class="line">docker run -itd --name=<span class="string">&#x27;ubuntu-personal&#x27;</span> 6c5e97787cfc /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment">#CONTAINER ID   IMAGE          COMMAND       CREATED              STATUS              PORTS     NAMES</span></span><br><span class="line"><span class="comment">#cf6f1be73bb1   6c5e97787cfc   &quot;/bin/bash&quot;   About a minute ago   Up About a minute             ubuntu-personal</span></span><br><span class="line"><span class="comment">#d090dfda0f04   df5d           &quot;/bin/bash&quot;   10 minutes ago       Up 10 minutes                 ubuntu-base</span></span><br></pre></td></tr></table></figure>
<p>上面的方法其实是将容器的文件系统导出为 tar 存档，也可以先把容器打标签成本地镜像，然后用下面的本地镜像导出和导入镜像到其他主机使用。容器打标签成镜像方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把容器转存镜像</span></span><br><span class="line"><span class="comment"># -a 提交的镜像作者；-m 说明文字</span></span><br><span class="line">docker commit -a <span class="string">&quot;jinzhongxu&quot;</span> -m <span class="string">&quot;my new image&quot;</span> &#123;CONTAINER ID&#125; &#123;IMAGE NAME&#125;:&#123;TAG&#125;</span><br></pre></td></tr></table></figure>

<h1 id="镜像导出和导入镜像"><a href="#镜像导出和导入镜像" class="headerlink" title="镜像导出和导入镜像"></a>镜像导出和导入镜像</h1><p>同容器导出和导入镜像，主要区别是，使用的命令从 <code>export</code>&#x2F;<code>import</code> 分别变为 <code>save</code>&#x2F;<code>load</code>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment">#REPOSITORY      TAG       IMAGE ID       CREATED          SIZE</span></span><br><span class="line"><span class="comment">#person/ubuntu   v1        e42208a4c3ce   13 minutes ago   77.8MB</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出镜像</span></span><br><span class="line">docker save -o person.tar e42208a4c3ce</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">docker save &gt; person.tar e42208a4c3ce</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">docker image save -o person.tar e42208a4c3ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再新的服务器上导入镜像压缩文件</span></span><br><span class="line">docker load -i person.tar</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">docker image load -i person.tar</span><br><span class="line"><span class="comment">#b4b3a9fb5a5c: Loading layer [==================================================&gt;]  80.36MB/80.36MB</span></span><br><span class="line"><span class="comment">#Loaded image ID: sha256:e42208a4c3ce49fdba41f504990f85554429a20a03d69a188d8efe3aef0d97b4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment">#REPOSITORY   TAG       IMAGE ID       CREATED          SIZE</span></span><br><span class="line"><span class="comment">#&lt;none&gt;       &lt;none&gt;    e42208a4c3ce   16 minutes ago   77.8MB</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给镜像打标签</span></span><br><span class="line">docker tag e42208a4c3ce person/ubuntu:v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment">#REPOSITORY      TAG       IMAGE ID       CREATED          SIZE</span></span><br><span class="line"><span class="comment">#person/ubuntu   v1        e42208a4c3ce   17 minutes ago   77.8MB</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="镜像和容器导入导出的区别"><a href="#镜像和容器导入导出的区别" class="headerlink" title="镜像和容器导入导出的区别"></a>镜像和容器导入导出的区别</h1><ol>
<li>镜像导入是一个复制的过程，容器导入是将当前容器变成一个新的镜像；</li>
<li>docker save 命令保存的是镜像（image），docker export 命令保存的是容器（container）；</li>
<li>export 命令导出的 tar 文件略小于 save 命令导出的；</li>
<li>因为 export 导出的是容器，export 导出的文件在 import 导入时，无法保留镜像所有的历史（即每一层 layer 信息），不能进行回滚操作。而 save 是根据镜像来的，所以导入时可以完整保留下每一层 layer 信息；</li>
<li>docker load 不能对导入的镜像重命名，而 docker import 导入可以为镜像指定新名称。</li>
</ol>
<p>注意：<font color=red> 测试发现 docker 20.10.9 运行 ubuntu22.04 出现异常。</font><br><strong>问题描述：</strong><br>外网 docker 20.10.18 基于 ubuntu22.04 安装 基于 miniconda 的 python 环境，并安装支持 GPU 的 torch 和 torchvision，测试能够在 python 中调用服务器 GPU。导出该镜像并刻录到内网，内网部署 docker 20.10.9，加载镜像后能够启动，但 python 无法正常使用，出现 ipython （Original error was: PyCapsule_Import could not import module “datetime” 和 could not start threads 错误）和 numpy （import numpy 出现 OpenBLAS blas_thread_init: pthread_create failed for thread 1 of 999: Operation not permitted OpenBLAS blas_thread_init: RLIMIT_NPROC -1 current, -1 max）。但把镜像拷贝到其他一台能够连接外网的服务器（安装有 docker 20.10.11）上时，能够正常运行。<br><strong>问题排查：</strong><br>经查发现是 ubuntu21.10 和 fedora35 开始使用glibc2.34甚至更高的版本。在glibc2.34 版本里面，开始使用一个名为 clone3 的系统调用。通常情况下，容器里面所有的系统调用都会被 docker 捕获，然后 docker 决定如何处理它们。如果 docker 中没有为特定系统调用指定策略，则默认的策略会通知容器这边”Permission Denied”。但是，如果 Glibc 收到此错误，它不会回退。它仅在收到响应“此系统调用不可用”时才执行此操作。<br><strong>解决方法：</strong></p>
<ol>
<li><p>运行容器的时候，加上这个参数来绕过docker系统调用限制</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--security-opt seccomp=unconfined</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line">docker run -itd --name gputest --gpus all -p 9090:80 -v /workspace:/data --security-opt seccomp=unconfined ubuntu22-gpu:v1 /bin/bash</span><br></pre></td></tr></table></figure>
<p> 这能够使得上面的 python 运行但会有很大的问题，一个是你的容器将变得不安全，另一个是这些参数在构建镜像的时候是不可用的。</p>
</li>
<li><p>将 docker 升级到 20.10.11 以上的版本</p>
</li>
<li><p>不要使用基础镜像 ubuntu22.04，而是使用 ubuntu18.04</p>
</li>
</ol>
<h1 id="容器端口映射"><a href="#容器端口映射" class="headerlink" title="容器端口映射"></a>容器端口映射</h1><p>有时候在我们运行的容器中有一些服务需要外部网络（docker 容器外）访问，此时就需要在我们从镜像运行容器时指定好本机端口和容器端口的映射，方便在本机直接访问容器中的服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把容器的80端口映射到主机的9000端口，默认是“0.0.0.0”，即所有能访问本机的设备都可以访问</span></span><br><span class="line">docker run -itd --name <span class="string">&quot;ubuntu-python&quot;</span> -p 9000:80 &#123;IMAGE ID&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把容器的80端口映射到主机的9000端口，设置为“127.0.0.1”，即只有本机可以访问</span></span><br><span class="line">docker run -itd --name <span class="string">&quot;ubuntu-python&quot;</span> -p 127.0.0.1:9000:80 &#123;IMAGE ID&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把容器的80端口映射到主机的随机端口</span></span><br><span class="line">docker run -itd --name <span class="string">&quot;ubuntu-python&quot;</span> -p 127.0.0.1::80 &#123;IMAGE ID&#125;</span><br><span class="line"><span class="comment"># 可以通过如下命令查看映射的本机端口</span></span><br><span class="line">docker ps</span><br><span class="line">docker port &#123;CONTAINER ID&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有多个端口映射</span></span><br><span class="line"><span class="comment"># 把容器的80端口映射到主机的9000端口，把容器的8080端口映射到主机的9090端口</span></span><br><span class="line">docker run -itd --name <span class="string">&quot;ubuntu-python&quot;</span> -p 9000:80 -p 9090:8080 &#123;IMAGE ID&#125;</span><br></pre></td></tr></table></figure>

<h1 id="给运行的容器新添加端口映射等其他涉及到非CPU、内存的操作"><a href="#给运行的容器新添加端口映射等其他涉及到非CPU、内存的操作" class="headerlink" title="给运行的容器新添加端口映射等其他涉及到非CPU、内存的操作"></a>给运行的容器新添加端口映射等其他涉及到非CPU、内存的操作</h1><p>对于运行的容器，更改CPU和内存、设置随docker自动开启等都可以使用 <code>docker update</code> 来完成，但是其他涉及到修改容器的端口、挂载点、GPU等需要停止docker服务，然后修改对应容易的配置文件才能完成。关于更新运行容器的CPU和内存等方法可以查看帮助：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker update --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p>目前 docker 没有直接为运行的容器动态增加端口映射的方法。建议从镜像运行容器时考虑清楚哪些端口需要进行映射。如果真的需要为运行的容器再增加新端口映射，可以考虑如下方法：</p>
<h2 id="重新运行容器"><a href="#重新运行容器" class="headerlink" title="重新运行容器"></a>重新运行容器</h2><p>最简单的方法就是直接重新再运行容器。如果已经运行的容器个人增加了一些不方便拷贝出来的内容，那么可以先将该容器 commit 成镜像，然后再从新镜像运行容器，增加新端口映射。<br>容器 commit 镜像的方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把容器转存镜像</span></span><br><span class="line"><span class="comment"># -a 提交的镜像作者；-m 说明文字；cv-ubuntu 镜像名；v1 镜像标签</span></span><br><span class="line">docker commit -a <span class="string">&quot;jinzhongxu&quot;</span> -m <span class="string">&quot;my new cv image&quot;</span> &#123;CONTAINER ID&#125; cv-ubuntu:v1</span><br></pre></td></tr></table></figure>

<h2 id="修改容器配置文件"><a href="#修改容器配置文件" class="headerlink" title="修改容器配置文件"></a>修改容器配置文件</h2><p>如果运行的容器体量太多（如几十G），上面的方法就显得有些不太合适，那么这里提供一种方法就是修改运行容器的配置文件。但需要暂时关闭 docker 服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop docker</span><br></pre></td></tr></table></figure>

<p>然后修改配置文件 <code>hostcongfig.json</code>、<code>config.v2.json</code>(如果该文件中有记录)。</p>
<p>查看容器配置信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect &#123;CONTAINER ID&#125;</span><br></pre></td></tr></table></figure>

<p>进入配置文件目录，修改配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以 Ubuntu 为例</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/containers</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后进入以容器id开头的长名目录</span></span><br><span class="line"><span class="comment"># 修改里面的 PortBindings</span></span><br><span class="line">vim hostconfig.json</span><br><span class="line">vim config.v2.json</span><br></pre></td></tr></table></figure>

<p>修改成功后，然后重启 docker 服务。</p>
<h1 id="挂载宿主机目录到容器"><a href="#挂载宿主机目录到容器" class="headerlink" title="挂载宿主机目录到容器"></a>挂载宿主机目录到容器</h1><p>有时候需要容器能够访问宿主机的某些文件或文件夹，此时，我们可以从镜像创建容器时通过设置挂载点的方式，将宿主机的目录挂载到容器的某个目录，使得容器内部就可以访问宿主机的文件夹。注意，与上面的 <code>cp</code> 命令的区别。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把宿主机的目录 /home/jinzhongxu/Documents 挂载到容器的 /data 目录</span></span><br><span class="line"><span class="comment"># 注意镜像中如果没有挂载点目录 /data，则会自动创建</span></span><br><span class="line"><span class="comment"># ubuntu:latest 为镜像名，也可以用镜像 ID</span></span><br><span class="line"><span class="comment"># -v 参数将宿主机的 /home/jinzhongxu/Documents 挂载到容器的 /data</span></span><br><span class="line">docker run -itd --name <span class="string">&#x27;ubuntu-test&#x27;</span> -v /home/jinzhongxu/Documents:/data ubuntu:latest /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认挂载的路径权限是读写 rw，可在挂载时自定义权限，如只读 ro</span></span><br><span class="line">docker run -itd --name <span class="string">&#x27;ubuntu-test&#x27;</span> -v /home/jinzhongxu/Documents:/data:ro ubuntu:latest /bin/bash</span><br></pre></td></tr></table></figure>

<p>有时候，我们需要创建一个新容器，挂载信息同已经创建的一个容器，那么我们可以使用如下方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用同上面的容器 &#x27;ubuntu-test&#x27; 相同的挂载信息</span></span><br><span class="line"><span class="comment"># 将宿主机的 /home/jinzhongxu/Documents 挂载到容器的 /data</span></span><br><span class="line"><span class="comment"># ubuntu:latest 为镜像名，也可以用镜像 ID</span></span><br><span class="line">docker run -itd --name <span class="string">&#x27;ubuntu-test2&#x27;</span> --volumes-from ubuntu-test ubuntu:latest /bin/bash</span><br></pre></td></tr></table></figure>
<p>此时，创建的新容器 ‘ubuntu-test2’ 同旧容器 ‘ubuntu-test’ 具有相同的挂载信息。</p>
<h1 id="容器-SSH-访问宿主机"><a href="#容器-SSH-访问宿主机" class="headerlink" title="容器 SSH 访问宿主机"></a>容器 SSH 访问宿主机</h1><p>从容器内部通过SSH访问宿主机能够为容器和宿主机提供更好的交互方式。此时，我们只需要知道宿主机的 docker0 IP，以及宿主机用户名和密码即可。</p>
<p>查看宿主机 docker0 IP 方法是，在宿主机上执行 <code>ifconfig</code> 命令，查看 docker0 对应的 IP，一般为 172.17.0.1;</p>
<p>通过如下方式访问宿主机：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我这里用户名是 jinzhongxu</span></span><br><span class="line">ssh jinzhongxu@172.17.0.1</span><br><span class="line"><span class="comment"># 然后输入用户名 jinzhongxu 在宿主机上的密码即可</span></span><br><span class="line"><span class="comment"># 注意，需要宿主机打开密码认证登录（/etc/ssh/sshd_config, PasswordAuthentication yes）</span></span><br></pre></td></tr></table></figure>

<h1 id="本地私有仓库-docker-hub"><a href="#本地私有仓库-docker-hub" class="headerlink" title="本地私有仓库 docker hub"></a>本地私有仓库 docker hub</h1><p>有时候使用 Docker Hub 这样的公共仓库可能不方便，如内网环境下。此时，用户可以创建一个本地仓库供私人使用。</p>
<p>docker-registry 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 docker-registry v2.x 版本。</p>
<h2 id="安装-docker-registry"><a href="#安装-docker-registry" class="headerlink" title="安装 docker-registry"></a>安装 docker-registry</h2><p>如果在能联网的服务器上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动从官网下载 registry 镜像并允许</span></span><br><span class="line"><span class="comment"># 把本地 5000 映射到容器 5000 端口</span></span><br><span class="line"><span class="comment"># 会自动创建本地目录 /opt/data/registry，以后本地镜像 push 到该目录</span></span><br><span class="line"><span class="comment"># --restart=always 表示重启电脑时，自动运行该容器</span></span><br><span class="line">docker run -d -p 5000:5000 --restart=always -v /opt/data/registry:/var/lib/registry --name registry registry</span><br></pre></td></tr></table></figure>

<p>如果想在内网服务器使用，需要现在能够连接互联网的机器上下载 registry 镜像，然后把该镜像导出，刻录到内网，然后在内网服务器上加载镜像并打标签为 registry:latest（以个人喜好，我这里以此名和标签做演示）。然后使用下面的方式运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart=always --name registry -p 5000:5000 -v /opt/data/registry:/var/lib/registry registry:latest</span><br></pre></td></tr></table></figure>
<p>此时，registry 容器在运行，并监控 5000 端口。</p>
<h2 id="在私有仓库上传、搜索、下载镜像"><a href="#在私有仓库上传、搜索、下载镜像" class="headerlink" title="在私有仓库上传、搜索、下载镜像"></a>在私有仓库上传、搜索、下载镜像</h2><p>创建好私有仓库之后，就可以使用 docker tag 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 127.0.0.1:5000，把镜像打标签，以 127.0.0.1:5000 开头：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag ubuntu:latest 127.0.0.1:5000/ubuntu18-gpu:v1</span><br></pre></td></tr></table></figure>
<p>提交镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 127.0.0.1:5000/ubuntu18-gpu:v1</span><br></pre></td></tr></table></figure>
<p>搜索私有仓库中的镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1:5000/v2/_catalog</span><br></pre></td></tr></table></figure>
<p>结果大概这样</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;repositories&quot;:[&quot;ubuntu18-gpu&quot;]&#125;</span><br></pre></td></tr></table></figure>
<p>从仓库中获取指定镜像的标签</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1:5000/v2/ubuntu18-gpu/tags/list</span><br></pre></td></tr></table></figure>
<p>结果大概这样</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;ubuntu18-gpu&quot;,&quot;tags&quot;:[&quot;v1&quot;]&#125;</span><br></pre></td></tr></table></figure>

<p>从私有仓库下载镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 127.0.0.1:5000/ubuntu18-gpu:v1</span><br></pre></td></tr></table></figure>

<h2 id="配置非-https-仓库地址"><a href="#配置非-https-仓库地址" class="headerlink" title="配置非 https 仓库地址"></a>配置非 https 仓库地址</h2><p>如果你不想使用 127.0.0.1:5000 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 192.168.199.100:5000 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。<br>这是因为 Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 HTTPS 访问的私有仓库。<br><strong>Ubuntu 16.04+, Debian 8+, centos 7</strong><br>对于使用 systemd 的系统，请在 &#x2F;etc&#x2F;docker&#x2F;daemon.json 中写入如下内容（如果文件不存在请新建该文件）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">                       <span class="string">&quot;https://registry.docker-cn.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">                       <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">                       <span class="string">&quot;https://mirror.baidubce.com&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;192.168.199.100:5000&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;debug&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;experimental&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;runtimes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;nvidia&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nvidia-container-runtime&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;runtimeArgs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol>
<li>该文件必须符合 json 规范，否则 Docker 将不能启动</li>
<li><font color=red>需要重启 docker 才能生效</font></li>
<li>上面我增加了容器调用宿主机服务器 GPU 的运行时，根据个人情况添加</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="容器中安装-opencv-python"><a href="#容器中安装-opencv-python" class="headerlink" title="容器中安装 opencv-python"></a>容器中安装 opencv-python</h2><p>Ubuntu18.04 容器中安装 opencv-python 需要安装一些依赖包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install ffmpeg libsm6 libxext6  -y</span><br></pre></td></tr></table></figure>

<h2 id="容器中运行-GUI-界面在宿主机显示"><a href="#容器中运行-GUI-界面在宿主机显示" class="headerlink" title="容器中运行 GUI 界面在宿主机显示"></a>容器中运行 GUI 界面在宿主机显示</h2><p>以 deeplabcut[gui] 镜像为例，先拉取镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull deeplabcut/deeplabcut:2.2.1.1-gui-cuda11.0.3-runtime-ubuntu18.04</span><br></pre></td></tr></table></figure>
<p>然后设置宿主机运行远程连接 X server</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhost +</span><br></pre></td></tr></table></figure>
<p>启动镜像，注意把本地 DISPLAY 设置上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name deeplabcut --gpus=all -v /tmp/.X11-unix:/tmp/.X11-unix -e DISPLAY=unix<span class="variable">$DISPLAY</span> deeplabcut/deeplabcut:2.2.1.1-gui-cuda11.0.3-runtime-ubuntu18.04 /bin/bash</span><br></pre></td></tr></table></figure>
<p>进入容器启动 GUI 服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m deeplabcut</span><br></pre></td></tr></table></figure>
<p>镜像包依赖问题可能需要把 python 包 wxpython 更改为 4.0.7:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install wxPython==<span class="number">4.0</span><span class="number">.7</span>.post2</span><br></pre></td></tr></table></figure>

<h2 id="容器中运行-pytorch-多-GPU-模型"><a href="#容器中运行-pytorch-多-GPU-模型" class="headerlink" title="容器中运行 pytorch 多 GPU 模型"></a>容器中运行 pytorch 多 GPU 模型</h2><p>在容器中运行 pytorch 多 GPU 模型可能会出现如下错误：</p>
<blockquote>
<p>ERROR: Unexpected bus error encountered in worker. This might be caused by insufficient shared memory (shm). Dataloader中的num_workers设置与docker的shared memory相关问题</p>
</blockquote>
<p>这是因为 docker 容器内 shm_size 默认大小 64M 太小导致的问题，有两个解决思路：</p>
<ol>
<li>在 Dataloader 中将 num_worker 设置为 0，只需在代码中修改比较简单，缺点是训练过程变慢，特别是对较大数据例如视频图像</li>
<li>改变容器中 shared_memory 大小，如下： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name mmdet-dlc-multi-gpus --gpus <span class="string">&#x27;&quot;device=1,2&quot;&#x27;</span> -p 33336:80 --shm-size 8G mmdet-dlc:v1.2 /bin/bash</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="容器内存和CPU限制"><a href="#容器内存和CPU限制" class="headerlink" title="容器内存和CPU限制"></a>容器内存和CPU限制</h2><p>有一次在容器中运行一个程序直接爆满宿主机内存，导致服务器无法使用。此时，可以尝试更新容器的内存限制，然后再运行程序，方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mmdet-dlc-tencent 为容器名</span></span><br><span class="line"><span class="comment"># 此代码设置容器可使用内存为 40 GB</span></span><br><span class="line">docker update --memory 40g --memory-swap 42g mmdet-dlc-tencent</span><br></pre></td></tr></table></figure>
<p>上面命令设置后，容器就只能使用宿主机内存 40000 MB，但可以使用所有的交换分区。同时，当程序遇到内存不够时会出现 OOM（Out Of Memory）异常退出，解决方法是，在创建容器时，设置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 oom-kill-disable 能够避免内存不够时异常退出</span></span><br><span class="line"><span class="comment"># memory-swap 一般不设置或设置为0，表示当内存不够时使用所有交换分区。或设置为比 memory 大，多出的为使用的交换分区大小。即其包含了使用的内存和交换分区两者</span></span><br><span class="line">docker run --cpus=<span class="string">&quot;3&quot;</span> --oom-kill-disable --memory=<span class="string">&quot;40000m&quot;</span> --memory-swap=<span class="string">&quot;50g&quot;</span> --name mmdet-dlc-tencent mmdet-dlc:v2.0 bash</span><br><span class="line"><span class="comment"># 或者使用--cpuset-cpus指定使用那几个cpu，该编号对应htop命令列出的CPU编号顺序（不过是从1开始，docker中从0开始）</span></span><br><span class="line">docker run --cpuset-cpus=<span class="string">&quot;0,1,2&quot;</span> --oom-kill-disable --memory=<span class="string">&quot;40000m&quot;</span> --memory-swap=<span class="string">&quot;50g&quot;</span> --name mmdet-dlc-tencent mmdet-dlc:v2.0 bash</span><br><span class="line"><span class="comment"># 或用 0-2 表示 0,1,2</span></span><br><span class="line">docker run --cpuset-cpus=<span class="string">&quot;0-2&quot;</span> --oom-kill-disable --memory=<span class="string">&quot;40g&quot;</span> --memory-swap=<span class="string">&quot;50g&quot;</span> --name mmdet-dlc-tencent mmdet-dlc:v2.0 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker-compose v2 配置 CPU 和内存限制</span></span><br><span class="line">version: <span class="string">&#x27;2&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  colab-hub:</span><br><span class="line">    image: colab-hub:v2.0</span><br><span class="line">    container_name: colab-huber</span><br><span class="line">    user: <span class="string">&#x27;root&#x27;</span></span><br><span class="line">    cpuset: <span class="string">&#x27;0-59&#x27;</span></span><br><span class="line">    mem_limit: <span class="string">&#x27;50g&#x27;</span></span><br><span class="line">    memswap_limit: <span class="string">&#x27;52g&#x27;</span></span><br><span class="line">    oom_kill_disable: <span class="literal">true</span></span><br><span class="line">    expose:</span><br><span class="line">      - <span class="string">&#x27;8000&#x27;</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&#x27;38000:8000&#x27;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&#x27;/disk0:/disk0&#x27;</span></span><br><span class="line">      - <span class="string">&#x27;/disk1:/disk1&#x27;</span></span><br><span class="line">    restart: <span class="string">&#x27;on-failure&#x27;</span></span><br><span class="line">    environment:</span><br><span class="line">      - TZ=Asia/Shanghai</span><br><span class="line">      - LANG=<span class="string">&quot;C.UTF-8&quot;</span></span><br><span class="line">    shm_size: <span class="string">&#x27;8g&#x27;</span></span><br><span class="line">    deploy:</span><br><span class="line">      resources:</span><br><span class="line">        reservations:</span><br><span class="line">          devices:</span><br><span class="line">            - driver: <span class="string">&#x27;nvidia&#x27;</span></span><br><span class="line">              <span class="comment">#device_ids: [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;]</span></span><br><span class="line">              count: <span class="string">&#x27;all&#x27;</span></span><br><span class="line">              capabilities: [<span class="string">&#x27;gpu&#x27;</span>]</span><br><span class="line">    entrypoint: [<span class="string">&#x27;/root/start_jupyterhub.sh&#x27;</span>]</span><br><span class="line">volumes:</span><br><span class="line">  colab-hub_data:</span><br><span class="line">    driver: <span class="built_in">local</span></span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    external: <span class="literal">true</span></span><br><span class="line">    name: colab  <span class="comment"># docker network create colab</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># cpus 表示限制容器只使用 3 个 逻辑CPU</span></span><br><span class="line"><span class="comment"># 可进入容器后，使用如下命令查看 CPU 情况，如下命令尝试使用 5 个CPU，但是容器创建时限制 3 个</span></span><br><span class="line">stress --cpu 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者通过编写 python 多进程程序进行压力测试，代码如下，在 docker 中运行该 Python 程序，在容器外查看使用的 CPU 情况</span></span><br><span class="line"><span class="comment"># Python 程序参加下方 Python 代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可在容器外使用如下命令查看容器资源（包括 CPU、内存、网络、磁盘IO 等）使用情况</span></span><br><span class="line">docker stats</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或使用 htop 查看哪些 CPU 被使用以及使用情况</span></span><br><span class="line">htop</span><br></pre></td></tr></table></figure>
<p>用于测试 docker 中 CPU 分配情况的程序 Python 程序(cpus-limit-test.py)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">t</span>():</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;python argparser&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-c&#x27;</span>, <span class="string">&quot;--cpus&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> parser</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 这里可以设置大于创建容器时指定的CPU个数</span></span><br><span class="line">    parser = t()</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    CPUs = args.cpus</span><br><span class="line">    p = Pool(CPUs)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(CPUs):</span><br><span class="line">        p.apply_async(loop, args=(i,))</span><br><span class="line"></span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>

<p>对容器进行内存现在时有时候会出现错误提示：No swap limit support，此时内存限制是无效的。可以尝试通过如下方法解决：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/default/grub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加如下内容</span></span><br><span class="line">GRUB_CMDLINE_LINUX=<span class="string">&quot;cgroup_enable=memory swapaccount=1&quot;</span></span><br><span class="line"><span class="comment"># 如果本身的 GRUB_CMDLINE_LINUX 后的双引号里有内容，请在后面增加空格后再增加上面的内容 &quot; cgroup_enable=memory swapaccount=1&quot;。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后需要更新引导</span></span><br><span class="line">sudo update-grub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后重启生效</span></span><br><span class="line">sudo shutdown -r now</span><br></pre></td></tr></table></figure>

<h2 id="mac-docker-无法启动"><a href="#mac-docker-无法启动" class="headerlink" title="mac docker 无法启动"></a>mac docker 无法启动</h2><p>mac 中 docker 无法启动，提示：</p>
<blockquote>
<p>com.docker.backend cannot start Exit code 101</p>
</blockquote>
<p>可尝试如下方法解决：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pkill Docker  </span><br><span class="line">killall Docker</span><br></pre></td></tr></table></figure>
<p>然后在重启 docker</p>
<h2 id="nvidia-smi-在-docker-中看不到进程号"><a href="#nvidia-smi-在-docker-中看不到进程号" class="headerlink" title="nvidia-smi 在 docker 中看不到进程号"></a>nvidia-smi 在 docker 中看不到进程号</h2><p>当我们使用 <code>--gpus all</code> 等启动一个想要在 docker 容器中使用 GPU 时，使用命令 <code>nvidia-smi</code> 无法看到当前使用 GPU 的进程 ID，it is related to PID namespaces, the driver is not aware of the PID namespace and thus nvidia-smi in the container doesn’t see any process running. <a target="_blank" rel="noopener" href="https://github.com/NVIDIA/nvidia-docker/issues/179">github-nvidia-docker issue</a>. 一种解决方法是启动容器时，增加上一个参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--pid=host</span><br></pre></td></tr></table></figure>

<p>或者，使用 python 包 <code>py3nvml</code>，方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install </span></span><br><span class="line">pip install py3nvml</span><br><span class="line"></span><br><span class="line"><span class="comment"># usage</span></span><br><span class="line">py3nvml</span><br><span class="line">py3nvml -l 5</span><br></pre></td></tr></table></figure>

<p>同时，py3nvml 作为 python 的一个包，可以在 python 代码中使用来获取 gpu 的实时信息:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> py3nvml</span><br><span class="line"></span><br><span class="line">py3nvml.get_gree_gpus()</span><br></pre></td></tr></table></figure>

<h2 id="迁移-docker-镜像"><a href="#迁移-docker-镜像" class="headerlink" title="迁移 docker 镜像"></a>迁移 docker 镜像</h2><p>默认情况下安装的 docker 会自动把镜像文件存储到 &#x2F;var&#x2F;lib&#x2F;docker 目录下，当我们创建的镜像较多较大时，会导致磁盘空间不足等问题，此时，我们可以尝试将镜像存储路径迁移到其他挂载盘：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止 docker 进程</span></span><br><span class="line">sudo service docker stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 /var/lib/docker 移动到其他磁盘，如 /disk2</span></span><br><span class="line"><span class="comment"># 这里 /disk2 是我新挂载的大容量磁盘</span></span><br><span class="line">sudo <span class="built_in">chmod</span> 775 /disk2</span><br><span class="line">sudo <span class="built_in">mv</span> /var/lib/docker /disk2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改配置文件信息</span></span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 增加如下内容</span></span><br><span class="line"><span class="string">&quot;data-root&quot;</span>: <span class="string">&quot;/disk2/docker&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure>

<h2 id="docker-磁盘清理"><a href="#docker-磁盘清理" class="headerlink" title="docker 磁盘清理"></a>docker 磁盘清理</h2><p>在长时间使用后，docker 镜像会累积，占用大量的磁盘空间。</p>
<h3 id="docker-磁盘分析"><a href="#docker-磁盘分析" class="headerlink" title="docker 磁盘分析"></a>docker 磁盘分析</h3><p>使用如下命令可查看 docker 使用空间情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker system <span class="built_in">df</span></span><br><span class="line"><span class="comment"># 详细信息</span></span><br><span class="line">docker system <span class="built_in">df</span> -v</span><br></pre></td></tr></table></figure>
<h3 id="docker-磁盘清理-1"><a href="#docker-磁盘清理-1" class="headerlink" title="docker 磁盘清理"></a>docker 磁盘清理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清理所有停止的容器、不使用的网络、所有悬空的镜像</span></span><br><span class="line"><span class="comment">#  - all stopped containers</span></span><br><span class="line"><span class="comment">#  - all networks not used by at least one container</span></span><br><span class="line"><span class="comment">#  - all dangling images</span></span><br><span class="line"><span class="comment">#  - all dangling build cache</span></span><br><span class="line">docker system prune</span><br><span class="line"></span><br><span class="line"><span class="comment"># 彻底清理。同时清理未使用的镜像。慎用</span></span><br><span class="line">docker system prune -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理所有悬空的镜像</span></span><br><span class="line">docker image prune</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时清理未使用的镜像</span></span><br><span class="line">docker image prune -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理停止运行的容器</span></span><br><span class="line">docker container prune</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理未使用的卷宗volume</span></span><br><span class="line">docker volume prune</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">docker system prune --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>


<h2 id="容器中使用-systemctl"><a href="#容器中使用-systemctl" class="headerlink" title="容器中使用 systemctl"></a>容器中使用 systemctl</h2><p>当在容器中使用 systemctl 时有时会出现如下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Failed to connect to bus: No such file or directory</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">Failed to get D-Bus connection: Operation not permitted</span><br></pre></td></tr></table></figure>
<p>此时，可以尝试如下方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取 centos8</span></span><br><span class="line">docker pull centos:latest</span><br><span class="line"><span class="comment"># 启动时指定 --privileged 和默认运行 /usr/sbin/init 为 pid 1</span></span><br><span class="line">docker run -itd --privileged --name nginx -p 9980:80 centos:latest /usr/sbin/init</span><br></pre></td></tr></table></figure>
<p>进入容器后，使用命令查看是否可使用 systemctl</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status</span><br></pre></td></tr></table></figure>
<h3 id="centos8-yum-update"><a href="#centos8-yum-update" class="headerlink" title="centos8 yum update"></a>centos8 yum update</h3><p>如果出现 centos8 中无法 <code>yum update</code>，可使用如下方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/mirrorlist/#mirrorlist/g&#x27;</span> /etc/yum.repos.d/CentOS-*</span><br><span class="line">sed -i <span class="string">&#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27;</span> /etc/yum.repos.d/CentOS-*</span><br></pre></td></tr></table></figure>
<h3 id="centos8-中安装-ssh"><a href="#centos8-中安装-ssh" class="headerlink" title="centos8 中安装 ssh"></a>centos8 中安装 ssh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install openssh-clients openssh-server -y</span><br><span class="line">systemctl start sshd</span><br><span class="line">systemctl <span class="built_in">enable</span> sshd</span><br></pre></td></tr></table></figure>
<h3 id="centos8-中安装-nginx"><a href="#centos8-中安装-nginx" class="headerlink" title="centos8 中安装 nginx"></a>centos8 中安装 nginx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc wget epel-release -y</span><br><span class="line">yum install vim htop make net-tools <span class="built_in">which</span> -y</span><br><span class="line">yum install -y pcre pcre-devel</span><br><span class="line">yum install -y zlib zlib-devel</span><br><span class="line">wget https://nginx.org/download/nginx-1.22.1.tar.gz</span><br><span class="line">tar -xvzf nginx-1.22.1.tar.gz </span><br><span class="line"><span class="built_in">cd</span> nginx-1.22.1</span><br><span class="line">./configure --prefix=/usr/local/nginx</span><br><span class="line">make -j 4 <span class="comment"># 指定使用 cpu 个数，加速</span></span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; /usr/lib/systemd/system/nginx.service &lt;&lt;-<span class="string">&quot;EOF&quot;</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=nginx - web server</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/usr/local/nginx/logs/nginx.pid</span><br><span class="line">ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecReload=/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/local/nginx/sbin/nginx -s stop</span><br><span class="line">ExecQuit=/usr/local/nginx/sbin/nginx -s quit</span><br><span class="line">PrivateTmp=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start nginx</span><br><span class="line">systemctl <span class="built_in">enable</span> nginx</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/StivenYang/p/13843397.html">docker国内镜像源</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html">Docker 微服务教程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dotnet261010/p/13283176.html">Docker：docker镜像与容器的导入和导出</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-tutorial.html">runoob.com docker-tutorial</a></li>
<li><a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/network/port_mapping">外部访问容器</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/liu865033503/article/details/100120113">添加和修改docker容器端口映射的方法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiangxianghehe/article/details/77131962">Docker和宿主机之间共享文件</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/889885e75de8">docker 挂载宿主机文件目录</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15642578/5306113">docker容器挂载host宿主机的本地目录，docker容器与宿主机之间互相拷贝文件</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-compose.html">Docker Compose</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43975924/article/details/104046790">docker使用GPU总结</a></li>
<li><a target="_blank" rel="noopener" href="https://gist.github.com/nathzi1505/d2aab27ff93a3a9d82dada1336c45041#file-install-docker-sh-L13">nathzi1505&#x2F;install-docker.sh</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/fly910905/article/details/126473224">Docker运行ubuntu22.04出现异常</a></li>
<li><a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/repository/registry">私有仓库</a></li>
<li><a target="_blank" rel="noopener" href="https://www.k2zone.cn/?p=2356">解决docker警告WARNING: No swap limit support</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://xujinzh.github.io">Jinzhong Xu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xujinzh.github.io/2020/11/05/docker-simple/">https://xujinzh.github.io/2020/11/05/docker-simple/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xujinzh.github.io" target="_blank">J. Xu</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/docker/">docker</a></div><div class="post_share"><div class="social-share" data-image="/img/c29.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/11/06/tensorflow-distribution/" title="TensorFlow 分布式简单介绍"><img class="cover" src="/img/c13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">TensorFlow 分布式简单介绍</div></div></a></div><div class="next-post pull-right"><a href="/2020/11/03/convolution-in-deep-learning/" title="深度学习中不同的卷积操作"><img class="cover" src="/img/c25.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">深度学习中不同的卷积操作</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/09/12/docker-gitlab/" title="docker 安装代码托管平台 gitlab"><img class="cover" src="/img/c1.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-12</div><div class="title">docker 安装代码托管平台 gitlab</div></div></a></div><div><a href="/2023/04/03/install-bitnami-redmine-by-docker/" title="通过 Docker 安装 bitnami redmine"><img class="cover" src="/img/c17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-03</div><div class="title">通过 Docker 安装 bitnami redmine</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/silence.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jinzhong Xu</div><div class="author-info__description">众妙之门</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">390</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">302</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xujinzh"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xujinzh" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xujinzhong027@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://www.mathscv.com" target="_blank" title="MathsCVBlog"><i class="fab fa-j"></i></a><a class="social-icon" href="https://xujinzh.github.io" target="_blank" title="GitHubBlog"><i class="fab fa-github-alt"></i></a><a class="social-icon" href="https://www.mathscv.com/power" target="_blank" title="MathsCVPower"><i class="fab fa-m"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">日本核污染水强排入海！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%94%A8%E9%80%94%EF%BC%8C%E7%9B%AE%E5%89%8D%E6%9C%89%E4%B8%89%E5%A4%A7%E7%B1%BB%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">Docker 的主要用途，目前有三大类：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-%E5%AE%89%E8%A3%85"><span class="toc-number">2.</span> <span class="toc-text">docker 安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85"><span class="toc-number">2.1.</span> <span class="toc-text">在线安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85"><span class="toc-number">2.2.</span> <span class="toc-text">离线安装</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-compose"><span class="toc-number">3.</span> <span class="toc-text">docker-compose</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-compose-%E5%AE%89%E8%A3%85"><span class="toc-number">3.1.</span> <span class="toc-text">docker-compose 安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%B9%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90-docker-compose-yml"><span class="toc-number">3.2.</span> <span class="toc-text">命令行容器自动生成 docker-compose.yml</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA"><span class="toc-number">4.</span> <span class="toc-text">中文显示</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%B6%E5%8C%BA"><span class="toc-number">5.</span> <span class="toc-text">时区</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-%E4%B8%AD%E4%BD%BF%E7%94%A8-GPU"><span class="toc-number">6.</span> <span class="toc-text">docker 中使用 GPU</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-%E4%BD%BF%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text">docker 使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#image"><span class="toc-number">8.</span> <span class="toc-text">image</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#container"><span class="toc-number">9.</span> <span class="toc-text">container</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C-docker-image"><span class="toc-number">10.</span> <span class="toc-text">制作 docker image</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-number">10.1.</span> <span class="toc-text">常见保留字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-network"><span class="toc-number">11.</span> <span class="toc-text">docker network</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%AF%BC%E5%87%BA%E5%92%8C%E5%AF%BC%E5%85%A5%E9%95%9C%E5%83%8F"><span class="toc-number">12.</span> <span class="toc-text">容器导出和导入镜像</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%AF%BC%E5%87%BA%E5%92%8C%E5%AF%BC%E5%85%A5%E9%95%9C%E5%83%8F"><span class="toc-number">13.</span> <span class="toc-text">镜像导出和导入镜像</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%92%8C%E5%AE%B9%E5%99%A8%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.</span> <span class="toc-text">镜像和容器导入导出的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84"><span class="toc-number">15.</span> <span class="toc-text">容器端口映射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%99%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8%E6%96%B0%E6%B7%BB%E5%8A%A0%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E7%AD%89%E5%85%B6%E4%BB%96%E6%B6%89%E5%8F%8A%E5%88%B0%E9%9D%9ECPU%E3%80%81%E5%86%85%E5%AD%98%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">16.</span> <span class="toc-text">给运行的容器新添加端口映射等其他涉及到非CPU、内存的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8"><span class="toc-number">16.1.</span> <span class="toc-text">重新运行容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">16.2.</span> <span class="toc-text">修改容器配置文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95%E5%88%B0%E5%AE%B9%E5%99%A8"><span class="toc-number">17.</span> <span class="toc-text">挂载宿主机目录到容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8-SSH-%E8%AE%BF%E9%97%AE%E5%AE%BF%E4%B8%BB%E6%9C%BA"><span class="toc-number">18.</span> <span class="toc-text">容器 SSH 访问宿主机</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93-docker-hub"><span class="toc-number">19.</span> <span class="toc-text">本地私有仓库 docker hub</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-docker-registry"><span class="toc-number">19.1.</span> <span class="toc-text">安装 docker-registry</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E4%B8%8A%E4%BC%A0%E3%80%81%E6%90%9C%E7%B4%A2%E3%80%81%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F"><span class="toc-number">19.2.</span> <span class="toc-text">在私有仓库上传、搜索、下载镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E9%9D%9E-https-%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80"><span class="toc-number">19.3.</span> <span class="toc-text">配置非 https 仓库地址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">20.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%AE%89%E8%A3%85-opencv-python"><span class="toc-number">20.1.</span> <span class="toc-text">容器中安装 opencv-python</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%BF%90%E8%A1%8C-GUI-%E7%95%8C%E9%9D%A2%E5%9C%A8%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%98%BE%E7%A4%BA"><span class="toc-number">20.2.</span> <span class="toc-text">容器中运行 GUI 界面在宿主机显示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%BF%90%E8%A1%8C-pytorch-%E5%A4%9A-GPU-%E6%A8%A1%E5%9E%8B"><span class="toc-number">20.3.</span> <span class="toc-text">容器中运行 pytorch 多 GPU 模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%86%85%E5%AD%98%E5%92%8CCPU%E9%99%90%E5%88%B6"><span class="toc-number">20.4.</span> <span class="toc-text">容器内存和CPU限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mac-docker-%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8"><span class="toc-number">20.5.</span> <span class="toc-text">mac docker 无法启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nvidia-smi-%E5%9C%A8-docker-%E4%B8%AD%E7%9C%8B%E4%B8%8D%E5%88%B0%E8%BF%9B%E7%A8%8B%E5%8F%B7"><span class="toc-number">20.6.</span> <span class="toc-text">nvidia-smi 在 docker 中看不到进程号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%81%E7%A7%BB-docker-%E9%95%9C%E5%83%8F"><span class="toc-number">20.7.</span> <span class="toc-text">迁移 docker 镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E7%A3%81%E7%9B%98%E6%B8%85%E7%90%86"><span class="toc-number">20.8.</span> <span class="toc-text">docker 磁盘清理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E7%A3%81%E7%9B%98%E5%88%86%E6%9E%90"><span class="toc-number">20.8.1.</span> <span class="toc-text">docker 磁盘分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E7%A3%81%E7%9B%98%E6%B8%85%E7%90%86-1"><span class="toc-number">20.8.2.</span> <span class="toc-text">docker 磁盘清理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8-systemctl"><span class="toc-number">20.9.</span> <span class="toc-text">容器中使用 systemctl</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#centos8-yum-update"><span class="toc-number">20.9.1.</span> <span class="toc-text">centos8 yum update</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#centos8-%E4%B8%AD%E5%AE%89%E8%A3%85-ssh"><span class="toc-number">20.9.2.</span> <span class="toc-text">centos8 中安装 ssh</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#centos8-%E4%B8%AD%E5%AE%89%E8%A3%85-nginx"><span class="toc-number">20.9.3.</span> <span class="toc-text">centos8 中安装 nginx</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">21.</span> <span class="toc-text">参考链接</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/05/vos-feelvos-cvpr2019/" title="FEELVOS, Fast End-to-End Embedding Learning for Video Object Segmentation"><img src="/img/c24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="FEELVOS, Fast End-to-End Embedding Learning for Video Object Segmentation"/></a><div class="content"><a class="title" href="/2024/03/05/vos-feelvos-cvpr2019/" title="FEELVOS, Fast End-to-End Embedding Learning for Video Object Segmentation">FEELVOS, Fast End-to-End Embedding Learning for Video Object Segmentation</a><time datetime="2024-03-05T08:14:48.000Z" title="发表于 2024-03-05 16:14:48">2024-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/04/vos-davis-eval/" title="Video Object Segmentation 评估指标"><img src="/img/c25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Video Object Segmentation 评估指标"/></a><div class="content"><a class="title" href="/2024/03/04/vos-davis-eval/" title="Video Object Segmentation 评估指标">Video Object Segmentation 评估指标</a><time datetime="2024-03-04T03:43:07.000Z" title="发表于 2024-03-04 11:43:07">2024-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/28/vos-stm-network-iccv2019/" title="Video Object Segmentation using Space-Time Memory Networks"><img src="/img/c16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Video Object Segmentation using Space-Time Memory Networks"/></a><div class="content"><a class="title" href="/2024/02/28/vos-stm-network-iccv2019/" title="Video Object Segmentation using Space-Time Memory Networks">Video Object Segmentation using Space-Time Memory Networks</a><time datetime="2024-02-28T03:20:20.000Z" title="发表于 2024-02-28 11:20:20">2024-02-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/04/python-download-speedup/" title="利用 Python 加速下载大文件突破 IP 限速"><img src="/img/c7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="利用 Python 加速下载大文件突破 IP 限速"/></a><div class="content"><a class="title" href="/2024/02/04/python-download-speedup/" title="利用 Python 加速下载大文件突破 IP 限速">利用 Python 加速下载大文件突破 IP 限速</a><time datetime="2024-02-04T10:30:30.000Z" title="发表于 2024-02-04 18:30:30">2024-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/04/exec-cmd-by-bat-in-window/" title="Windows 中使用 bat 执行程序"><img src="/img/c6.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Windows 中使用 bat 执行程序"/></a><div class="content"><a class="title" href="/2024/02/04/exec-cmd-by-bat-in-window/" title="Windows 中使用 bat 执行程序">Windows 中使用 bat 执行程序</a><time datetime="2024-02-04T10:11:31.000Z" title="发表于 2024-02-04 18:11:31">2024-02-04</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Jinzhong Xu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '695ca5d39e2ba2f9feb5',
      clientSecret: '9d4027af6364ff54595b7a8580977ec58c38a5ae',
      repo: 'xujinzh.github.io',
      owner: 'xujinzh',
      admin: ['xujinzh'],
      id: 'a9ebf537b8c6ad2d1b696af797ca5592',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="众,妙,之,门" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>