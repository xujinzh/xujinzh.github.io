<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>三维深度学习简单介绍</title>
    <url>/2019/12/21/3d-dl-intro/</url>
    <content><![CDATA[<p>文章《<a rel="noreferrer noopener" aria-label="超越像素平面：聚焦3D深度学习的现在和未来（在新窗口打开）" href="https://www.jiqizhixin.com/articles/091203" target="_blank">超越像素平面：聚焦 3D 深度学习的现在和未来</a>》（英文版对应《<a rel="noreferrer noopener" aria-label="Beyond the pixel plane: sensing and learning in 3D（在新窗口打开）" href="https://thegradient.pub/beyond-the-pixel-plane-sensing-and-learning-in-3d/" target="_blank">Beyond the pixel plane: sensing and learning in 3D</a>》）中介绍了三维数据的获取，表示，以及三维深度学习的进展。</p>
<a id="more"></a>

<p>三维数据的获取可以通过</p>
<ol>
<li>立体视觉系统（多目相机）</li>
<li>RGB-D（结构光和 TOF）</li>
</ol>
<p>三维数据的表示形式包含</p>
<ol>
<li>点云数据</li>
<li>体素网格点</li>
<li>多边形网格</li>
<li>多视角表示</li>
</ol>
<p>三维深度学习最新研究趋势</p>
<ul>
<li>以基于点云数据为研究对象的 PointNet 为开端，流行的方法是结合点云数据和多视角的二维图像数据作为深度学习网络的输入</li>
</ul>
]]></content>
      <categories>
        <category>research</category>
      </categories>
      <tags>
        <tag>3d</tag>
        <tag>dl</tag>
      </tags>
  </entry>
  <entry>
    <title>牛顿-莱布尼茨公式</title>
    <url>/2020/08/15/Newton-Leibniz-formula/</url>
    <content><![CDATA[<p>牛顿-莱布尼茨公式不仅为定积分提供了一个有效的计算方法，而且是联系不定积分和定积分的桥梁。</p>
<a id="more"></a>

<p><strong>定理 9.1</strong>    若函数 $f$ 在 $[a, b]$ 上连续，且存在原函数 $F$，即 $F^{\prime}(x) = f(x), x\in[a, b]$，则 $f$ 在 $[a, b]$ 上可积，且<br>$$<br>\int^b_a f(x) \mathrm{d}x = F(b) - F(a).<br>$$<br>上式称为牛顿-莱布尼茨公式，也常写作<br>$$<br>\left. \int_a^b f(x) \mathrm{d}x = F(x) \right\vert_a^b.<br>$$<br>证明（拉格朗日中值定理和定积分定义）由定积分定义，任给 $\varepsilon &gt; 0$，需要证明存在 $\delta &gt; 0$，当 $\left | T \right | &lt; \delta$ 时，有<br>$$<br>\left\vert \sum_{i=1}^n f(\xi_i) \Delta x_i - [F(b) - F(a)] \right\vert &lt; \varepsilon.<br>$$<br>事实上，对于 $[a, b]$ 的任一分割 $T = {a = x_0, x_1, \cdots, x_n = b}$，在每一个小区间 $[x_{i-1}, x_i]$ 上对 $F(x)$ 使用拉格朗日中值定理，则分别存在 $\eta_i \in (x_{i-1}, x_i), i = 1, 2, \cdots, n$，使得<br>$$<br>F(b) - F(a) = \sum_{i=1}^n [F(x_i) - F(x_{i-1})] \\<br>= \sum_{i=1}^n F^{\prime}(\eta_i) \Delta x_i = \sum_{i=1}^n f(\eta_i)\Delta x_i.<br>$$<br>因为 $f$ 在 $[a, b]$ 上连续，从而一致连续，所以对上述 $\varepsilon &gt; 0$，存在 $\delta &gt; 0$，当 $x^{\prime}, x^{\prime\prime} \in [a, b]$ 且 $\left\vert x^{\prime} - x^{\prime\prime} \right\vert &lt; \delta$ 时，有<br>$$<br>\left\vert f(x^{\prime}) - f(x^{\prime\prime}) \right\vert &lt; \frac{\varepsilon}{b-a}.<br>$$<br>于是，当 $\Delta x_i \leq \left|T\right| &lt; \delta$ 时，任取 $\xi_i \in [x_{i-1}, x_i]$，便有 $\left\vert \xi_i - \eta_i \right\vert &lt; \delta$，这就证明<br>$$<br>\left\vert \sum_{i=1}^n f(\xi_i)\Delta x_i - [F(b) - F(a)] \right\vert \\<br>= \left\vert \sum_{i=1}^n [f(\xi_i) - f(\eta_i)]\Delta x_i \right\vert \\<br>\leq \sum_{i=1}^n \left\vert f(\xi_i) - f(\eta_i) \right\vert \Delta x_i \\<br>&lt; \frac{\varepsilon}{b-a} \cdot \sum_{i=1}^n \Delta x_i = \varepsilon.<br>$$<br>所以，$f$ 在 $[a,b]$ 上可积，且有牛顿-莱布尼茨公式成立。</p>
<p><em>注意</em> 定理的条件可适当减弱，</p>
<ol>
<li>对 $F$ 的要求可减弱为：在 $[a,b]$ 上连续，在 $(a,b)$ 上可导，且 $F^{\prime}(x)=f(x), x\in(a,b)$</li>
<li>对 $f$ 的要求可减弱为：在 $[a, b]$ 上可积</li>
<li>其实，连续函数必有原函数，因此，定理中“且存在原函数”要求可以省略</li>
</ol>
<p>例题 </p>
<p>证明：若 $f$ 在 $[a,b]$ 上可积，$F$ 在 $[a,b]$ 上连续，且除有限个点外有 $F^{\prime}=f(x)$，则<br>$$<br>\int_a^b f(x) \mathrm{d}x=F(b)-F(a).<br>$$</p>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>Newton</tag>
        <tag>Leibniz</tag>
      </tags>
  </entry>
  <entry>
    <title>三维重建简单综述</title>
    <url>/2019/12/21/3d-reconstruction/</url>
    <content><![CDATA[<p>文章《<a rel="noreferrer noopener" aria-label="基于深度学习的视觉三维重建研究总结（在新窗口打开）" href="https://zhuanlan.zhihu.com/p/79628068" target="_blank">基于深度学习的视觉三维重建研究总结</a>》从三维重建的意义、定义、表示方式、分类开始，总结了深度学习在三维重建方向的最近几年（截至2019年）的进展，分别是</p>
<a id="more"></a>

<ol><li>从单张图像恢复深度图的文章《<a rel="noreferrer noopener" aria-label="Depth Map Prediction from a Single Image using a Multi-Scale Deep Network（在新窗口打开）" href="https://arxiv.org/abs/1406.2283" target="_blank">Depth Map Prediction from a Single Image using a Multi-Scale Deep Network</a>》，是深度学习进行三维重建的开山之作，由粗到细并提出尺度不变的损失函数。</li><li>单视图或多视图的体素三维重建文章《<a rel="noreferrer noopener" aria-label="3D-R2N2: A Unified Approach for Single and Multi-view 3D Object Reconstruction（在新窗口打开）" href="https://arxiv.org/abs/1604.00449" target="_blank">3D-R2N2: A Unified Approach for Single and Multi-view 3D Object Reconstruction</a>》结合编码解码网络和LSTM，既可以对单幅图像做三维图像体素重建，又可以对多幅图像做。</li><li>单张RGB图像的点云三维重建文章《<a rel="noreferrer noopener" aria-label="A Point Set Generation Network for 3D Object Reconstruction from a Single Image（在新窗口打开）" href="https://arxiv.org/abs/1612.00603" target="_blank">A Point Set Generation Network for 3D Object Reconstruction from a Single Image</a>》用1024个点云数据表示物体的三维重建，并提出了CD（Chamfer Distance）和 EMD（Earth Mover's Distance）。</li><li>单张RGB图像的Mesh三维重建文章《<a rel="noreferrer noopener" aria-label="Pixel2Mesh: Generating 3D Mesh Models from Single RGB Images（在新窗口打开）" href="https://arxiv.org/abs/1804.01654" target="_blank">Pixel2Mesh: Generating 3D Mesh Models from Single RGB Images</a>》从椭球体Mesh通过深度学习（CNN + GCN） 端到端 变形为对应物体的Mesh三维重建。</li><li>文章《<a rel="noreferrer noopener" aria-label="Mesh R-CNN（在新窗口打开）" href="https://arxiv.org/abs/1906.02739" target="_blank">Mesh R-CNN</a>》使用《<a rel="noreferrer noopener" aria-label="Mask R-CNN（在新窗口打开）" href="https://arxiv.org/abs/1703.06870" target="_blank">Mask R-CNN</a>》框架实现现实图片的物体检测，并为每个检测物体生成三角Mesh。文章使用了图卷积网络GCN和多种损失来训练。</li><li>文章《<a rel="noreferrer noopener" aria-label="Conditional Single-view Shape Generation for Multi-view Stereo Reconstruction（在新窗口打开）" href="https://arxiv.org/abs/1904.06699" target="_blank">Conditional Single-view Shape Generation for Multi-view Stereo Reconstruction</a>》使用条件生成模型对不可见部分进行建模。</li></ol>
]]></content>
      <categories>
        <category>research</category>
      </categories>
      <tags>
        <tag>3d</tag>
        <tag>dl</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中 deepcopy, copy, 赋值的区别</title>
    <url>/2019/12/21/Python-deepcopy-copy/</url>
    <content><![CDATA[<p>Python 中数据对象分为三类，一类是不可变对象，如元组、字符串、数值；一类为单层可变对象，如列表 L = [1, 2, 3]，字典 D = {‘x’: 1, ‘y’: 2}；最后一类是多层可变对象，即可变对象中嵌套有可变对象，如列表 L = [1, [1, 2], 3]，字典 D = {‘x’: [1, 2], ‘y’ = 3}。</p>
<a id="more"></a>

<p>Python 中拷贝也分为三类， 一类是赋值 ‘=’;   一类是浅层拷贝 copy.copy(); 一类是深层拷贝 copy.deepcopy()，它们表现了对数据操作的不同程度。赋值’=’是对数据对象“打上标签”, 而不对具体的数值操作，是一种指向操作。深层拷贝是真正意义上的拷贝一份，创造出两个完全意义的数据对象，在内存中开辟一个空间来存储数值。浅层拷贝对于对于不可变对象和单层可变对象开辟一个内存空间来存储数值，但是只存储“一层”，对于多层可变对象数据，不能够嵌套拷贝，因为嵌套的可变对象在多层可变对象中是以索引或标签的形式存储的。</p>
<p>举一些例子：</p>
<p>对于固定值的不可变对象，三者一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">y_deep = copy.deepcopy(x)</span><br><span class="line">y_copy = copy.copy(x)</span><br><span class="line">y_assi = x</span><br><span class="line">print(id(x))</span><br><span class="line">print(id(y_deep))</span><br><span class="line">print(id(y_copy))</span><br><span class="line">print(id(y_assi))</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">94442834912000</span><br><span class="line">94442834912000</span><br><span class="line">94442834912000</span><br><span class="line">94442834912000</span><br></pre></td></tr></table></figure>

<p>对于单层可变对象，三者不同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y_deep = copy.deepcopy(x)</span><br><span class="line">y_copy = copy.copy(x)</span><br><span class="line">y_assi = x</span><br><span class="line">print(id(x))</span><br><span class="line">print(id(y_deep))</span><br><span class="line">print(id(y_copy))</span><br><span class="line">print(id(y_assi))</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">139621304194544</span><br><span class="line">139621670020192</span><br><span class="line">139621671066192</span><br><span class="line">139621304194544</span><br></pre></td></tr></table></figure>

<p>对于多层可变对象，三者不同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>]</span><br><span class="line">y_deep = copy.deepcopy(x)</span><br><span class="line">y_copy = copy.copy(x)</span><br><span class="line">y_assi = x</span><br><span class="line">print(id(x))</span><br><span class="line">print(id(y_deep))</span><br><span class="line">print(id(y_copy))</span><br><span class="line">print(id(y_assi))</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">139621669999392</span><br><span class="line">139621671065792</span><br><span class="line">139621669999792</span><br><span class="line">139621669999392</span><br></pre></td></tr></table></figure>

<p>多层可变对象，deepcopy() 和 copy() 的区别</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>]</span><br><span class="line">y_deep = copy.deepcopy(x)</span><br><span class="line">y_copy = copy.copy(x)</span><br><span class="line">y_assi = x</span><br><span class="line">x[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line">print(<span class="string">&#x27;x = &#x27;</span>, x)</span><br><span class="line">print(<span class="string">&#x27;y_deep = &#x27;</span>, y_deep)</span><br><span class="line">print(<span class="string">&#x27;y_copy = &#x27;</span>, y_copy)</span><br><span class="line">print(<span class="string">&#x27;y_assi = &#x27;</span>, y_assi)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D;  [1, [9, 2], 3]</span><br><span class="line">y_deep &#x3D;  [1, [1, 2], 3]</span><br><span class="line">y_copy &#x3D;  [1, [9, 2], 3]</span><br><span class="line">y_assi &#x3D;  [1, [9, 2], 3]</span><br></pre></td></tr></table></figure>

<p>补充参考 <a rel="noreferrer noopener" aria-label="csdn（在新窗口打开）" href="https://blog.csdn.net/u011630575/article/details/78604226" target="_blank">csdn</a></p>]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>copy</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习优化算法：从SGD到Adam</title>
    <url>/2020/05/30/ai-optimizer/</url>
    <content><![CDATA[<p>机器学习是实现人工智能的一种有效方法，当构建好模型后，需要使用优化器迭代学习模型参数，常用的有随机梯度下降法（SGD）和 Adam，下面总结一下各种的优缺点，并介绍一点优化器的演变过程。</p>
<a id="more"></a>

<h1 id="随机梯度下降法-SGD"><a href="#随机梯度下降法-SGD" class="headerlink" title="随机梯度下降法 SGD"></a>随机梯度下降法 SGD</h1><p>SGD 是一种梯度下降算法，为什么叫做随机梯度下降呢，因为每次迭代都是随机选择一个样本，计算损失函数沿着负梯度方向求极小值，而梯度下降算法是将所有样本计算损失函数的平均，然后再计算损失函数沿着负梯度方向求极小值，通过链式法则一层一层依据梯度下降方向来更新模型参数。</p>
<p>SGD 的计算公式如下（与梯度下降算法相同）：<br>$$<br>\Delta \theta_t = - \alpha \times g_t.<br>$$<br>这里，$\alpha$ 是学习率或步长，$g_t$ 是梯度方向，$\Delta \theta_t$ 是损失函数优化量，包含了优化迭代的方向和步长。优化变量公式如下：<br>$$<br>x = x + \Delta \theta_t.<br>$$</p>
<p>SGD 的缺点如下：</p>
<ol>
<li>容易陷入局部极值（这是梯度下降算法的通病，因为复杂模型的损失函数一般都不是凸函数，具有多局部极值）</li>
<li>遇到鞍点，模型无法更新参数</li>
<li>受初始学习率（最优化理论中的步长）的影响很大</li>
<li>每个维度上学习率都一样（特别是在稀疏数据下出现问题）</li>
</ol>
<p>如何解决这些问题，特别是随着迭代的增加，能够动态的调整学习率，遇到鞍点时能够不仅仅依靠当前点的梯度而是增加动量冲过鞍点，下面一些方法是对SGD的改进。</p>
<h1 id="AdaGrad"><a href="#AdaGrad" class="headerlink" title="AdaGrad"></a>AdaGrad</h1><p>AdaGrad 算法的计算公式如下：<br>$$<br>n_t = n_{t-1} + g^2_t, \\<br>\Delta \theta_t = -\frac{\alpha}{\sqrt{n_t + \epsilon}} \times g_t.<br>$$<br>其中，$g_t$ 是当前梯度方向，$n_t$ 是梯度平方的积累值，$\frac{\alpha}{\sqrt{n_t + \epsilon}}$是学习率（可以看出随着优化迭代的进行，学习率递减，这里$\epsilon$ 是一个小正数，防止初始梯度$n_t=0$）。AdaGrad 算法没有改变SGD算法优化的方向，只是更改了每次迭代的学习率或步长，使得每次迭代都迈更小的步，特别是在极小点附近，这将是有益的。</p>
<p>伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grad_squard = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	dx = compute_gradient(x)</span><br><span class="line">    grad_squard += dx * dx</span><br><span class="line">    x -= learning_rate * dx / (np.sqrt(grad_squard + <span class="number">1e-7</span>))</span><br></pre></td></tr></table></figure>

<p>AdaGrad 算法的优点：</p>
<ol>
<li>前期放大学习率，因前期梯度累积值较小</li>
<li>后期缩小学习率，因后期梯度累计值较小</li>
<li>学习率随着训练次数降低</li>
<li>每个分量有不同的学习率，这是因为每个分量的梯度方向不同导致，累积的梯度平方和不同</li>
</ol>
<p>AdaGrad 算法的缺点：</p>
<ol>
<li>学习率设置太大时，会导致优化迭代比较敏感，不收敛</li>
<li>后期因梯度评分累积值太大，使得学习率较小，即步长小，导致基本上不走不优化，提前结束训练</li>
</ol>
<h1 id="RMSProp"><a href="#RMSProp" class="headerlink" title="RMSProp"></a>RMSProp</h1><p>RMSProp 是解决AdaGrad的学习率后期太小而提出，主要是解决$\sqrt{n_t + \epsilon}$ 梯度平方和累积过大问题，考虑求当前梯度和累积梯度的加权平均。</p>
<p>RMSProp 算法计算公式如下：<br>$$<br>n_t = \gamma n_{t-1} + (1-\gamma)g^2_t, \\<br>\Delta \theta_t = -\frac{\alpha}{\sqrt{n_t + \epsilon}}\times g_t<br>$$<br>伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grad_squard = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	dx = compute_gradient(x)</span><br><span class="line">    grad_squard = decay_rate * grad_squard + (<span class="number">1</span> - decay_rate) * dx * dx</span><br><span class="line">    x -= learning_rate * dx / (np.sqrt(grad_squard + <span class="number">1e-7</span>))</span><br></pre></td></tr></table></figure>

<p>RMSProp 算法的优点：</p>
<ol>
<li>RMSProp 解决AdaGrad 训练后期提前结束的问题（学习率太小不更新）</li>
</ol>
<p>RMSProp 算法的缺点：</p>
<ol>
<li>只解决了学习率更新问题，为解决梯度方向问题，遇到鞍点时无法更新</li>
</ol>
<h1 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h1><p>Adam 算法的计算公式如下：<br>$$<br>m_t = \beta \times m_{t-1} + (1-\beta) \times g_t, \\<br>n_t = \gamma \times n_{t-q} + (1-\gamma) \times g^2_t, \\<br>\Delta \theta_t = - \frac{\alpha}{\sqrt{n_t} + \epsilon} \times m_t.<br>$$</p>
<p>这里，$m_t$ 是为梯度添加累积动量的加权平均梯度方向，$n_t$ 是为学习率的累积梯度平方缩放率。</p>
<p>Adam 算法的伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">first_moment = <span class="number">0</span></span><br><span class="line">second_moment = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	dx = compute_gradient(x)</span><br><span class="line">	first_moment = beta1 * first_moment + (<span class="number">1</span> - beta1) * dx</span><br><span class="line">	second_moment = beta2 * second_moment + (<span class="number">1</span> - beta2) * dx * dx</span><br><span class="line">	x -= first_moment * learning_rate / (np.sqrt(second_moment) + <span class="number">1e-7</span>)</span><br></pre></td></tr></table></figure>

<p>Adam 算法的优点：</p>
<ol>
<li>学习率按照RMSProp算法更新，能够保证每步迭代学习率都在减小，而且每个维度不一样，且不会像AdaGrad算法提前结束</li>
<li>梯度方向提升为动量和梯度的加权平均，能够有效逃避鞍点问题</li>
</ol>
<p>更进一步的，Adam算法引入校准值，伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">first_moment = <span class="number">0</span></span><br><span class="line">second_moment = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>, num_iterations):</span><br><span class="line">	dx = compute_gradient(x)</span><br><span class="line">	first_moment = beta1 * first_moment + (<span class="number">1</span> - beta1) * dx</span><br><span class="line">	second_moment = beta2 * second_moment + (<span class="number">1</span> - beta2) * dx * dx</span><br><span class="line">	first_unbias = first_moment / (<span class="number">1</span> - beta1 ** t)</span><br><span class="line">	second_unbias = second_moment / (<span class="number">1</span> - beta2 ** t)</span><br><span class="line">	x -= first_unbias * learning_rate / (np.sqrt(second_unbias) + <span class="number">1e-7</span>)</span><br></pre></td></tr></table></figure>

<h1 id="ALL-IN-ALL"><a href="#ALL-IN-ALL" class="headerlink" title="ALL IN ALL"></a>ALL IN ALL</h1><p>无论是哪种优化算法，都需要初始化一个学习率，训练模型时，推荐使用SGD和Adam算法都尝试一下。SGD 通常训练时间会更长，但最终效果比较好，当然需要好的初始化和学习率。当需要训练较深较复杂的网络且需要快速收敛时，推荐使用Adam. 一般 Adam 算法的参数可选择：</p>
<ol>
<li><pre><code class="html">1. beta1 = 0.9
2. beta2 = 0.999
3. learning_rate = 1e-3 or 5e - 4</code></pre>
</li>
</ol>
<p>其他，学习率自适应方法，如</p>
<ol>
<li>指数衰减 $\alpha = \alpha_0 e^{-kt}$.</li>
<li>倒数衰减 $\alpha = \alpha_p / (1 + kt)$.</li>
</ol>
]]></content>
      <categories>
        <category>research</category>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>optimizer</tag>
        <tag>ml</tag>
      </tags>
  </entry>
  <entry>
    <title>给服务器添加交换分区swap 和开启 bbr</title>
    <url>/2019/12/20/add-swap/</url>
    <content><![CDATA[<p>有时候，购买的云服务器不会自动给创建交换分区，如何自己建立交换分区呢，使用下面命令创建交换分区，可以更改大小，比如1G更改为2G，一般交换分区是内存的2倍足矣。本篇以 Debian 系统为例，建议以 root 身份运行本篇中的命令。</p>
<a id="more"></a>

<h1 id="添加交换分区"><a href="#添加交换分区" class="headerlink" title="添加交换分区"></a>添加交换分区</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo swapon --show</span><br><span class="line">free -h</span><br><span class="line">df -h</span><br><span class="line">sudo fallocate -l 1G /swapfile</span><br><span class="line">ls -lh /swapfile</span><br><span class="line">sudo chmod 600 /swapfile</span><br><span class="line">ls -lh /swapfile</span><br><span class="line">sudo mkswap /swapfile</span><br><span class="line">sudo swapon /swapfile</span><br><span class="line">sudo swapon --show</span><br><span class="line">free -h</span><br><span class="line">sudo cp /etc/fstab /etc/fstab.bak</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;/swapfile none swap sw 0 0&#x27;</span> | sudo tee -a /etc/fstab</span><br><span class="line">cat /proc/sys/vm/swappiness</span><br><span class="line">sudo sysctl vm.swappiness=10</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;vm.swappiness=10&#x27;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">cat /proc/sys/vm/vfs_cache_pressure</span><br><span class="line">sudo sysctl vm.vfs_cache_pressure=50</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;vm.vfs_cache_pressure=50&#x27;</span> &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure>

<p>使用 top 或 htop 命令，可以查看交换分区是否创建成功。</p>
<h1 id="开启-bbr"><a href="#开启-bbr" class="headerlink" title="开启 bbr"></a>开启 bbr</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.core.default_qdisc=fq&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.tcp_congestion_control=bbr&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否开启成功</span></span><br><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>swap</tag>
      </tags>
  </entry>
  <entry>
    <title>不定积分</title>
    <url>/2020/03/24/antiderivative-or-indefinite-integral/</url>
    <content><![CDATA[<p>积分法属于微分法的逆运算，就像减法是加法的逆运算，除法是乘法的逆运算一样。</p>
<a id="more"></a>

<h1 id="原函数与不定积分"><a href="#原函数与不定积分" class="headerlink" title="原函数与不定积分"></a>原函数与不定积分</h1><p><strong>定义 1</strong> &emsp; 设函数$f$与$F$在区间$I$上都有定义。若<br>$$<br>F^{\prime}(x) = f(x), \ x \in I,<br>$$<br>则称$F$为$f$在区间$I$上的一个原函数。</p>
<p>这一节解决满足什么样条件的函数存在原函数。</p>
<p><strong>定理 8.1</strong> &emsp; 若函数$f$在区间$I$上连续，则$f$在$I$上存在原函数$F$，即$F^{\prime} = f(x), \ x \in I$.</p>
<p>初等函数在定义域内是连续函数，因此，初等函数都存在原函数。注意，初等函数的原函数不一定还是初等函数。</p>
<p><strong>定理 8.2</strong> &emsp; 设$F$是$f$在区间$I$上的一个原函数，则</p>
<ol>
<li>$F + C$ 也是$f$在$I$上的原函数，其中$C$为任意常量函数；</li>
<li>$f$在$I$上的任意两个原函数之间，只可能相差一个常数。</li>
</ol>
<p><strong>定义 2</strong> &emsp; 函数$f$在区间$I$上的全体原函数称为$f$在$I$上的不定积分，记作<br>$$<br>\int f(x) \mathrm{d}x,<br>$$<br>其中称$\int$为积分号，$f(x)$为被积函数，$f(x)\mathrm{d}x$为被积表达式，$x$为积分变量。<strong>尽管上述记号中各个部分都有其特定的名称，但在使用时必须把它们看作一个整体。</strong></p>
<p>不定积分与原函数是总体与个体的关系，即若$F$是$f$的一个原函数，则$f$的不定积分是一个函数族$\{F + C\}$，其中$C$是任意常数，为了方便常写作<br>$$<br>\int f(x) \mathrm{d}x = F(x) + C.<br>$$<br>称$C$为积分常数，它可取任一实数值。</p>
<p><strong>不定积分的几何意义</strong> &emsp; 若$F$是$f$的一个原函数，则称$y = F(x)$的图像为$f$的一条积分曲线。于是，$f$的不定积分在几何上表示$f$的某一积分曲线沿纵轴方向任意平移所得一切积分曲线组成的曲线族。显然，若在每一条积分曲线上横坐标相同的点处作切线，则这些切线互相平行。</p>
<p>当给定原函数的某一个初始条件后，可以求出满足该初始条件的某一原函数子集合。</p>
<h1 id="基本积分表"><a href="#基本积分表" class="headerlink" title="基本积分表"></a>基本积分表</h1><p>求导数相对于求积分会容易，对于某些基本的积分公式列出如下：</p>
<ol>
<li>$\int 0 \mathrm{d}x = C$;</li>
<li>$\int 1 \mathrm{d}x = \int \mathrm{d}x = x + C$;</li>
<li>$\int x^{\alpha} \mathrm{d}x = \frac{x^{\alpha + 1}}{\alpha + 1} + C \ (\alpha \neq -1, \ x &gt; 0)$;</li>
<li>$\int \frac{1}{x} \mathrm{d}x = \ln |x| + C \ (x \neq 0)$;</li>
<li>$\int e^x \mathrm{d}x = e^x + C$;</li>
<li>$\int a^x \mathrm{d}x = \frac{a^x}{\ln a} + C \ (a &gt; 0, \ a \neq 1)$;</li>
<li>$\int \cos ax \mathrm{d}x = \frac{1}{a} \sin ax + C \ (a \neq 0)$;</li>
<li>$\int \sin ax \mathrm{d}x = - \frac{1}{a} \cos ax + C \ (a \neq 0)$;</li>
<li>$\int \sec^2 x \mathrm{d}x = \tan x + C$;</li>
<li>$\int \csc^2 x \mathrm{d}x = -\cot x + C$;</li>
<li>$\int \sec x \cdot \tan x \mathrm{d}x = \sec x + C$;</li>
<li>$\int \csc x \cdot \cot x \mathrm{d}x = -\csc x + C$;</li>
<li>$\int \frac{1}{\sqrt[2]{1 - x^2}} \mathrm{d}x = \arcsin x + C = -\arccos x + C$;</li>
<li>$\int \frac{1}{1 + x^2} \mathrm{d}x = \arctan x + C = -\text{arccot}\ x + C_1$.</li>
</ol>
<p>**定理 8.3 **&ensp; 若函数$f$与$g$在区间$I$上都存在原函数，$k_1, k_2$为两个任意常数，则$k_1 f + k_2 g$在$I$上也存在原函数，且当$k_1$与$k_2$不同时为零时有<br>$$<br>\int [k_1 f(x) + k_2 g(x)] \mathrm{d}x = k_1 \int f(x) \mathrm{d}x + k_2 \int g(x) \mathrm{d}x.<br>$$<br>一些事实：</p>
<p>每一个含有第一类间断点的函数都没有原函数。</p>
<p>导函数不存在第一类间断点。</p>
<p>某些导函数可能存在第二类间断点。如下函数的导函数$f(x)$在$x = 0$处是第二类间断点<br>$$<br>F(x) =<br>\begin{cases}<br>x^{3/2} \sin \frac{1}{x}, \quad x \in (0, 1]; \\<br>0, \quad \quad \quad x = 0.<br>\end{cases}<br>$$</p>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>antiderivatiive</tag>
        <tag>indefinite integral</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Ubuntu 上删除软件和清理配置文件</title>
    <url>/2021/10/27/apt-remove-package-and-configurations/</url>
    <content><![CDATA[<p>在 Ubuntu（或其他 Debian 类系统）上安装卸载软件常常都是通过包管理器 apt (或 apt-get) 来实现的。通过 apt remove packagename 和 apt purge packagename 都可以卸载软件，那么它们都有什么区别呢，它们都做了什么呢？本篇进行简单介绍。</p>
<a id="more"></a>

<h1 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h1><p>使用命令 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt remove packagename </span><br></pre></td></tr></table></figure>

<p>确实能够卸载软件，但是，它会保留软件的配置文件信息。当下次再次安装该软件时，将会检索到保留的配置文件，安装时将会跳过软件的配置环节。</p>
<h1 id="dpkg"><a href="#dpkg" class="headerlink" title="dpkg"></a>dpkg</h1><p>使用命令 <code>dpkg --list packagename</code> 可以查看软件的信息，如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dpkg --list python</span><br><span class="line">Desired=Unknown/Install/Remove/Purge/Hold</span><br><span class="line">| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend</span><br><span class="line">|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)</span><br><span class="line">||/ Name                     Version           Architecture      Description</span><br><span class="line">+++-========================-=================-=================-======================================================</span><br><span class="line">ii  python                   2.7.15~rc1-1      amd64             interactive high-level object-oriented language</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">not</span>-installed    - The package <span class="keyword">is</span> <span class="keyword">not</span> installed on this system</span><br><span class="line">config-files     - Only the configuration files are deployed to this system</span><br><span class="line">half-installed   - The installation of the package has been started, but <span class="keyword">not</span> completed</span><br><span class="line">unpacked         - The package <span class="keyword">is</span> unpacked, but <span class="keyword">not</span> configured</span><br><span class="line">half-configured  - The package <span class="keyword">is</span> unpacked <span class="keyword">and</span> configuration has started but <span class="keyword">not</span> completed</span><br><span class="line">triggers-awaited - The package awaits trigger processing by another package</span><br><span class="line">triggers-pending - The package has been triggered</span><br><span class="line">installed        - The packaged <span class="keyword">is</span> unpacked <span class="keyword">and</span> configured OK</span><br></pre></td></tr></table></figure>

<p>当使用命令 <code>apt remove packagename</code> 卸载包后，再使用 <code>dpkg --list packagename</code> 可以看到出现 “rc”，而不是 “ii”，表示卸载（remove）和保留配置文件（config-files）。</p>
<p>那么如何清理配置文件呢？或者在卸载时同时清空配置文件信息，这样下次安装时能够重新安装并重新配置，使用下面的命令。</p>
<h1 id="purge"><a href="#purge" class="headerlink" title="purge"></a>purge</h1><p>使用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt purge packagename</span><br></pre></td></tr></table></figure>

<p>能够同时卸载软件和清理软件配置。</p>
<p>在 Ubuntu 上，很多人会使用 apt autoremove 命令，此命令能够清理多余的软件包，但是，却将配置文件保留在系统中，应慎用。建议以后多使用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt purge packagename</span><br><span class="line">apt --purge remove packagename</span><br></pre></td></tr></table></figure>

<p>当然，如果想要保留配置文件，建议直接使用 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt remove packagename</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="http://bencane.com/2014/08/18/removing-packages-and-configurations-with-apt-get/">Removing packages and configurations with apt-get</a></li>
<li><a href="https://www.jianshu.com/p/f6176973b56f">关于apt-get remove 与 apt-get purge</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>利用定积分求平面图形的面积</title>
    <url>/2020/10/10/area-of-plane-figure/</url>
    <content><![CDATA[<p>由定积分的几何意义我们知道，连续曲线 $y = f(x) (\geq 0)$ 在区间 $[a, b]$ 上与 $x$ 轴所围曲边梯形的面积为<br>$$<br>A = \int_a^b f(x) \mathrm{d}x = \int_a^b y \mathrm{d}x.<br>$$</p>
<a id="more"></a>

<h1 id="负面积"><a href="#负面积" class="headerlink" title="负面积"></a>负面积</h1><p>如果 $f(x)$ 在 $[a, b]$ 上不都是非负的，则所围图形的面积为<br>$$<br>A = \int_a^b |f(x)| \mathrm{d}x = \int_a^b |y| \mathrm{d}x.<br>$$<br>一般地，由上、下两条连续曲线 $y = f_2(x)$ 与 $y = f_1(x)$ 在区间 $[a, b]$ 上所围的平面图形面积计算公式为<br>$$<br>A = \int_a^b [f_2(x) - f_1(x)] \mathrm{d}x.<br>$$<br>同样 $x = g_2(y)$ 和 $x = g_1(y)$ 在区间 $[\alpha, \beta]$ 上所围面积，计算公式如下<br>$$<br>A = \int_{\alpha}^{\beta} [g_2(y) - g_1(y)] \mathrm{d}y.<br>$$</p>
<h1 id="参数方程"><a href="#参数方程" class="headerlink" title="参数方程"></a>参数方程</h1><p>设曲线 $C$ 由参数方程<br>$$<br>x = x(t), y = y(t), t \in [\alpha, \beta]<br>$$<br>给出，在 $[\alpha, \beta]$ 上 $y(t)$ 连续， $x(t)$连续可微且 $x^{\prime}(t) \neq 0$（对于 $y(t)$ 连续可微且 $y^{\prime}(t) \neq 0$ 的情形可类似地讨论）.记 $a = x(\alpha), b = x(\beta) (a &lt; b 或者 b &lt; a)$，则曲线 $C$ 及直线 $x = a, x = b$ 和 $x$ 轴所围的图形，其面积计算公式为<br>$$<br>A = \int_{\alpha}^{\beta} |y(t)x^{\prime}(t)| \mathrm{d}t.<br>$$<br>求图形面积最好画出图形，根据对称性约简计算过程。</p>
<p>如果参数方程所表示的曲线是封闭的，即<br>$$<br>x(\alpha) = x(\beta), y(\alpha) = y(\beta)<br>$$<br>且在 $(\alpha, \beta)$ 上曲线自身不再相交，那么曲线自身所围图形的面积为<br>$$<br>A = \left \vert \int_{\alpha}^{\beta} y(t) x^{\prime}(t) \mathrm{d}t \right \vert ,<br>$$<br>或<br>$$<br>A = \left \vert \int_{\alpha}^{\beta} x(t) y^{\prime}(t) \mathrm{d}t \right \vert .<br>$$</p>
<h1 id="极坐标方程"><a href="#极坐标方程" class="headerlink" title="极坐标方程"></a>极坐标方程</h1><p>设曲线 $C$ 由极坐标方程<br>$$<br>r = r(\theta), \theta \in [\alpha, \beta]<br>$$<br>给出，其中 $r(\theta)$ 在 $[\alpha, \beta]$ 上连续，$\beta - \alpha \leq 2 \pi$. 由曲线 $C$ 与两条射线 $\theta = \alpha, \theta = \beta$ 所围成的平面图形，通常也称为扇形，此扇形的面积计算公式为<br>$$<br>A = \frac{1}{2} \int_{\alpha}^{\beta} r^2 (\theta) \mathrm{d} \theta.<br>$$<br>圆扇形的弧长是 $r \cdot \theta$</p>
<p>圆扇形的面积是 $\frac{1}{2} r^2 \cdot \theta$</p>
<p>圆周长是 $2\pi r$</p>
<p>圆面积是 $\pi r^2$</p>
<p>面积求导得到弧长，弧长求导得到弧度。</p>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>integral</tag>
        <tag>definite integral</tag>
      </tags>
  </entry>
  <entry>
    <title>平面曲线的弧长和曲率</title>
    <url>/2021/01/27/arc-length-and-curvature-of-a-plane-curve/</url>
    <content><![CDATA[<p>通过定积分我们能够计算平面曲线的弧长和曲率。对于平面曲线的画出，通过利用参数方程和对曲线划分以直代曲的定积分思想来计算弧长。</p>
<a id="more"></a>

<h1 id="平面曲线的弧长"><a href="#平面曲线的弧长" class="headerlink" title="平面曲线的弧长"></a>平面曲线的弧长</h1><p>设$C = \stackrel\frown{AB}$ 是一条没有<strong>自交点</strong>的非闭的平面曲线。在$C$上从$A$到$B$依次取分点：<br>$$<br>A=P_0, P_1, P_2, \cdots, P_{n-1}, P_n = B,<br>$$<br>它们成为对曲线$C$的一个分割，记为$T$。然后用线段联结$T$中每个相邻的两点，得到$C$的$n$条弦$\overline{P_{i-1}P_i} (i=1,2,\cdots,n)$，这$n$条弦又成为$C$的一条内接折线。记<br>$$<br>|T| = \max_{1\leq i \leq n} |P_{i-1}P_i|, s_T = \sum^n_{i=1}|P_{i-1}P_i|,<br>$$<br>分别表示最长弦的长度和折线的总长度。</p>
<p><strong>定义 1</strong>    如果存在有限极限<br>$$<br>\lim_{|T|\to 0}s_T = s,<br>$$<br>即任给$\varepsilon &gt; 0$，恒存在$\delta &gt; 0$，使得$C$的任何分割$T$，只要$|T| &lt; \delta$，就有<br>$$<br>|s_T - s| &lt; \varepsilon,<br>$$<br>则称曲线$C$是可求长的，并把极限$s$定义为曲线$C$的弧长。</p>
<p><strong>定理 1</strong>    设曲线$C$是一条没有自交点的非闭的平面曲线，由参数方程<br>$$<br>x=x(t), y=y(t), t\in [\alpha, \beta]<br>$$<br>给出。若$x(t)$与$y(t)$在$[\alpha, \beta]$上连续可微，则$C$是可求长的，且弧长为<br>$$<br>s = \int^{\beta}_{\alpha} \sqrt{[x^{\prime}(t)]^2 + [y^{\prime}(t)]^2} \mathrm{d}t.<br>$$<br>对于光滑曲线，上面公式仍然成立。</p>
<h2 id="直角坐标方程定义的曲线"><a href="#直角坐标方程定义的曲线" class="headerlink" title="直角坐标方程定义的曲线"></a>直角坐标方程定义的曲线</h2><p>假设曲线$C$由直角坐标方程<br>$$<br>y=f(x), x\in [a, b]<br>$$<br>表示，把它看作参数方程时，即为<br>$$<br>x=x, y=f(x),x\in[a,b].<br>$$<br>当$f(x)$在$[a,b]$上连续可微时，此曲线即为一光滑曲线。弧长公式为<br>$$<br>s = \int^b_a \sqrt{1 + {f^{\prime}}^2(x)} \mathrm{d}x.<br>$$</p>
<h2 id="极坐标方程定义的曲线"><a href="#极坐标方程定义的曲线" class="headerlink" title="极坐标方程定义的曲线"></a>极坐标方程定义的曲线</h2><p>若曲线$C$由极坐标方程<br>$$<br>r = r(\theta), \theta \in [\alpha, \beta]<br>$$<br>表示，把它化为参数方程，则为<br>$$<br>x = r(\theta)\cos \theta, y= r(\theta)\sin\theta, \theta\in[\alpha, \beta].<br>$$<br>由于<br>$$<br>x^{\prime}(\theta)=r^{\prime}(\theta)\cos\theta - r(\theta)\sin\theta, \\<br>y^{\prime}(\theta)=r^{\prime}(\theta)\sin\theta + r(\theta)\cos\theta, \\<br>{x^{\prime}}^2(\theta) + {y^{\prime}}^2(\theta)=r^2(\theta)+{r^{\prime}}^2(\theta),<br>$$<br>因此当$r^{\prime}(\theta)$在$[\alpha,\beta]$上连续，且$r(\theta)$与$r^{\prime}(\theta)$不同时为零时，此极坐标曲线为一光滑曲线。这时弧长公式为<br>$$<br>s = \int^{\beta}_{\alpha}\sqrt{r^2(\theta) + {r^{\prime}}^2(\theta)}\mathrm{d}\theta.<br>$$</p>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>definite integral</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器关机自动发送通知邮件</title>
    <url>/2021/11/29/auto-email-server-shutdown/</url>
    <content><![CDATA[<p>我这里有个需求，就是服务器会因为不知道的原因（排除断电）导致关机，这种情况下，如果不能及时知道何时关机将会导致不能及时进行重启，并进行安全检查。这里通过撰写 Python 代码并设置服务，监测服务器是否关机并自动邮件通知。本篇以 Ubuntu 为例。</p>
<a id="more"></a>

<h1 id="编写-python-代码"><a href="#编写-python-代码" class="headerlink" title="编写 python 代码"></a>编写 python 代码</h1><p>编写 /home/jinzhongxu/shutdown_msg.py 模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : Jinzhong Xu</span></span><br><span class="line"><span class="comment"># @Contact : jinzhongxu@csu.ac.cn</span></span><br><span class="line"><span class="comment"># @Time    : 2021/11/23 17:45</span></span><br><span class="line"><span class="comment"># @File    : shutdown_msg.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mail</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        sender=<span class="string">&quot;xxx@qq.com&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        password=<span class="string">&quot;xxxZHyyy&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        recipients=(<span class="params"><span class="string">&quot;jinzhongxu@csu.ac.cn&quot;</span>, <span class="string">&quot;otheruser@163.com&quot;</span></span>),</span></span></span><br><span class="line"><span class="function"><span class="params">        smtp_server=<span class="string">&quot;smtp.qq.com&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        port=<span class="number">465</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        subject=<span class="string">&quot;服务器 IP 地址改变&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        text=<span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        attachment=(<span class="params"><span class="string">&quot;&quot;</span>,</span>),</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    msg = MIMEMultipart()</span><br><span class="line">    msg[<span class="string">&quot;From&quot;</span>] = _format_addr(<span class="string">&quot;JinzhongXu-Pythoner &lt;%s&gt;&quot;</span> % sender)</span><br><span class="line">    msg[<span class="string">&quot;To&quot;</span>] = _format_addr(<span class="string">&quot;管理员 &lt;%s&gt;&quot;</span> % <span class="string">&quot;, &quot;</span>.join(list(recipients)))</span><br><span class="line">    msg[<span class="string">&quot;Subject&quot;</span>] = Header(subject, <span class="string">&quot;utf-8&quot;</span>).encode()</span><br><span class="line">    <span class="comment"># 邮件正文是MIMEText:</span></span><br><span class="line">    msg.attach(MIMEText(text, <span class="string">&quot;plain&quot;</span>, <span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">    attachment = list(attachment)</span><br><span class="line">    <span class="keyword">if</span> attachment != [<span class="string">&quot;&quot;</span>]:</span><br><span class="line">        <span class="keyword">for</span> i, file_path <span class="keyword">in</span> enumerate(attachment):</span><br><span class="line">            <span class="keyword">with</span> open(file_path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="comment"># 设置附件的MIME和文件名:</span></span><br><span class="line">                file_dir, file_name = os.path.split(os.path.abspath(file_path))</span><br><span class="line">                filename_extension = file_name.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">                mime = MIMEBase(<span class="string">&quot;file&quot;</span>, filename_extension[<span class="number">-1</span>], filename=file_name)</span><br><span class="line">                <span class="comment"># 加上必要的头信息:</span></span><br><span class="line">                mime.add_header(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment&quot;</span>, filename=file_name)</span><br><span class="line">                mime.add_header(<span class="string">&quot;Content-ID&quot;</span>, <span class="string">f&quot;&lt;<span class="subst">&#123;i&#125;</span>&gt;&quot;</span>)</span><br><span class="line">                mime.add_header(<span class="string">&quot;X-Attachment-Id&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="comment"># 把附件的内容读进来:</span></span><br><span class="line">                mime.set_payload(f.read())</span><br><span class="line">                <span class="comment"># 用Base64编码:</span></span><br><span class="line">                encoders.encode_base64(mime)</span><br><span class="line">                <span class="comment"># 添加到MIMEMultipart:</span></span><br><span class="line">                msg.attach(mime)</span><br><span class="line"></span><br><span class="line">    server = smtplib.SMTP_SSL(smtp_server, port)</span><br><span class="line">    <span class="comment"># 控制打印日志</span></span><br><span class="line">    <span class="comment"># server.set_debuglevel(2)</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        server.login(</span><br><span class="line">            sender,</span><br><span class="line">            base64.b64decode(password.encode(), altchars=<span class="literal">None</span>, validate=<span class="literal">False</span>).decode(),</span><br><span class="line">        )</span><br><span class="line">        server.sendmail(sender, list(recipients), msg.as_string())</span><br><span class="line">        logs = <span class="string">f&quot;<span class="subst">&#123;sender&#125;</span> 给 <span class="subst">&#123;<span class="string">&#x27;; &#x27;</span>.join(recipients)&#125;</span> 的邮件发送成功&quot;</span></span><br><span class="line">    <span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">        logs = <span class="string">&quot;Error: 无法发送邮件&quot;</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        server.quit()</span><br><span class="line">    <span class="keyword">return</span> logs</span><br><span class="line"></span><br><span class="line"><span class="comment"># ubuntu设置关机时自动执行任务 https://blog.csdn.net/xiaohu50/article/details/79268538</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    subject = <span class="string">&quot;服务器关机&quot;</span></span><br><span class="line">    content = <span class="string">&quot;服务器关机了&quot;</span></span><br><span class="line">    mail(subject=subject, text=content)</span><br></pre></td></tr></table></figure>

<h1 id="设置守护程序"><a href="#设置守护程序" class="headerlink" title="设置守护程序"></a>设置守护程序</h1><p>创建服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/mailshutdown.service</span><br></pre></td></tr></table></figure>

<p>添加如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Run <span class="built_in">command</span> at shutdown</span><br><span class="line"><span class="comment"># 假设要执行的命令依赖网络</span></span><br><span class="line">Requires=network.target</span><br><span class="line">DefaultDependencies=no</span><br><span class="line">Conflicts=reboot.target</span><br><span class="line">Before=shutdown.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">RemainAfterExit=<span class="literal">true</span></span><br><span class="line">ExecStart=/bin/<span class="literal">true</span></span><br><span class="line">ExecStop=/usr/<span class="built_in">local</span>/miniconda/bin/python /home/jinzhongxu/shutdown_msg.py</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>设置开机启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start mailshutdown.service</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> mailshutdown.service</span><br></pre></td></tr></table></figure>

<p>这样，当某人使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo shutdown -h now</span><br></pre></td></tr></table></figure>

<p>等命令关机时，将会收到邮件通知。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://blog.csdn.net/xiaohu50/article/details/79268538">ubuntu设置关机时自动执行任务</a></li>
<li><a href="https://xujinzh.github.io/2021/11/06/auto-email-server-ip">服务器开机或IP改变自动发送通知邮件</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>ubuntu</tag>
        <tag>linux</tag>
        <tag>mail</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器开机或IP改变自动发送通知邮件</title>
    <url>/2021/11/06/auto-email-server-ip/</url>
    <content><![CDATA[<p>我这里有个需求，就是服务器会因为断电等原因关机、重启，导致 IP 地址更改，无法通过 SSH 连接，也不能及时知道电脑何时开机。这里通过撰写 Python  代码，自动检测 IP、开机自动邮件通知。本篇以 Ubuntu 为例。</p>
<a id="more"></a>

<h1 id="编写-Python-代码"><a href="#编写-Python-代码" class="headerlink" title="编写 Python 代码"></a>编写 Python 代码</h1><p>在目录 <code>/home/jinzhongxu/PythonProjects</code> 下编写 Python 模块 <code>send_message.py</code></p>
<p>因为在 Ubuntu 系统下，当电脑重启时，目录 <code>/tmp</code> 下的文件会清空</p>
<p>在 Mail 函数中，<code>sender</code> 为 qq 邮箱，即发送给你通知信息的邮箱；<code>recipients</code> 为接收信息的邮箱，可以通过该登录该邮箱查看收到的通知信息，如 IP 更改、服务器重启等；<code>password</code> 为 qq 邮箱的授权码，<code>smtp_server</code>、<code>port</code> 等都需要到 QQ 邮箱进行认证获取；<code>subject</code> 为邮件主题；<code>text</code> 为邮件内容；<code>attachment</code> 为附件，比如图像、文件等。</p>
<h2 id="简单通知信息"><a href="#简单通知信息" class="headerlink" title="简单通知信息"></a>简单通知信息</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : Jinzhong Xu</span></span><br><span class="line"><span class="comment"># @Contact : jinzhongxu@csu.ac.cn</span></span><br><span class="line"><span class="comment"># @Time    : 2021/11/5 19:02</span></span><br><span class="line"><span class="comment"># @File    : send_message.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email <span class="keyword">import</span> encoders</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.base <span class="keyword">import</span> MIMEBase</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> formataddr, parseaddr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_temp_ip</span>(<span class="params">current_ip</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    检查是否 IP 改变和是否是重启状态</span></span><br><span class="line"><span class="string">    :param current_ip: 当前 IP 地址</span></span><br><span class="line"><span class="string">    :return: 是否发送邮件、当前 IP 地址、电脑是否是重启</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    reboot = <span class="literal">False</span></span><br><span class="line">    temp_ip_json_path = <span class="string">&quot;/tmp/ip.json&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> os.path.exists(temp_ip_json_path)) <span class="keyword">or</span> (</span><br><span class="line">            <span class="keyword">not</span> os.path.getsize(temp_ip_json_path)</span><br><span class="line">    ):</span><br><span class="line">        reboot = <span class="literal">True</span></span><br><span class="line">        print(<span class="string">&quot;No &#123;&#125;, dump it.&quot;</span>.format(temp_ip_json_path))</span><br><span class="line">        <span class="keyword">with</span> open(temp_ip_json_path, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> jo:</span><br><span class="line">            json.dump(current_ip, jo)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>, current_ip, reboot</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">with</span> open(temp_ip_json_path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> jo:</span><br><span class="line">            origin_ip = json.load(jo)</span><br><span class="line">        <span class="keyword">if</span> origin_ip == current_ip:</span><br><span class="line">            print(<span class="string">&quot;Current ip &#123;&#125; do not change, no need to send&quot;</span>.format(current_ip))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>, current_ip, reboot</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(</span><br><span class="line">                <span class="string">&quot;The ip updated from &#123;&#125; to &#123;&#125;, update it.&quot;</span>.format(origin_ip, current_ip)</span><br><span class="line">            )</span><br><span class="line">            os.remove(temp_ip_json_path)</span><br><span class="line">            <span class="keyword">with</span> open(temp_ip_json_path, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> jo:</span><br><span class="line">                json.dump(current_ip, jo)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>, current_ip, reboot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_global_ip</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取电脑的外网 IP 地址</span></span><br><span class="line"><span class="string">    :return: 外网 IP</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">        s.connect((<span class="string">&quot;8.8.8.8&quot;</span>, <span class="number">80</span>))</span><br><span class="line">        ip = s.getsockname()[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        s.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_status</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取电脑状态，包括是否 IP 改变、是否重启</span></span><br><span class="line"><span class="string">    :return: 是否发送通知邮件</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    global_ips = get_global_ip()</span><br><span class="line">    whether_to_send, send_ip, reboot = get_temp_ip(global_ips)</span><br><span class="line">    send_ip = json.dumps(send_ip)</span><br><span class="line">    <span class="keyword">return</span> whether_to_send, send_ip, reboot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_format_addr</span>(<span class="params">s</span>):</span></span><br><span class="line">    name, addr = parseaddr(s)</span><br><span class="line">    <span class="keyword">return</span> formataddr((Header(name, <span class="string">&quot;utf-8&quot;</span>).encode(), addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mail</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        sender=<span class="string">&quot;xxx@qq.com&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        password=<span class="string">&quot;xxxZHyyy&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        recipients=(<span class="params"><span class="string">&quot;jinzhongxu@csu.ac.cn&quot;</span>, </span>),</span></span></span><br><span class="line"><span class="function"><span class="params">        smtp_server=<span class="string">&quot;smtp.qq.com&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        port=<span class="number">465</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        subject=<span class="string">&quot;服务器 IP 改变&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        text=<span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        attachment=(<span class="params"><span class="string">&quot;&quot;</span>,</span>),</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    msg = MIMEMultipart()</span><br><span class="line">    msg[<span class="string">&quot;From&quot;</span>] = _format_addr(<span class="string">&quot;JinzhongXu-Pythoner &lt;%s&gt;&quot;</span> % sender)</span><br><span class="line">    msg[<span class="string">&quot;To&quot;</span>] = _format_addr(<span class="string">&quot;管理员 &lt;%s&gt;&quot;</span> % <span class="string">&quot;, &quot;</span>.join(list(recipients)))</span><br><span class="line">    msg[<span class="string">&quot;Subject&quot;</span>] = Header(subject, <span class="string">&quot;utf-8&quot;</span>).encode()</span><br><span class="line">    <span class="comment"># 邮件正文是MIMEText:</span></span><br><span class="line">    msg.attach(MIMEText(text, <span class="string">&quot;plain&quot;</span>, <span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">    attachment = list(attachment)</span><br><span class="line">    <span class="keyword">if</span> attachment != [<span class="string">&quot;&quot;</span>]:</span><br><span class="line">        <span class="keyword">for</span> i, file_path <span class="keyword">in</span> enumerate(attachment):</span><br><span class="line">            <span class="keyword">with</span> open(file_path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="comment"># 设置附件的MIME和文件名:</span></span><br><span class="line">                file_dir, file_name = os.path.split(os.path.abspath(file_path))</span><br><span class="line">                filename_extension = file_name.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">                mime = MIMEBase(<span class="string">&quot;file&quot;</span>, filename_extension[<span class="number">-1</span>], filename=file_name)</span><br><span class="line">                <span class="comment"># 加上必要的头信息:</span></span><br><span class="line">                mime.add_header(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment&quot;</span>, filename=file_name)</span><br><span class="line">                mime.add_header(<span class="string">&quot;Content-ID&quot;</span>, <span class="string">f&quot;&lt;<span class="subst">&#123;i&#125;</span>&gt;&quot;</span>)</span><br><span class="line">                mime.add_header(<span class="string">&quot;X-Attachment-Id&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="comment"># 把附件的内容读进来:</span></span><br><span class="line">                mime.set_payload(f.read())</span><br><span class="line">                <span class="comment"># 用Base64编码:</span></span><br><span class="line">                encoders.encode_base64(mime)</span><br><span class="line">                <span class="comment"># 添加到MIMEMultipart:</span></span><br><span class="line">                msg.attach(mime)</span><br><span class="line"></span><br><span class="line">    server = smtplib.SMTP_SSL(smtp_server, port)</span><br><span class="line">    <span class="comment"># 控制打印日志</span></span><br><span class="line">    <span class="comment"># server.set_debuglevel(2)</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        server.login(</span><br><span class="line">            sender,</span><br><span class="line">            base64.b64decode(password.encode(), altchars=<span class="literal">None</span>, validate=<span class="literal">False</span>).decode(),</span><br><span class="line">        )</span><br><span class="line">        server.sendmail(sender, list(recipients), msg.as_string())</span><br><span class="line">        logs = <span class="string">f&quot;<span class="subst">&#123;sender&#125;</span> 给 <span class="subst">&#123;<span class="string">&#x27;; &#x27;</span>.join(recipients)&#125;</span> 的邮件发送成功&quot;</span></span><br><span class="line">    <span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">        logs = <span class="string">&quot;Error: 无法发送邮件&quot;</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        server.quit()</span><br><span class="line">    <span class="keyword">return</span> logs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    whether_to_send, global_ips, reboot = get_status()</span><br><span class="line">    <span class="keyword">if</span> whether_to_send <span class="keyword">and</span> reboot:</span><br><span class="line">        mail(subject=<span class="string">&quot;服务器重启成功&quot;</span>, text=<span class="string">f&quot;重启后的IP：<span class="subst">&#123;global_ips&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> whether_to_send <span class="keyword">and</span> (<span class="keyword">not</span> reboot):</span><br><span class="line">        mail(text=<span class="string">f&quot;新的IP：<span class="subst">&#123;global_ips&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;wait and no send&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="详细通知信息"><a href="#详细通知信息" class="headerlink" title="详细通知信息"></a>详细通知信息</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : Jinzhong Xu</span></span><br><span class="line"><span class="comment"># @Contact : jinzhongxu@csu.ac.cn</span></span><br><span class="line"><span class="comment"># @Time    : 2021/11/12 18:11</span></span><br><span class="line"><span class="comment"># @File    : send_message.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email <span class="keyword">import</span> encoders</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.base <span class="keyword">import</span> MIMEBase</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> formataddr, parseaddr</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">把 IP 地址存储在某个固定的开机不被清空的文件 fixed_ip_file 中；</span></span><br><span class="line"><span class="string">把 IP 地址存储在某个固定的开机就被清空的文件中，比如 /tmp 文件下的文件 tmp_ip_file；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果没有则表示刚开机，检测 IP 并写入到文件 tmp_ip_file 中，同时检查当前 IP 是否与 fixed_ip_file 中存储的 IP 是否相同：</span></span><br><span class="line"><span class="string">    0. 如果 fixed_ip_file 不存在，则把当前 IP 写入该文件，并通知：&quot;电脑重启成功，IP 文件丢失，当前 IP 地址是 XXX&quot;；</span></span><br><span class="line"><span class="string">    1. 如果存在但不同，则发送邮件通知：&quot;电脑重启成功，IP 地址改变。旧 IP: xxx，新 IP: yyy&quot;，最后更新 fixed_ip_file 中的 IP；</span></span><br><span class="line"><span class="string">    2. 如果相同，则发送邮件通知：&quot;电脑重启成功，IP 未发生改变，IP 地址是 xxx&quot;；</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">如果有那么表示不是刚开机，并检查当前 IP，如果与文件 tmp_ip_file 中不同，则更新，如果相同则不用重新。</span></span><br><span class="line"><span class="string">同时检查当前 IP 是否与 fixed_ip_file 中存储的 IP 是否相同：</span></span><br><span class="line"><span class="string">    0. 如果 fixed_ip_file 不存在，则把当前 IP 写入该文件，并通知：&quot;电脑正常运行中，IP 文件丢失，当前 IP 地址是 XXX&quot;；</span></span><br><span class="line"><span class="string">    1. 如果存在但不同，则发送邮件通知：&quot;电脑正常运行中，IP 地址改变。旧 IP: xxx，新 IP: yyy&quot;，最后更新 fixed_ip_file 中的 IP；</span></span><br><span class="line"><span class="string">    2. 如果相同，则不发送邮件通知； </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">1. 需要编写检测外网 IP 地址的函数，返回外网 IP 地址</span></span><br><span class="line"><span class="string">2. 需要编写发送邮件的函数，发送通知</span></span><br><span class="line"><span class="string">3. 需要指定两个文件地址</span></span><br><span class="line"><span class="string">4. 需要编写检测电脑状态和 IP 地址状态的函数，检测是否发送邮件、邮件内容</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computer_status</span>():</span></span><br><span class="line">    <span class="comment"># 指定两个文件，存储 IP 地址</span></span><br><span class="line">    fixed_ip_file = <span class="string">&quot;~/Documents/computerinfo/ip.txt&quot;</span></span><br><span class="line">    tmp_ip_file = <span class="string">&quot;/tmp/ip.txt&quot;</span></span><br><span class="line">    fixed_ip_file = os.path.expanduser(fixed_ip_file)</span><br><span class="line">    print(fixed_ip_file)</span><br><span class="line">    send_email = <span class="literal">False</span></span><br><span class="line">    ip = get_global_ip()</span><br><span class="line">    <span class="comment"># 如果 /tmp 下没有文件 tmp_ip_file，那么表示电脑刚开机</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(tmp_ip_file):  <span class="comment"># 此处有误报电脑重启的可能，如认为的删除 tmp_ip_file 文件。本程序默认该中情况不发生。</span></span><br><span class="line">        send_email = <span class="literal">True</span>  <span class="comment"># 则一定要发送通知邮件</span></span><br><span class="line">        <span class="keyword">with</span> open(tmp_ip_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> ip_file:</span><br><span class="line">            ip_file.write(ip)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果 fixed_ip_file 不存在，则重新创建并写入当前 IP 地址；发送通知邮件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(fixed_ip_file):</span><br><span class="line">            <span class="keyword">with</span> open(fixed_ip_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> ip_file:</span><br><span class="line">                ip_file.write(ip)</span><br><span class="line">            subject = <span class="string">&quot;电脑重启成功，IP 文件丢失&quot;</span></span><br><span class="line">            content = <span class="string">f&quot;电脑重启成功，IP 文件 <span class="subst">&#123;fixed_ip_file&#125;</span> 丢失，当前 IP 地址是 <span class="subst">&#123;ip&#125;</span>&quot;</span></span><br><span class="line">            <span class="keyword">return</span> send_email, content, subject</span><br><span class="line">        <span class="comment"># 如果 fixed_ip_file 存在</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">with</span> open(fixed_ip_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> ip_file:</span><br><span class="line">                origin_ip = ip_file.readline()</span><br><span class="line">            <span class="comment"># 如果当前 IP 与原 IP 不同，则发送通知邮件</span></span><br><span class="line">            <span class="keyword">if</span> ip != origin_ip:</span><br><span class="line">                subject = <span class="string">f&quot;电脑重启成功，IP 地址改变为 <span class="subst">&#123;ip&#125;</span>&quot;</span></span><br><span class="line">                content = <span class="string">f&quot;电脑重启成功，IP 地址改变。旧 IP: <span class="subst">&#123;origin_ip&#125;</span>，新 IP: <span class="subst">&#123;ip&#125;</span>&quot;</span></span><br><span class="line">                <span class="keyword">with</span> open(fixed_ip_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> ip_file:</span><br><span class="line">                    ip_file.write(ip)</span><br><span class="line">                <span class="keyword">return</span> send_email, content, subject</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 如果当前 IP 与原 IP 相同，则发送通知邮件</span></span><br><span class="line">                subject = <span class="string">&quot;电脑重启成功，IP 地址未改变&quot;</span></span><br><span class="line">                content = <span class="string">f&quot;电脑重启成功，IP 未发生改变，IP 地址是 <span class="subst">&#123;ip&#125;</span>&quot;</span></span><br><span class="line">                <span class="keyword">return</span> send_email, content, subject</span><br><span class="line">    <span class="comment"># 如果 /tmp 下有文件 tmp_ip_file，那么表示电脑正常运行</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">with</span> open(tmp_ip_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> ip_file:</span><br><span class="line">            origin_ip = ip_file.readline()</span><br><span class="line">        <span class="comment"># 如果当前 IP 与 tmp_ip_file 中不一致，则更新 tmp_ip_file 中的 IP</span></span><br><span class="line">        <span class="keyword">if</span> ip != origin_ip:</span><br><span class="line">            <span class="keyword">with</span> open(tmp_ip_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> ip_file:</span><br><span class="line">                ip_file.write(ip)</span><br><span class="line">        <span class="comment"># 如果 fixed_ip_file 不存在</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(fixed_ip_file):</span><br><span class="line">            <span class="keyword">with</span> open(fixed_ip_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> ip_file:</span><br><span class="line">                ip_file.write(ip)</span><br><span class="line">            send_email = <span class="literal">True</span></span><br><span class="line">            subject = <span class="string">f&quot;电脑正常运行中，但 IP 文件丢失&quot;</span></span><br><span class="line">            content = <span class="string">f&quot;电脑正常运行中，但 IP 文件 <span class="subst">&#123;fixed_ip_file&#125;</span> 丢失，当前 IP 地址是 <span class="subst">&#123;ip&#125;</span>&quot;</span></span><br><span class="line">            <span class="keyword">return</span> send_email, content, subject</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 如果 fixed_ip_file 存在</span></span><br><span class="line">            <span class="keyword">with</span> open(fixed_ip_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> ip_file:</span><br><span class="line">                origin_ip = ip_file.readline()</span><br><span class="line">            <span class="comment"># 如果当前 IP 与 fixed_ip_file 的不相同</span></span><br><span class="line">            <span class="keyword">if</span> ip != origin_ip:</span><br><span class="line">                send_email = <span class="literal">True</span></span><br><span class="line">                subject = <span class="string">f&quot;电脑正常运行中，IP 地址改变为 <span class="subst">&#123;ip&#125;</span>&quot;</span></span><br><span class="line">                content = <span class="string">f&quot;电脑正常运行中，IP 地址改变。旧 IP: <span class="subst">&#123;origin_ip&#125;</span>，新 IP: <span class="subst">&#123;ip&#125;</span>&quot;</span></span><br><span class="line">                <span class="keyword">with</span> open(fixed_ip_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> ip_file:</span><br><span class="line">                    ip_file.write(ip)</span><br><span class="line">                <span class="keyword">return</span> send_email, content, subject</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 如果当前 IP 与 fixed_ip_file 的相同，则不发生通知邮件；这是大多数正常情况</span></span><br><span class="line">                subject = <span class="string">&quot;电脑正常运行中，IP 地址未改变&quot;</span></span><br><span class="line">                content = <span class="string">f&quot;电脑正常运行中，IP 地址未改变，仍然是 <span class="subst">&#123;ip&#125;</span>&quot;</span></span><br><span class="line">                <span class="keyword">return</span> send_email, content, subject</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_global_ip</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取电脑的外网 IP 地址</span></span><br><span class="line"><span class="string">    :return: 外网 IP</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    s = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">        s.connect((<span class="string">&quot;8.8.8.8&quot;</span>, <span class="number">80</span>))</span><br><span class="line">        ip = s.getsockname()[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        s.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_format_addr</span>(<span class="params">s</span>):</span></span><br><span class="line">    name, addr = parseaddr(s)</span><br><span class="line">    <span class="keyword">return</span> formataddr((Header(name, <span class="string">&quot;utf-8&quot;</span>).encode(), addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mail</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        sender=<span class="string">&quot;xxx@qq.com&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        password=<span class="string">&quot;xxxZHyyy&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        recipients=(<span class="params"><span class="string">&quot;jinzhongxu@csu.ac.cn&quot;</span>, <span class="string">&quot;otheruser@163.com&quot;</span></span>),</span></span></span><br><span class="line"><span class="function"><span class="params">        smtp_server=<span class="string">&quot;smtp.qq.com&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        port=<span class="number">465</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        subject=<span class="string">&quot;服务器 IP 地址改变&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        text=<span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        attachment=(<span class="params"><span class="string">&quot;&quot;</span>,</span>),</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    msg = MIMEMultipart()</span><br><span class="line">    msg[<span class="string">&quot;From&quot;</span>] = _format_addr(<span class="string">&quot;JinzhongXu-Pythoner &lt;%s&gt;&quot;</span> % sender)</span><br><span class="line">    msg[<span class="string">&quot;To&quot;</span>] = _format_addr(<span class="string">&quot;管理员 &lt;%s&gt;&quot;</span> % <span class="string">&quot;, &quot;</span>.join(list(recipients)))</span><br><span class="line">    msg[<span class="string">&quot;Subject&quot;</span>] = Header(subject, <span class="string">&quot;utf-8&quot;</span>).encode()</span><br><span class="line">    <span class="comment"># 邮件正文是MIMEText:</span></span><br><span class="line">    msg.attach(MIMEText(text, <span class="string">&quot;plain&quot;</span>, <span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">    attachment = list(attachment)</span><br><span class="line">    <span class="keyword">if</span> attachment != [<span class="string">&quot;&quot;</span>]:</span><br><span class="line">        <span class="keyword">for</span> i, file_path <span class="keyword">in</span> enumerate(attachment):</span><br><span class="line">            <span class="keyword">with</span> open(file_path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="comment"># 设置附件的MIME和文件名:</span></span><br><span class="line">                file_dir, file_name = os.path.split(os.path.abspath(file_path))</span><br><span class="line">                filename_extension = file_name.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">                mime = MIMEBase(<span class="string">&quot;file&quot;</span>, filename_extension[<span class="number">-1</span>], filename=file_name)</span><br><span class="line">                <span class="comment"># 加上必要的头信息:</span></span><br><span class="line">                mime.add_header(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment&quot;</span>, filename=file_name)</span><br><span class="line">                mime.add_header(<span class="string">&quot;Content-ID&quot;</span>, <span class="string">f&quot;&lt;<span class="subst">&#123;i&#125;</span>&gt;&quot;</span>)</span><br><span class="line">                mime.add_header(<span class="string">&quot;X-Attachment-Id&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="comment"># 把附件的内容读进来:</span></span><br><span class="line">                mime.set_payload(f.read())</span><br><span class="line">                <span class="comment"># 用Base64编码:</span></span><br><span class="line">                encoders.encode_base64(mime)</span><br><span class="line">                <span class="comment"># 添加到MIMEMultipart:</span></span><br><span class="line">                msg.attach(mime)</span><br><span class="line"></span><br><span class="line">    server = smtplib.SMTP_SSL(smtp_server, port)</span><br><span class="line">    <span class="comment"># 控制打印日志</span></span><br><span class="line">    <span class="comment"># server.set_debuglevel(2)</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        server.login(</span><br><span class="line">            sender,</span><br><span class="line">            base64.b64decode(password.encode(), altchars=<span class="literal">None</span>, validate=<span class="literal">False</span>).decode(),</span><br><span class="line">        )</span><br><span class="line">        server.sendmail(sender, list(recipients), msg.as_string())</span><br><span class="line">        logs = <span class="string">f&quot;<span class="subst">&#123;sender&#125;</span> 给 <span class="subst">&#123;<span class="string">&#x27;; &#x27;</span>.join(recipients)&#125;</span> 的邮件发送成功&quot;</span></span><br><span class="line">    <span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">        logs = <span class="string">&quot;Error: 无法发送邮件&quot;</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        server.quit()</span><br><span class="line">    <span class="keyword">return</span> logs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    send_email, content, subject = computer_status()</span><br><span class="line">    <span class="keyword">if</span> send_email:</span><br><span class="line">        mail(subject=subject, text=content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>



<h1 id="配置定时检查"><a href="#配置定时检查" class="headerlink" title="配置定时检查"></a>配置定时检查</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"><span class="comment"># 添加如下内容，每分钟进行 IP 检查和是否是重启状态</span></span><br><span class="line">*/1 * * * * /usr/<span class="built_in">local</span>/miniconda/bin/python /home/jinzhongxu/PythonProjects/send_message.py</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/338190964">linux服务器开机发送本机ip地址到指定邮箱</a></li>
<li><a href="https://www.cnblogs.com/lianshuiwuyi/p/11636876.html">Python 获取本机内网IP</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/352642228">Linux临时目录/tmp与/var/tmp</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>ubuntu</tag>
        <tag>linux</tag>
        <tag>mail</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 系统中的开机自启命令简单介绍</title>
    <url>/2020/06/12/auto-start-command-in-linux/</url>
    <content><![CDATA[<p>Linux 系统可以通过命令行，有效简便快捷的启动程序、设置开机自启的程序等，并且，往往有多个命令可以达到这一效果。但是，需要我们了解这些命令并知悉它们之间的区别，下面主要简单的总结一下，以下代码以 Ubuntu18.04 为例</p>
<a id="more"></a>

<h1 id="启动程序命令"><a href="#启动程序命令" class="headerlink" title="启动程序命令"></a>启动程序命令</h1><h2 id="etc-init-d-appname"><a href="#etc-init-d-appname" class="headerlink" title="/etc/init.d/appname"></a>/etc/init.d/appname</h2><p>常用方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看ssh服务状态</span></span><br><span class="line">/etc/init.d/ssh status   </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动ssh服务，注意需要sudo权限</span></span><br><span class="line">sudo /etc/init.d/ssh start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭ssh服务</span></span><br><span class="line">sudo /etc/init.d/ssh stop</span><br></pre></td></tr></table></figure>

<p>/etc/init.d/ 其实是一个目录，里面存放的都是系统启动时需要运行或关闭的命令，这些命令常常通过软连接，连接到各级启动级别的文件夹中，如 /etc/rc3.d/，通过下面介绍的命令 update-rc.d 和 systemctl 可以设置开机启动或关闭</p>
<h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>常用方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看防火墙状态</span></span><br><span class="line">service ufw status</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭防火墙，注意sudo权限</span></span><br><span class="line">sudo service ufw stop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动防火墙</span></span><br><span class="line">sudo service ssh start</span><br></pre></td></tr></table></figure>

<p>service 是一个运行 System V 的 init script，它其实是运行 /etc/init.d 和  /{lib,run,etc}/systemd/system 中的命令或程序，对于 /etc/init.d/ 就是等同于上面介绍的命令 /etc/init.d/appname</p>
<h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p>常用方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看zabbix-agent运行状态</span></span><br><span class="line">systemctl status zabbix-agent.service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭zabbix-agent</span></span><br><span class="line">systemctl stop zabbix-agent.service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动zabbix-agent</span></span><br><span class="line">systemctl start zabbix-agent.service</span><br></pre></td></tr></table></figure>

<p>该命令非常强大，不仅可以启动程序，还可以设置程序开机自启等，不过在 Ubuntu 14.04等之前的系统中未有该命令。在 Centos、Redhat 等系统中，设置程序开机自启的有 chkconfig 等，不过，现在逐渐被抛弃。功能上 systemctl = service + chkconfig</p>
<h1 id="设置开机自启命令"><a href="#设置开机自启命令" class="headerlink" title="设置开机自启命令"></a>设置开机自启命令</h1><h2 id="update-rc-d"><a href="#update-rc-d" class="headerlink" title="update-rc.d"></a>update-rc.d</h2><p>常用方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 取消开机启动zabbix-agent，从/etc/rcN.d中清除到/etc/init.d/zabbix-agent链接</span></span><br><span class="line">update-rc.d -f zabbix-agent remove</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置默认启动级别的zabbix-agent开机自启</span></span><br><span class="line">update-rc.d zabbix-agent defaults</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置zabbix-agent开机自启</span></span><br><span class="line">update-rc.d zabbix-agent enable</span><br></pre></td></tr></table></figure>

<h2 id="chkconfig"><a href="#chkconfig" class="headerlink" title="chkconfig"></a>chkconfig</h2><p>常用方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置开机启动zabbix-agent</span></span><br><span class="line">chkconfig --add zabbix-agent</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置开机不启动zabbix-agent</span></span><br><span class="line">chkconfig --del zabbix-agent</span><br></pre></td></tr></table></figure>

<p>在 Debian、Ubuntu上无该命令，在Centos、RedHat上可以使用</p>
<h2 id="systemctl-1"><a href="#systemctl-1" class="headerlink" title="systemctl"></a>systemctl</h2><p>常用方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开机启动ssh服务</span></span><br><span class="line">systemctl enable ssh.socket</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开机不启动ssh服务</span></span><br><span class="line">systemctl disable ssh.socket</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看zabbix-agent是否开机启动</span></span><br><span class="line">systemctl list-unit-files | grep zabbix-agent</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 中的 awk 命令</title>
    <url>/2021/09/06/awk-command-language/</url>
    <content><![CDATA[<p>awk 是一个处理文本的应用程序，也是一门语言。基本上所有的 Linux 发行版都自带该程序。它依次处理文件的每一行，并读取里面的每一个字段，尤其是日志文件、CSV文件等。本篇介绍 awk 如何在命令行上使用，以 Debian 10.8 为例。</p>
<a id="more"></a>

<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模式或条件可省略</span></span><br><span class="line">awk <span class="string">&#x27;模式 &#123;动作&#125;&#x27;</span> 文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子 1</span></span><br><span class="line">awk <span class="string">&#x27;NR &lt; 3 &#123;print $0&#125;&#x27;</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子 2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;21 25 26&#x27;</span> | awk <span class="string">&#x27;&#123;print sin($1), cos($NF)&#125;&#x27;</span></span><br><span class="line">0.836656 0.646919</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子 3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;21:25:26&#x27;</span> | awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print sin($1), cos($NF)&#125;&#x27;</span></span><br><span class="line">0.836656 0.646919</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子 4</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;21:25:26&#x27;</span> | awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $1 * $NF&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上例 1 中，<code>NR</code> 是一个变量表示行号，<code>NR &lt; 3</code> 表示只取前 2 行，为模式或条件；大括号中的为动作，<code>print $0</code> 表示打印所有列；<code>~/.bashrc</code> 表示文件名。因此，命令是将文件 <code>~/.bashrc</code> 中前 2 行所有列打印出来。</p>
<p>上例 2 中，通过管道符 <code>|</code>将 <code>echo</code> 的结果传给 <code>awk</code>，字符串 <code>21 25 26</code>以空格为分隔符，<code>awk</code>中默认的列分隔符就是空格，<code>$1</code> 表示第1列 <code>21</code>，依次类推，<code>NF</code>是变量表示最后一列，这里是 <code>26</code>，函数 <code>sin</code>, <code>cos</code> 是 awk 中自带的函数。两个函数之间的<code>,</code>表示打印时以空格为分隔符。</p>
<p>上例 3 中，与例 2 不同的是，字符串<code>21:25:26</code>的分隔符是 <code>:</code>，在 awk 中以参数 <code>-F</code> 指定分隔符。</p>
<p>上例 4 中，给出了自定义运算输出结果。</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>除了上面例子中介绍的内置变量<code>NR, NF</code> 外，还有很多变量，这里列出常用的几个变量。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">FILENAME：当前文件名</span><br><span class="line">FS：字段分隔符，默认是空格和制表符。</span><br><span class="line">RS：行分隔符，用于分割每一行，默认是换行符。</span><br><span class="line">OFS：输出字段的分隔符，用于打印时分隔字段，默认为空格。</span><br><span class="line">ORS：输出记录的分隔符，用于打印时分隔记录，默认为换行符。</span><br><span class="line">OFMT：数字输出的格式，默认为％.6g。</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如打印时添加行号</span></span><br><span class="line">awk <span class="string">&#x27;NR &lt; 3 &#123;print NR &quot;)&quot;, FILENAME&#125;&#x27;</span> ~/.bashrc</span><br><span class="line">1) /home/jinzhongxu/.bashrc</span><br><span class="line">2) /home/jinzhongxu/.bashrc</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>除了第一节例子中介绍的内置函数<code>sin, cos</code>外，还有很多函数，这里列出常用的几个函数。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">toupper(x): 字符串大写</span><br><span class="line">tolower(x)：字符串小写。</span><br><span class="line">length(x)：返回字符串长度。</span><br><span class="line">substr(x)：返回子字符串。</span><br><span class="line">atan2(y,x)：Arctan of y/x between -pi and pi.</span><br><span class="line">exp(x)：Exponential function.</span><br><span class="line">int(x)：Returns x truncated towards zero.</span><br><span class="line">log(x)：Natural logarithm.</span><br><span class="line">sqrt()：平方根。</span><br><span class="line">rand()：随机数。</span><br></pre></td></tr></table></figure>

<p>更多请使用命令 <code>man awk</code>查看。</p>
<h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><p>条件就是第一节中介绍的模式，可处理更加特定的输出，如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只打印偶数行</span></span><br><span class="line">awk <span class="string">&#x27;NR % 2 == 0 &#123;print $0&#125;&#x27;</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只打印行号大于 3 的行</span></span><br><span class="line">awk <span class="string">&#x27;NR &gt; 3 &#123;print $0&#125;&#x27;</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只打印第一个字符串是 export 的行</span></span><br><span class="line">awk <span class="string">&#x27;$1 == &quot;export&quot; &#123;print $0&#125;&#x27;</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只打印第一个字符串是 export 或 alias 的行</span></span><br><span class="line">awk <span class="string">&#x27;$1 == &quot;export&quot; || $1 == &quot;alias&quot; &#123;print $0&#125;&#x27;</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h1 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h1><p>if 语句能够处理更复杂的逻辑，如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只打印第一个字符串是 export 的行</span></span><br><span class="line">awk <span class="string">&#x27;&#123;if ($1 == &quot;export&quot;) print $0&#125;&#x27;</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于以字符串 export 开头的行直接打印，其他行打印成 &quot;*&quot; 号</span></span><br><span class="line">awk <span class="string">&#x27;&#123;if ($1 == &quot;export&quot;) print $0; else print &quot;*&quot;&#125;&#x27;</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://www.ruanyifeng.com/blog/2018/11/awk.html">awk 入门教程</a></li>
<li><a href="https://gregable.com/2010/09/why-you-should-know-just-little-awk.html">Why you should learn just a little Awk</a></li>
<li><a href="https://likegeeks.com/awk-command/">30 Examples for Awk Command in Text Processing</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分基本定理和定积分计算</title>
    <url>/2020/09/19/basic-theorem-of-calculus-and-calculation-of-definite-integral/</url>
    <content><![CDATA[<p>首先给出一个结论：连续函数必定存在原函数。</p>
<a id="more"></a>

<h1 id="变限积分与原函数的存在性"><a href="#变限积分与原函数的存在性" class="headerlink" title="变限积分与原函数的存在性"></a>变限积分与原函数的存在性</h1><p>假设$f(x)$在$[a,b]$上可积，对于任何的$x\in[a,b]$，$f$在$[a,x]$上也可积，定义<br>$$<br>\Phi(x) = \int^x_a f(t) \mathrm{d}t, x\in [a, b]<br>$$<br>为以积分上限$x$为自变量的函数，称为变上限的定积分。同样，定义变下限的定积分为<br>$$<br>\Psi(x) = \int^b_x f(t) \mathrm{d}t, x\in[a,b].<br>$$<br>统称$\Psi$与$\Phi$为变限积分。由于$\int^b_x f(t) \mathrm{d}t = -\int^x_b f(t)\mathrm{d}t$，因此下面只讨论变上限积分。</p>
<p><strong>定理 9.9</strong>    若$f$在$[a,b]$上可积，则$\Phi$在$[a,b]$上连续。</p>
<p><strong>定理 9.10</strong>    （原函数存在定理）若$f$在$[a,b]$上连续，则$\Phi$在$[a,b]$上处处可导，且<br>$$<br>\Phi^{\prime}(x) = \frac{\mathrm{d}}{\mathrm{d}x}\int^x_a f(t)\mathrm{d}t = f(x), x \in [a, b].<br>$$<br><strong>定理 9.11</strong>    （积分第二中值定理）设函数$f$在$[a,b]$上可积，</p>
<ul>
<li>若函数$g$在$[a,b]$上减，且$g(x)\geq 0$，则存在$\xi \in [a,b]$，使得</li>
</ul>
<p>$$<br>\int^b_a f(x)g(x) \mathrm{d}x = g(a) \int^{\xi}_a f(x) \mathrm{d}x.<br>$$</p>
<ul>
<li>若函数$g$在$[a,b]$上增，且$g(x)\geq 0$，则存在$\eta \in [a,b]$，使得</li>
</ul>
<p>$$<br>\int^b_a f(x) g(x) \mathrm{d}x = g(b) \int^b_{\eta} f(x) \mathrm{d}x.<br>$$</p>
<ul>
<li>推广：若函数$g$在$[a,b]$上单调，则存在$\xi \in [a,b]$使得</li>
</ul>
<p>$$<br>\int_{a}^{b} f(x)g(x) \mathrm{d}x = g(a) \int_{a}^{\xi} f(x) \mathrm{d}x + g(b) \int_{\xi}^{b} f(x) \mathrm{d}x.<br>$$</p>
<h1 id="换元积分法与分部积分法"><a href="#换元积分法与分部积分法" class="headerlink" title="换元积分法与分部积分法"></a>换元积分法与分部积分法</h1><p><strong>定理 9.12</strong>    （定积分换元积分法）若函数$f$在$[a,b]$上连续，$\varphi^{\prime}$在$[a,b]$上可积，且满足<br>$$<br>\varphi(\alpha)=a, \varphi(\beta)=b, \varphi([\alpha, \beta]) \subset [a,b],<br>$$<br>则有定积分换元公式：<br>$$<br>\int^b_a f(x) \mathrm{d}x = \int^{\beta}_{\alpha}f(\varphi(t))\varphi^{\prime}(t) \mathrm{d}t.<br>$$<br><strong>定理 9.13</strong>    （定积分分部积分法）若$u(x),v(x)$为$[a,b]$上的可微函数，且$u^{\prime}(x)$和$v^{\prime}(x)$都在$[a,b]$上可积，则有定积分分部积分公式：<br>$$<br>\int^b_a u(x)v^{\prime}(x) \mathrm{d}x = u(x)v(x)\vert^b_a - \int^b_a u^{\prime}(x)v(x)\mathrm{d}x.<br>$$</p>
<h1 id="泰勒公式的积分型余项"><a href="#泰勒公式的积分型余项" class="headerlink" title="泰勒公式的积分型余项"></a>泰勒公式的积分型余项</h1><p>若在$[a,b]$上$u(x),v(x)$有$n+1$阶连续导函数，则有<br>$$<br>\int^b_a u(x)v^{(n+1)}(x)\mathrm{d}x = [u(x)v^{(n)}(x) - u^{\prime}v^{(n-1)}(x) + \cdots + \\<br>(-1)^n u^{(n)}(x)v(x)]^b_a + (-1)^{n+1}\int^b_a u^{(n+1)}(x) v(x) \mathrm{d}x \\<br>(n = 1, 2, \cdots)<br>$$<br>假设函数$f$在点$x_0$的某领域$U(x_0)$上有$n+1$阶连续导函数，令$x\in U(x_0)$，$u(t) = (x-t)^n, v(t) = f(t), t\in [x_0, x]$ （或$[x, x_0]$），<br>$$<br>\int^x_{x_0} (x-t)^n f^{(n+1)}(t) \mathrm{d}t = [(x-t)^n f^{(n)}(t) + n(x-t)^{n-1}f^{(n-1)}(t) + \cdots + \\<br>n! f(t)]^x_{x_0} + \int^x_{x_0} 0 \cdot f(t) \mathrm{d}t \\<br>= n! f(x) - n! [f(x_0) + f^{\prime}(x_0)(x-x_0) + \cdots + \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n] \\<br>= n! R_n(x)<br>$$<br>其中$R_n(x)$即为泰勒公式的$n$阶余项。由此求得<br>$$<br>R_n(x) = \frac{1}{n!} \int^x_{x_0} f^{(n+1)}(t)(x-t)^n \mathrm{d}t,<br>$$<br>这就是泰勒公式的积分型余项。</p>
<p>由于$f^{(n+1)}(t)$连续，$(x-t)^n$在$[x_0, x]$（或$[x, x_0]$）上保持同号，因此由推广的积分第一中值定理，可得<br>$$<br>R_n(x) = \frac{1}{n!} f^{(n+1)}(\xi) \int^x_{x_0} (x-t)^n \mathrm{d}t \\<br>= \frac{1}{(n+1)!}f^{(n+1)}(\xi)(x-x_0)^{n+1},<br>$$<br>其中$\xi = x_0 + \theta(x-x_0), 0\leq \theta \leq 1$，得到得结果就是拉格朗日型余项。</p>
<p>如果直接运用积分第一中值定理，那么<br>$$<br>R_n(x) = \frac{1}{n!}f^{(n+1)}(\xi)(x-\xi)^n(x-x_0), \\<br>\xi = x_0 + \theta(x-x_0), 0 \leq \theta \leq 1.<br>$$<br>由于<br>$$<br>(x-\xi)^n (x-x_0) = [x-x_0 - \theta(x-x_0)]^n(x-x_0) \\<br>=(1-\theta)^n(x-x_0)^{n+1},<br>$$<br>因此<br>$$<br>R_n(x) = \frac{1}{n!}f^{(n+1)}(x_0 + \theta(x-x_0))(1-\theta)^n(x-x_0)^{n+1}, \\<br>0 \leq \theta \leq 1.<br>$$<br>特别地，当$x_0 = 0$时，又有<br>$$<br>R_n(x) = \frac{1}{n!}f^{(n+1)}(\theta x)(1 - \theta)^n x^{n+1}, 0\leq \theta \leq 1.<br>$$<br>称为泰勒公式得柯西型余项。</p>
<h1 id="三角函数积分技巧"><a href="#三角函数积分技巧" class="headerlink" title="三角函数积分技巧"></a>三角函数积分技巧</h1><ul>
<li><p>$\int_{0}^{\frac{\pi}{2}} f(\sin x, \cos x)\mathrm{d}x = \int_{0}^{\frac{\pi}{2}} f(\cos x, \sin x)\mathrm{d}x.$ </p>
</li>
<li><p>$I(m,n) = \int^{\frac{\pi}{2}}_0 \cos^m x \sin^n x \mathrm{d}x$，$m,n$为正整数，则</p>
</li>
</ul>
<p>$$<br>I(m,n) = \frac{m-1}{m+n}I(m-2,n) = \frac{n-1}{n+m}I(m,n-2), m,n=2,3,\cdots.<br>$$</p>
<p>$$<br>I(m,n) =<br>\begin{cases}<br>\frac{(m-1)!! \cdot (n-1)!!}{(m+n)!!} \frac{\pi}{2}, m,n 都是偶数;\\<br>\frac{(m-1)!! \cdot (n-1)!!}{(m+n)!!}, 其他.<br>\end{cases}<br>$$</p>
<ul>
<li>$\int^{\frac{\pi}{2}}_0 \sin^n x \mathrm{d}x = \int^{\frac{\pi}{2}}_0 \cos^n x \mathrm{d}x = I(n, 0)$</li>
</ul>
<p>$$<br>I(n, 0) =<br>\begin{cases}<br>\frac{(n-1)!!}{n!!}\frac{\pi}{2}, n 是偶数;\\<br>\frac{(n-1)!!}{n!!}.<br>\end{cases}<br>$$</p>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>integral</tag>
        <tag>definite integral</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用服务器搭建博客</title>
    <url>/2019/12/22/blog-construct/</url>
    <content><![CDATA[<p>参照博文《<a rel="noreferrer noopener" aria-label="（在新窗口打开）" href="https://websiteforstudents.com/install-wordpress-on-ubuntu-18-04-lts-beta-with-apache2-mariadb-and-php-7-1/" target="_blank"><em>Website for Students</em></a>》或《<a rel="noreferrer noopener" aria-label="How to Install WordPress with LAMP Stack on Ubuntu 18.04（在新窗口打开）" href="https://www.rosehosting.com/blog/how-to-install-wordpress-with-lamp-stack-on-ubuntu-18-04/" target="_blank"><em><strong>How to Install WordPress with LAMP Stack on Ubuntu 18.04</strong></em></a>》进行搭建.</p>
<p>在Ubuntu18.04上，分别按照《Website for Students》和文章《How to Install WordPress with LAMP Stack on Ubuntu 18.04》搭建网站时，发现第一篇文章能够成功进入WordPress，而第二篇文章无法配置WordPress，经分析后通过命令 </p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install php-mysql</span><br></pre></td></tr></table></figure>

<p>进行修复，成功进入WordPress配置页面。</p>
<p>下面根据前面两篇文章总结出一个搭建网站的方法，一共分为7步：</p>
<ul><li><a href="https://www.rosehosting.com/blog/how-to-install-wordpress-with-lamp-stack-on-ubuntu-18-04/#Step-1-Connect-to-your-Server">Step 1: Connect to your Server</a></li><li><a href="https://www.rosehosting.com/blog/how-to-install-wordpress-with-lamp-stack-on-ubuntu-18-04/#Step-2-Apache-Web-Server-Installation">Step 2: Apache Web Server Installation</a></li><li><a href="https://www.rosehosting.com/blog/how-to-install-wordpress-with-lamp-stack-on-ubuntu-18-04/#Step-3-Install-PHP">Step 3: Install PHP</a></li><li><a href="https://www.rosehosting.com/blog/how-to-install-wordpress-with-lamp-stack-on-ubuntu-18-04/#Step-4-Install-the-MySQL-Database-server">Step 4: Install the MySQL Database server</a></li><li><a href="https://www.rosehosting.com/blog/how-to-install-wordpress-with-lamp-stack-on-ubuntu-18-04/#Step-5-Create-a-Database-for-WordPress">Step 5: Create a Database for WordPress</a></li><li><a href="https://www.rosehosting.com/blog/how-to-install-wordpress-with-lamp-stack-on-ubuntu-18-04/#Step-6-Install-WordPress">Step 6: Install WordPress</a></li><li><a href="https://www.rosehosting.com/blog/how-to-install-wordpress-with-lamp-stack-on-ubuntu-18-04/#Step-6-Create-the-Virtual-Host-Files">Step 6: Create the Virtual Host Files</a></li><li><a href="https://www.rosehosting.com/blog/how-to-install-wordpress-with-lamp-stack-on-ubuntu-18-04/#Step-7-Configure-WordPress">Step 7: Configure WordPress</a></li></ul>
<p>具体地</p>
<p><strong>Step 1: Connect to your Server</strong>，更新系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get upgrade</span><br></pre></td></tr></table></figure>

<p><strong>Step 2: Apache Web Server Installation</strong>，安装Web服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install apache2</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> apache2</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status apache2</span><br></pre></td></tr></table></figure>

<p><strong>Step 3: Install PHP</strong>，安装PHP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install php php-curl php-gd php-mbstring php-xml php-xmlrpc php-soap php-intl php-zip&lt;strong&gt; php-mysql&lt;/strong&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Step 4: Install the MySQL Database server</strong>，安装数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install mysql-server</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure>

<p><strong>Step 5: Create a Database for WordPress</strong>，为网站创建一个数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<pre class="wp-block-preformatted">CREATE DATABASE <strong>wp</strong>;
GRANT ALL PRIVILEGES ON <strong>wp</strong>.* TO '<strong>jayzon</strong>'@'localhost' IDENTIFIED BY '<strong>StrongPassword</strong>';
FLUSH PRIVILEGES;
EXIT;</pre>
<p><strong>Step 6: Install WordPress</strong>，安装WordPress</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/www/html</span><br><span class="line">wget -c http://wordpress.org/latest.zip</span><br><span class="line">unzip latest.zip</span><br><span class="line">chown -R www-data:www-data wordpress</span><br><span class="line">rm latest.zip</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/www/html/wordpress</span><br><span class="line">mv wp-config-sample.php wp-config.php</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim wp-config.php</span><br></pre></td></tr></table></figure>

<p>插入一下代码</p>
<pre class="wp-block-preformatted">// ** MySQL settings - You can get this info from your web host ** //
/** The name of the database for WordPress */
define('DB_NAME', '<strong>wp</strong>');

<p>/** MySQL database username */<br>define(‘DB_USER’, ‘<strong>jayzon</strong>‘);</p>
<p>/** MySQL database password */<br>define(‘DB_PASSWORD’, ‘<strong>StrongPassword</strong>‘);</p>
<p>/** MySQL hostname */<br>define(‘DB_HOST’, ‘localhost’);</p>
<p>/** Database Charset to use in creating database tables. */<br>define(‘DB_CHARSET’, ‘utf8’);</p>
<p>/** The Database Collate type. Don’t change this if in doubt. */<br>define(‘DB_COLLATE’, ‘’);</pre></p>
<p><strong>Step 6: Create the Virtual Host Files</strong>，打开80端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/apache2/sites-available/your_domain.com.conf</span><br></pre></td></tr></table></figure>

<pre class="wp-block-preformatted">&lt;VirtualHost *:80>

ServerAdmin admin@jayzonxu.com
ServerName jayzonxu.com
ServerAlias www.jayzonxu.com
DocumentRoot /var/www/html/wordpress

&lt;Directory /var/www/html/wordpress>
     Options Indexes FollowSymLinks
     AllowOverride All
     Require all granted
&lt;/Directory>

ErrorLog ${APACHE_LOG_DIR}/jayzonxu.com_error.log 
CustomLog ${APACHE_LOG_DIR}/jayzonxu.com_access.log combined 
&lt;/VirtualHost></pre>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /etc/apache2/sites-available/jayzonxu.com.conf /etc/apache2/sites-enabled/jayzonxu.com.conf</span><br></pre></td></tr></table></figure>

<p><strong>Step 7: Configure WordPress</strong>，配置网站</p>
<p>在浏览器中输入以下网址，进行配置WordPress</p>
<pre class="wp-block-preformatted">http://www.jayzonxu.com/</pre>
更多请参考
[embed]https://www.rosehosting.com/blog/how-to-install-wordpress-with-lamp-stack-on-ubuntu-18-04/[/embed]]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title>Clion 运行 C 出现 cmake-build-debug 找不到的解决方法</title>
    <url>/2021/04/08/c-remote-cmake-debug/</url>
    <content><![CDATA[<p>使用 Clion 连接远程服务器，利用服务器上的 c 编译器、make、cmake 进行 C 开发非常方便高效，但是，有时候编译时会出现 cmake-build-debug 找不到，导致无法编译运行 C 代码。下面给出解决方法。</p>
<a id="more"></a>

<p>使用远程服务器时，已经自动将本地的 CMakeLists.txt、main.c 和 其他 .c 文件同步到服务器上，但是，无法同步本地的 cmake-build-debug 文件夹，该文件夹是编译运行 C 程序的。尝试通过两种方法解决。</p>
<h1 id="手动远程服务器上生成"><a href="#手动远程服务器上生成" class="headerlink" title="手动远程服务器上生成"></a>手动远程服务器上生成</h1><p>首先通过 SSH 连接到远程服务器上，并 cd 到 C 工程目录，然后，创建文件夹 cmake-build-debug</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir cmake-build-debug</span><br></pre></td></tr></table></figure>

<p>最后，使用服务器的 cmake 生成 make 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> cmake-build-debug</span><br><span class="line">cmake ..</span><br></pre></td></tr></table></figure>

<h1 id="在-Clion-上自动生成"><a href="#在-Clion-上自动生成" class="headerlink" title="在 Clion 上自动生成"></a>在 Clion 上自动生成</h1><p>其实 Clion 上给出了自动生成 make file 的工具。</p>
<p>在 Clion 窗口最下面一行，找到 CMake，然后点击 CMake 窗口左上角的同步（Reload CMake Project），此时，会在远程服务器上自动生成 make file，即 cmake-build-debug 文件夹。</p>
]]></content>
      <categories>
        <category>technology</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>cmake</tag>
        <tag>clion</tag>
      </tags>
  </entry>
  <entry>
    <title>Cassandra 集群部署</title>
    <url>/2020/02/28/cassandra-deploy/</url>
    <content><![CDATA[<p>Facebook参照Amazon的NoSQL的Dynamo和Google Big Table开发了Cassandra，它是一种NoSQL数据库。其cqlsh的运行依赖于python 2.x，<strong>注意python3目前还不支持</strong>。下面记载一下自己在6台服务器上搭建Cassandra集群的过程以及需要注意的点。这里以Ubuntu18.04为例。</p>
<a id="more"></a>

<p>假设我们6个节点服务器的ip地址分别为1.1.1.0, 1.1.1.1, 1.1.1.2, 1.1.1.3, 1.1.1.4, 1.1.1.5，并希望把1.1.1.1， 1.1.1.2， 1.1.1.3 作为种子节点（一般不少于2个），其他为正常节点。下面操作默认在1.1.1.0机器上执行，并且默认各机器之间已经可以互相进行SSH免密连接。</p>
<h1 id="下载Cassandra和JDK"><a href="#下载Cassandra和JDK" class="headerlink" title="下载Cassandra和JDK"></a>下载Cassandra和JDK</h1><p>Cassandra的下载地址是<a href="http://cassandra.apache.org/">Apache Cassandra</a>.</p>
<p>JDK目前推荐jdk8，下载地址是<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">Java SE Development Kit 8 Downloads</a> .</p>
<h1 id="安装Cassandra-和JDK"><a href="#安装Cassandra-和JDK" class="headerlink" title="安装Cassandra 和JDK"></a>安装Cassandra 和JDK</h1><h2 id="安装Cassandra"><a href="#安装Cassandra" class="headerlink" title="安装Cassandra"></a>安装Cassandra</h2><p>安装非常简单，将压缩包解压到你喜欢的目录即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzf apache-cassandra-3.11.6-bin.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p>安装也非常简单，只需要解压缩到喜欢的目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzf jdk-8u241-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>

<h1 id="配置Cassandra环境变量和Java环境变量"><a href="#配置Cassandra环境变量和Java环境变量" class="headerlink" title="配置Cassandra环境变量和Java环境变量"></a>配置Cassandra环境变量和Java环境变量</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~.bashrc</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/home/jinzhongxu/jdk1.8.0_241</span><br><span class="line">export CASSANDRA_HOME=/home/jinzhongxu/apache-cassandra-3.11.6</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$CASSANDRA_HOME/bin</span><br></pre></td></tr></table></figure>

<p>然后，在主目录下，运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sourc ~/.bashrc</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<p>没有报错，就说明配置成功。</p>
<h1 id="配置Cassandra运行参数"><a href="#配置Cassandra运行参数" class="headerlink" title="配置Cassandra运行参数"></a>配置Cassandra运行参数</h1><p>进入配置文件目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> apache-cassandra-3.11.6/conf/</span><br><span class="line">vim cassandra.yaml</span><br></pre></td></tr></table></figure>

<p>首先，在1.1.1.0机器上修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cluster_name: &#x27;Cassandra Cluster&#x27; # 修改为自己喜欢的名字，后面运行后再修改比较麻烦</span><br><span class="line">- seeds: &quot;1.1.1.1,1.1.1.2,1.1.1.3&quot;</span><br><span class="line">listen_address: 1.1.1.0</span><br><span class="line">rpc_address: 1.1.1.0</span><br><span class="line">data_file_directories:</span><br><span class="line">	- /var/lib/cassandra/data # 也可以添加多个用于存储数据</span><br><span class="line">commitlog_directory: /var/lib/cassandra/commitlog</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li><strong>seeds处ip与逗号之间最好不要有空格；</strong></li>
<li><strong>listen_address和rpc_address要使用IP地址，不要使用hostname;</strong></li>
<li><strong>此处需要给用户jinzhongxu添加访问上面目录的权限，</strong>如下</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chown -R jinzhongxu /var/lib/cassandra/data</span><br><span class="line">sudo chown -R jinzhongxu /var/lib/cassandra/commitlog</span><br></pre></td></tr></table></figure>

<p>然后，将apache-cassandra-3.11.6拷贝到其他机器中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r apache-cassandra-3.11.6 1.1.1.1:/home/jinzhongxu/.</span><br></pre></td></tr></table></figure>

<p>并修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">listen_address: 1.1.1.1</span><br><span class="line">rpc_address: 1.1.1.1</span><br></pre></td></tr></table></figure>

<p>创建目录/var/lib/cassandra/data和/var/lib/cassandra/commitlog，并分配访问权限</p>
<p>其他机器1.1.1.2, 1.1.1.3, 1.1.1.4, 1.1.1.5, 同样执行，注意换成各自的ip</p>
<h1 id="启动Cassandra集群服务"><a href="#启动Cassandra集群服务" class="headerlink" title="启动Cassandra集群服务"></a>启动Cassandra集群服务</h1><p>注意，需要先启动种子节点上的服务，然后才能启动正常节点上的服务。</p>
<p>先在1.1.1.1上运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cassandra -f <span class="comment"># 前台启动，在终端上打印日志</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cassandra <span class="comment"># 后台启动，不在终端打印日志</span></span><br></pre></td></tr></table></figure>

<p>选择运行一种，建议第一种。</p>
<p>然后是1.1.1.2, 1.1.1.3</p>
<p>最后是1.1.1.4，1.1.1.5,  1.1.1.0</p>
<p>在机器1.1.1.1上运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nodetool status</span><br></pre></td></tr></table></figure>

<p>可以查看各节点运行情况是否正常</p>
<p>运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cqlsh 1.1.1.0 9042</span><br></pre></td></tr></table></figure>

<p>可以启动cql查询shell.</p>
<p><strong>如果不想带参数启动cqlsh，而是直接启动cqlsh</strong>，可以通过如下方式设置：</p>
<ol>
<li>把配置文件cqlshrc.sample拷贝到~/.cassandra目录下（如果没有该目录，说明没有运行过Cassandra命令，可以运行一次命令：nodetool status，之后就会自动产生该目录）</li>
<li>修改cqlshrc.sample为cqlshrc</li>
<li>修改配置，将hostname=127.0.0.1切换为1.1.1.0，其他服务器一样改成各自IP地址</li>
<li>重启Cassandra</li>
<li>直接输入cqlsh，即启动本机cql shell</li>
<li>输入cqlsh 1.1.1.1 9042 或 cqlsh 1.1.1.1，即远程连接服务器1.1.1.1的cql shell</li>
</ol>
<h1 id="关闭Cassandra"><a href="#关闭Cassandra" class="headerlink" title="关闭Cassandra"></a>关闭Cassandra</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -aux | grep cassandra</span><br></pre></td></tr></table></figure>

<p>kill 掉其相应的pid</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>cassandra</tag>
        <tag>big data</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos安装ffmpeg</title>
    <url>/2020/03/10/centos-ffmpeg/</url>
    <content><![CDATA[<p>Centos 安全稳定，但是，对于ffmpeg却没有通过yum install ffmpeg直接按照的支持。下面给出一种可行的安装方法：<strong>Static Prebuilt Install of FFMpeg.</strong> 这里以Centos 7为例。</p>
<a id="more"></a>

<h1 id="下载安装脚本"><a href="#下载安装脚本" class="headerlink" title="下载安装脚本"></a>下载安装脚本</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/q3aql/ffmpeg-install/master/ffmpeg-install</span><br></pre></td></tr></table></figure>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod  a+x ffmpeg-install &amp;&amp; ./ffmpeg-install --install release</span><br></pre></td></tr></table></figure>

<h1 id="查看ffmpeg版本信息"><a href="#查看ffmpeg版本信息" class="headerlink" title="查看ffmpeg版本信息"></a>查看ffmpeg版本信息</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -version</span><br></pre></td></tr></table></figure>

<h1 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h1><p>Centos 7 不能直接使用tar 解压缩 x.tar.bz2?</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install bzip2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos 修改时区</title>
    <url>/2020/04/02/centos-change-timezone/</url>
    <content><![CDATA[<p>Centos修改系统显示时间可以通过修改时区来做。常用的时区一般包含CST, UTC, GMT.</p>
<a id="more"></a>

<h1 id="时区介绍"><a href="#时区介绍" class="headerlink" title="时区介绍"></a>时区介绍</h1><p>CST：China Standard Time，即中国标准时间，又称北京时间。是我中国大陆的标准时间，比世界协调时快八小时（即UTC+8），与香港、澳门、台湾、马来西亚、新加坡等地的标准时间相同。</p>
<p>UTC：<strong>C</strong>oordinated <strong>U</strong>niversal <strong>T</strong>ime，即协调世界时。是最主要的世界时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林威治标准时间，UTC + 8小时 = CST。协调世界时是最接近格林威治标准时间（GMT）的几个替代时间系统之一。对于大多数用途来说，UTC时间被认为能与GMT时间互换，但GMT时间已不再被科学界所确定。</p>
<p>GMT：<strong>G</strong>reenwich <strong>M</strong>ean <strong>T</strong>ime，即格林威治平均时间。是指位于英国伦敦郊区的皇家格林威治天文台当地的平太阳时，因为本初子午线被定义为通过那里的经线。</p>
<h1 id="查看时区"><a href="#查看时区" class="headerlink" title="查看时区"></a>查看时区</h1><p>下面介绍如何修改系统时间，假设Centos系统采用UTC时区，可以通过如下命令查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure>

<h1 id="修改时区"><a href="#修改时区" class="headerlink" title="修改时区"></a>修改时区</h1><p>我们想要修改为北京时间，方法如下</p>
<h2 id="使用timedatectl"><a href="#使用timedatectl" class="headerlink" title="使用timedatectl"></a>使用timedatectl</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">timedatectl <span class="built_in">set</span>-timezone Asia/Shanghai</span><br></pre></td></tr></table></figure>

<h2 id="使用localtime"><a href="#使用localtime" class="headerlink" title="使用localtime"></a>使用localtime</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp  /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime</span><br></pre></td></tr></table></figure>

<h2 id="使用tzselect"><a href="#使用tzselect" class="headerlink" title="使用tzselect"></a>使用tzselect</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tzselect</span><br></pre></td></tr></table></figure>

<h1 id="修改时间"><a href="#修改时间" class="headerlink" title="修改时间"></a>修改时间</h1><p>如果，系统显示时间的分秒出现错误，可以使用如下命令修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">date -s <span class="string">&#x27;2020-04-02 12:20:30&#x27;</span></span><br></pre></td></tr></table></figure>

<p>也可以根据网络自动同步，如果可以联网，使用ntp同步标准时间，ntp：网络时间协议（network time protol）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install ntp</span><br><span class="line">ntpdate pool.ntp.org</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos安装htop和htop命令使用</title>
    <url>/2020/03/10/centos-htop/</url>
    <content><![CDATA[<p>Centos 是一个比较优秀的Linux发行版，在其上可以使用软件包管理工具yum进行软件命令的安装，但是，htop却不能直接使用命令yum install htop来安装，下面介绍如何安装htop，方面我们清楚的查看电脑的运行情况。</p>
<a id="more"></a>

<h1 id="首先，需要添加EPEL-repo"><a href="#首先，需要添加EPEL-repo" class="headerlink" title="首先，需要添加EPEL repo"></a>首先，需要添加EPEL repo</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum -y install epel-release</span><br></pre></td></tr></table></figure>

<h1 id="其次，安装htop"><a href="#其次，安装htop" class="headerlink" title="其次，安装htop"></a>其次，安装htop</h1><h2 id="搜索htop"><a href="#搜索htop" class="headerlink" title="搜索htop"></a>搜索htop</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum search htop</span><br></pre></td></tr></table></figure>

<h2 id="查看htop信息"><a href="#查看htop信息" class="headerlink" title="查看htop信息"></a>查看htop信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum info htop</span><br></pre></td></tr></table></figure>

<h2 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br><span class="line">sudo yum upgrade</span><br></pre></td></tr></table></figure>

<p>注意，在centos中，命令yum update 和yum upgrade有一些小区别：</p>
<p>yum upgrade 会强制删除过时的软件包，这可能是危险的，因为有可能你在使用该软件</p>
<p>yum update 不会删除而会保留它们，这使得yum update 更安全</p>
<h2 id="安装htop"><a href="#安装htop" class="headerlink" title="安装htop"></a>安装htop</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install htop</span><br></pre></td></tr></table></figure>

<h1 id="htop命令"><a href="#htop命令" class="headerlink" title="htop命令"></a>htop命令</h1><h2 id="以无颜色显示"><a href="#以无颜色显示" class="headerlink" title="以无颜色显示"></a>以无颜色显示</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">htop -C</span><br><span class="line">htop --no-color</span><br></pre></td></tr></table></figure>

<h2 id="以树型显示"><a href="#以树型显示" class="headerlink" title="以树型显示"></a>以树型显示</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">htop -t</span><br><span class="line">htop --tree</span><br></pre></td></tr></table></figure>

<h2 id="查看某个用户的信息"><a href="#查看某个用户的信息" class="headerlink" title="查看某个用户的信息"></a>查看某个用户的信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">htop -u jinzhongxu</span><br><span class="line">htop --user=jinzhongxu</span><br></pre></td></tr></table></figure>

<h2 id="查看某个进程的信息"><a href="#查看某个进程的信息" class="headerlink" title="查看某个进程的信息"></a>查看某个进程的信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">htop -p PID</span><br><span class="line">htop -p 2322, 3999</span><br></pre></td></tr></table></figure>

<h2 id="查看htop帮助信息"><a href="#查看htop帮助信息" class="headerlink" title="查看htop帮助信息"></a>查看htop帮助信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">htop --<span class="built_in">help</span></span><br><span class="line">man htop</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>htop</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 编译安装 gcc</title>
    <url>/2021/02/03/centos-install-gcc/</url>
    <content><![CDATA[<p>gcc 是 Linux 系统的核心模块，同时，它可以编译使用 C，C++ 等语言编写的源代码。但是，在某些系统上自带的 gcc 版本过低，导致一些软件无法正常安装和运行。本篇介绍在 CentOS 上如何编译安装最新版或者高版本的 gcc，默认在 root 用户下运行命令。</p>
<a id="more"></a>

<h1 id="下载最新版-gcc"><a href="#下载最新版-gcc" class="headerlink" title="下载最新版 gcc"></a>下载最新版 gcc</h1><p>下载 gcc 可以在下面的官方网址下载，里面有最新版的 gcc 源码</p>
<p><a href="http://ftp.gnu.org/gnu/gcc/">GCC官方网址</a></p>
<p>或者使用 Git 克隆最新版</p>
<p>git clone <a href="https://gcc.gnu.org/git/gcc.git">https://gcc.gnu.org/git/gcc.git</a></p>
<p>如果官网下载慢，可以采用如下的镜像网址</p>
<p><a href="https://mirrors.ustc.edu.cn//gnu/gcc/">中国科技大学镜像网址</a></p>
<p><a href="http://mirror.hust.edu.cn/gnu/gcc/">华中科技大学镜像网址</a></p>
<p><a href="http://mirrors.nju.edu.cn/gnu/gcc/">南京大学镜像网址</a></p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/gnu/gcc/">清华大学镜像网址</a></p>
<p>我这里下载的测试版本是 gcc-10.1.0，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -c http://ftp.gnu.org/gnu/gcc/gcc-10.1.0/gcc-10.1.0.tar.gz</span><br><span class="line"><span class="comment"># 或者下载到指定目录</span></span><br><span class="line">wget -c http://ftp.gnu.org/gnu/gcc/gcc-10.1.0/gcc-10.1.0.tar.gz -p /root/.</span><br><span class="line">tar -xzvf gcc-10.1.0.tar.gz</span><br></pre></td></tr></table></figure>

<h1 id="安装工具软件"><a href="#安装工具软件" class="headerlink" title="安装工具软件"></a>安装工具软件</h1><p>因为下载的是 gcc 源码，因此，需要先编译才能安装。所以，需要在 CentOS 上需要安装一下工具软件，方法如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install wget bzip2 gcc gcc-c++ glibc-headers</span><br></pre></td></tr></table></figure>

<h1 id="编译安装最新版-gcc"><a href="#编译安装最新版-gcc" class="headerlink" title="编译安装最新版 gcc"></a>编译安装最新版 gcc</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/gcc-10.1.0</span><br><span class="line"><span class="comment"># 下载依赖包</span></span><br><span class="line">./contrib/download_prerequisites</span><br><span class="line"><span class="comment"># 创建文件夹，存储编译中产生的临时文件</span></span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build/</span><br><span class="line"><span class="comment"># 配置编译</span></span><br><span class="line">../configure --prefix=/usr/<span class="built_in">local</span>/gcc-10.1.0 --<span class="built_in">enable</span>-bootstrap --<span class="built_in">enable</span>-checking=release --<span class="built_in">enable</span>-languages=c,c++ --<span class="built_in">disable</span>-multilib</span><br><span class="line"><span class="comment"># 进行编译，经测试花销3小时30分钟左右</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 安装，大约3-5分钟左右</span></span><br><span class="line">make install</span><br><span class="line"><span class="comment"># 配置为默认 gcc</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;\nexport PATH=/usr/local/gcc-10.1.0/bin:$PATH\n&#x27;</span> &gt;&gt; /etc/profile.d/gcc.sh &amp;&amp; <span class="built_in">source</span> /etc/profile.d/gcc.sh</span><br><span class="line">ln -sv /usr/<span class="built_in">local</span>/gcc-10.1.0/include/ /usr/include/gcc</span><br><span class="line"><span class="comment"># 配置生效</span></span><br><span class="line">ldconfig -v</span><br><span class="line"><span class="comment"># 导出验证</span></span><br><span class="line">ldconfig -p | grep gcc</span><br><span class="line"><span class="comment"># 查看 gcc 版本号</span></span><br><span class="line">gcc -v</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><p><a href="https://developer.aliyun.com/article/718551">CentOS 7.6 编译安装最新版本GCC 9.2.0 实录</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_42090356/article/details/90678158">Linux升级gcc到最新版本–gcc-9.1.0</a></p>
</li>
<li><p><a href="https://blog.csdn.net/21aspnet/article/details/105708122">安装最新的GCC</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>gcc</tag>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos远程SSH保持在线方法</title>
    <url>/2020/03/21/centos-ssh-client-alive/</url>
    <content><![CDATA[<p>Centos 安全可靠，但是远程通过SSH连接Centos服务器时，总是会出现过一段时间不用或隔夜第二天断开的情况，这是由于Centos的SSH服务配置项设置导致的，可以修改相应的配置项来保证Centos通过SSH连接时不自动断开。</p>
<a id="more"></a>

<h1 id="修改配置项"><a href="#修改配置项" class="headerlink" title="修改配置项"></a>修改配置项</h1><p>打开配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p>修改如下两项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ClientAliveInterval 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ClientAliveCountMax 3</span></span><br></pre></td></tr></table></figure>

<p>为如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ClientAliveInterval 60</span><br><span class="line">ClientAliveCountMax 3</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<p>&emsp; ClientAliveInterval 指定了服务器端向客户端请求消息的时间间隔，默认值为0，表示不发送。设置ClientAliveInterval = 60 表示每分钟发送一次，客户端进行相应，保持在线不断开。</p>
<p>&emsp; ClientAliveCountMax  表服务器发出请求后客户端没有响应的次数达到一定值就会自动断开。使用默认值3即可，因为正常情况下，不会不响应。</p>
<h1 id="重启SSH服务"><a href="#重启SSH服务" class="headerlink" title="重启SSH服务"></a>重启SSH服务</h1><p>重启SSH服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart sshd</span><br></pre></td></tr></table></figure>

<p>或者如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure>

<p>重启后，就使设置生效了。即正常情况下，远程SSH连接不会断开。</p>
<p>参考博文：</p>
<ol>
<li><a href="https://blog.csdn.net/libaineu2004/article/details/83857779">CentOS 7 SSH连接超时自动断开解决方案</a>.</li>
<li><a href="https://blog.csdn.net/moliyiran/article/details/54809090">CentOS下解决SSH自动断开办法</a>.</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos 安装 htop</title>
    <url>/2020/01/02/centos-install-htop/</url>
    <content><![CDATA[<p>htop 是一个非常优秀好用的命令来查看系统运行情况，在Ubuntu上可以非常简单的使用命令</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; apt install htop</span><br></pre></td></tr></table></figure>

<p>安装htop</p>
<p>但是，在Centos 7等上却不能简单的使用一条命令安装htop，下面给出完整的命令来在Centos 7上安装htop</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install epel-release -y</span><br><span class="line"></span><br><span class="line">sudo yum update -y</span><br><span class="line"></span><br><span class="line">sudo yum install htop -y</span><br></pre></td></tr></table></figure>

<p>到此，就正常安装了htop在Centos 7上，可以在终端运行 htop 命令来查看是否安装成功。</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH远程连接Centos出现cannot change locale (UTF-8)</title>
    <url>/2020/03/12/centos-utf8-ssh/</url>
    <content><![CDATA[<p>Centos是一个优秀的安全的linux发行版，但是，当我使用Mac终端SSH远程连接Centos服务器时却出现如下警告：</p>
<p>-bash: warning: setlocale: LC_CTYPE: cannot change locale (UTF-8): No such file or directory=</p>
<p>这里给出解决该问题的方法：</p>
<a id="more"></a>

<p>在Centos服务器上，进入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/environment</span><br></pre></td></tr></table></figure>

<p>添加如下代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LANG=en_US.utf-8</span><br><span class="line">LC_ALL=en_US.utf-8</span><br></pre></td></tr></table></figure>

<p>再次通过SSH连接时就不会出现上述警告了。</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome 添加扩展程序</title>
    <url>/2020/03/12/chrome-add-extension/</url>
    <content><![CDATA[<p>Chrome是一款非常优秀的浏览器，再配合上扩展程序或插件，可谓是如虎添翼。但是由于不能够直接登录谷歌扩展程序商店直接添加扩展程序，那么这里给出一个将已经下载或自己编写好的扩展程序添加到Chrome浏览器插件的一种方法。</p>
<a id="more"></a>

<blockquote>
<ol>
<li><p>将扩展程序的类型由 .crx 更改为 .zip，然后解压缩该文件到一个文件夹中 ；</p>
</li>
<li><p>打开谷歌扩展程序管理页，即 chrome://extensons ；</p>
</li>
<li><p>将右上角的开发者模式（Developer mode）打开 ；</p>
</li>
<li><p>点击左上角的上传解压缩文件（Load unpacked），选择刚刚解压缩的 zip 文件夹。</p>
</li>
</ol>
</blockquote>
<p>这样就将手动下载或自己编写的扩展程序添加为Chrome插件了。</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos 给用户增加sudo 权限</title>
    <url>/2020/01/02/centos-sudo-user/</url>
    <content><![CDATA[<p>当给 Centos 增加新用户时，想配置新用户具有sudo权限，可是跟ubuntu上不同，在Ubuntu上可以使用简单的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod -aG sudo jinzhongxu</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>来给用户jinzhongxu增加sudo权限。但是，在Centos上却行不通，提示 没有sudo组。那么在Centos上如何给用户增加sudo权限呢。经过查看 /etc/sudoers 文件，发现wheel组下面的用户都可以具有sudo 权限，因此，可以经新用户添加到wheel组，使其具有sudo 权限，具体命令(root权限)如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -aG wheel jinzhongxu</span><br></pre></td></tr></table></figure>

<p>在命令行输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure>

<p>可以发现，新用户jinzhongxu已经具有sudo权限了。</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 filebrowser 和 Nginx 在 VPS 搭建云盘</title>
    <url>/2020/11/19/cloud-by-filebrowser-and-nginx/</url>
    <content><![CDATA[<p>个人云盘能够方便存储个人文档，特别是没有上传下载速度限制，可以灵活扩展容量，具有更好的私密性。当具有远程服务器（如VPS）时，可以使用 <a href="https://filebrowser.org/">filebrowser</a> 搭建个人云盘。结合 <a href="https://nginx.org/en/linux_packages.html#Debian">Nginx</a> 实现个性化网页快速访问。下面分别介绍如何在远程服务器上安装 Nginx, filebrowser, 以及他们的配置。本篇以 Debian 10 为例，Ubuntu 系统类似， CentOS 系统需要切换相应命令，但一般是将 apt 更改为 yum.</p>
<a id="more"></a>

<h1 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure>

<h1 id="安装-filebrowser"><a href="#安装-filebrowser" class="headerlink" title="安装 filebrowser"></a>安装 filebrowser</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://filebrowser.org/get.sh | bash</span><br></pre></td></tr></table></figure>

<h1 id="配置-filebrowser"><a href="#配置-filebrowser" class="headerlink" title="配置 filebrowser"></a>配置 filebrowser</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建配置数据库</span></span><br><span class="line">filebrowser -d .filebrowser.db config init</span><br><span class="line"><span class="comment"># 设置监听地址</span></span><br><span class="line">filebrowser -d .filebrowser.db config <span class="built_in">set</span> --address 0.0.0.0</span><br><span class="line"><span class="comment"># 设置监听端口，需要打开端口 6666</span></span><br><span class="line">filebrowser -d .filebrowser.db config <span class="built_in">set</span> --port 6666</span><br><span class="line"><span class="comment"># 设置网址根路径</span></span><br><span class="line">filebrowser -d .filebrowser.db config <span class="built_in">set</span> --baseurl /cloud</span><br></pre></td></tr></table></figure>

<p>设置服务器自动启动命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/filebrowser.service</span><br><span class="line"><span class="comment"># 添加如下代码</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=filebrowser daemon</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=filebrowser -d /home/xiangyin/.filebrowser.db</span><br><span class="line">User=xiangyin</span><br><span class="line">Group=xiangyin</span><br><span class="line">WorkingDirectory=/home/xiangyin/files-path/</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">sudo systemctl status filebrowser.service</span><br><span class="line"><span class="comment"># 启动 filebrowser</span></span><br><span class="line">sudo systemctl restart filebrowser.service</span><br><span class="line"><span class="comment"># 设置开机自启</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> filebrowser.service</span><br><span class="line"><span class="comment"># 查看是否设置开机自启成功</span></span><br><span class="line">sudo systemctl list-unit-files| grep filebrowser</span><br><span class="line"><span class="comment"># 如果对service文件进行修改再次启动，请运行如下命令，重载服务</span></span><br><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<p>此时，已经可以访问网页：<a href="http://ip:6666/">http://ip:6666</a> 查看目录 /home/xiangyin/files-path/ 下的文件</p>
<h1 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/nginx/nginx.conf</span><br><span class="line"><span class="comment"># 在 server 下添加如下内容</span></span><br><span class="line">location /cloud &#123;</span><br><span class="line">            client_max_body_size 2048m;</span><br><span class="line">            proxy_read_timeout   86400s;</span><br><span class="line">            proxy_send_timeout   86400s;</span><br><span class="line">            proxy_set_header     X-Forwarded-Host <span class="variable">$host</span>;</span><br><span class="line">            proxy_set_header     X-Forwarded-Server <span class="variable">$host</span>;</span><br><span class="line">            proxy_set_header     X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            proxy_set_header     Host <span class="variable">$host</span>;</span><br><span class="line">            proxy_set_header     X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            proxy_http_version   1.1;</span><br><span class="line">            proxy_redirect       off;</span><br><span class="line">            proxy_set_header     Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">            proxy_set_header     Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">            proxy_pass           http://127.0.0.1:6666;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment"># 注意这里的 /cloud 需要同配置 filebrowser baseurl 一致</span></span><br></pre></td></tr></table></figure>

<p>如果申请了域名，可以如下设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.baigoo.com;</span><br><span class="line">        root /home/xiangyin/html;</span><br><span class="line">        index index.php index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 其中 www.baigoo.com 是域名，/home/xiangyin/html 是静态网页文件放置目录</span></span><br><span class="line"><span class="comment"># 注意，请打开 80、443 端口</span></span><br></pre></td></tr></table></figure>

<p>设置 nginx 服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl status nginx.service</span><br><span class="line">sudo systemctl restart nginx.service</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> nginx.service</span><br></pre></td></tr></table></figure>

<p>之后，就可以访问网址：<a href="http://www.baigoo.com/cloud">http://www.baigoo.com/cloud</a> 打开个人云盘了。注意，进入后设置强密码。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://filebrowser.org/">filebrowser.org</a></li>
<li><a href="https://nginx.org/en/">nginx.org</a></li>
<li><a href="https://blog.csdn.net/xujinzh/article/details/98040033">在服务器上搭建个人网盘</a></li>
<li><a href="https://diannaobos.com/post/828.html">使用filebrowser搭建私人云盘</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>cloud</tag>
        <tag>filebrowser</tag>
        <tag>nginx</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title>几个聚类算法</title>
    <url>/2020/11/21/clustering-methods/</url>
    <content><![CDATA[<p>本节介绍一些典型的聚类算法，如 K-Means, DBSCAN, 谱聚类，层次聚类，optics, birch 等。聚类就是对大量未知标注的数据，按照内在相似性将其划分为多个类别，是类别内的数据相似度较大而类别间的数据相似度较小。通过计算每个类的代表点可以获得整个数据集的少量代表点，从而获得整个数据集的结构、形状信息。聚类算法通常处理无标签的数据集，因此常使用相似度或距离来处理。有衡量两个点（向量）直接的距离的，有衡量两个子集合之间的距离的，也有衡量点到子集合之间距离的。</p>
<a id="more"></a>

<p>首先先给出一个图，来直观看一下各个聚类算法的效果图。</p>
<p><img src="https://scikit-learn.org/stable/_images/sphx_glr_plot_cluster_comparison_001.png"></p>
<p>数学上，什么是距离？非空集合 $X$ 上的度量为一个函数（称之为“距离函数”或简称为“距离”）<br>$$<br>d: X \times X \to \mathbb{R}<br>$$<br>这里的 $\mathbb{R}$ 是实数集合，且对于所有 $X$ 内的 $x, y, z$，均满足如下条件：</p>
<ul>
<li><p>非负性，或分离公理<br>$$<br>d(x, y) \geq 0<br>$$</p>
</li>
<li><p>同一性，或同时公理<br>$$<br>d(x,y) = 0 \Longleftrightarrow x = y<br>$$</p>
</li>
<li><p>对称性<br>$$<br>d(x, y) = d(y, x)<br>$$</p>
</li>
<li><p>次加性，或三角不等式<br>$$<br>d(x, z) \leq d(x, y) + d(y, z)<br>$$<br>其次，给出几种计算相似度或距离的方法。</p>
</li>
</ul>
<ol>
<li><p>闵可夫斯基（或叫明氏）距离（Minkowski，欧式空间中的一种距离，$p$-范数距离，$p$不一定要是整数，但不可以小于1，不然三角不等式不成立）<br>$$<br>d(\vec{x}, \vec{y}) = (\sum_{i=1}^n |x_i - y_i|^p)^{\frac{1}{p}}<br>$$<br>当 $p = 1$ 时，称为曼哈顿距离（Manhattan，1-范数距离），$p = 2$ 时，称为欧式（欧几里得）距离（Euclidean，2-范数距离），$p = +\infty$ 时称为切比雪夫距离（Chebyshev，无穷范数距离）。</p>
</li>
<li><p>杰卡德（Jaccard）相似系数<br>$$<br>J(A, B) = \frac{|A \cap B|}{|A \cup B|}<br>$$</p>
</li>
<li><p>余弦相似度（cosine similarity）<br>$$<br>cos(\theta) = \frac{\vec{x}^T \vec{y}}{|\vec{x}| \cdot |\vec{y}|}<br>$$</p>
</li>
<li><p>Pearson 相似系数<br>$$<br>\rho_{\vec{x}\vec{y}} = \frac{cov(\vec{x}, \vec{y})}{\sigma_{\vec{x}}\sigma_{\vec{y}}}  = \frac{E[(\vec{x} - \mu_{\vec{x}})(\vec{y} - \mu_{\vec{y}})]}{\sigma_{\vec{x}}\sigma_{\vec{y}}}<br>$$</p>
</li>
<li><p>相对熵（K-L散度，K-L距离）<br>$$<br>D(p | q) = \sum_{\vec{x}} p(\vec{x}) \log{\frac{p(\vec{x})}{q(\vec{x})}} = E_{p(\vec{x})} \log{\frac{p(\vec{x})}{q(\vec{x})}}<br>$$</p>
</li>
<li><p>Hellinger 距离<br>$$<br>D_{\alpha}(p | q) = \frac{2}{1-\alpha^2}(1 - \int p(x)^{\frac{1+\alpha}{2}} q(x)^{\frac{1-\alpha}{2}} \mathrm{d}x)<br>$$</p>
</li>
</ol>
<h1 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means"></a>K-Means</h1><p>k-means 算法是使用最多，且相对简单的聚类算法。</p>
<p>k-means 算法，也被称为 k-平均或k-均值，是一些聚类算法的基础，如谱聚类。</p>
<p>假设输入样本为 $S = x_1, x_2, \cdots, x_m$，则算法步骤为</p>
<ol>
<li><p>选择初始的 $k$ 个类别中心 $\mu_1, \mu_2, \cdots, \mu_k$</p>
</li>
<li><p>对于每个样本 $x_i$，将其标记为距离类别中心最近的类别，即<br>$$<br>label_i = \underset{1 \leq j \leq k}{\arg \min} | x_j - \mu_j |<br>$$</p>
</li>
<li><p>将每个类别中心更新为隶属该类别的所有样本的均值<br>$$<br>\mu_j = \frac{1}{|c_j|} \underset{i \in c_j}{\sum} x_i<br>$$</p>
</li>
<li><p>重复最后两步，直到类别中心的变化小于某阈值。或者迭代次数达到某阈值，或者最小平方误差MSE（Minimum Squared Error）小于某阈值。</p>
</li>
</ol>
<p>在算法中，如果不取均值，改为取中位数，称为 k-mediods 聚类（k中值聚类）。</p>
<p>初始值的选择对 k-means 算法影响很大，通过 k-means++ 可以有效的选择初始聚类中心。具体的，</p>
<ol>
<li>首先任意选择一个初始样本点 $\mu_1 = x_1$ 为第一个聚类中心</li>
<li>其次，计算剩余点 $y_1, y_2, \cdots, y_m$ 到聚类中心 $\mu_1$ 的聚类，假设为 $d_1, d_2, \cdots, d_m$，那么依概率 $\frac{d_1}{d}, \frac{d_2}{d}, \cdots, \frac{d_m}{d}$ 来选择样本点 $y_1, y_2, \cdots, y_m$ 中的一个作为第二个聚类中心 $\mu_2$，其中 $d = \sum_{i=1}^m d_i$</li>
<li>重复步骤2，直到选到所需的 $k$ 个聚类中心 $\mu_1, \mu_2, \cdots, \mu_k$</li>
<li>最后，使用 k-means 聚类算法在数据集 $x_1, x_2, \cdots, x_n$ 和  $k$ 个聚类中心 $\mu_1, \mu_2, \cdots, \mu_k$ 上进行迭代聚类</li>
</ol>
<p>关于簇数即聚类中心个数的选择，一种方法是遍历簇数取值 $1, 2, \cdots, n$，画图查看不同簇数取值下整个数据集 MSE 变化情况，即从数据集方差（当类簇数等于1）下降到0（当类簇数等于 $n$，即样本个数，每个样本聚成一个类），选择 MSE 变化的“肘关节点”；另一种方法是，当选择某个 $k$ 作为聚类中心树，进行 k-means 聚类，计算聚类后每个类簇的 MSE，对于取值较大 MSE 的类簇增加聚类中心个数，对于取值较小的，合并聚类中心。</p>
<p><font color='dd00dd'> k-means 深层解释 </font></p>
<p>假设样本集 ${ x_i }$  有 $k$ 个簇，每个簇样本数目为 $N_1, N_2, \cdots, N_k$，且每个簇都服从相同方差 $\sigma$ 的高斯分布，每个类簇的均值就是聚类中心 $\mu_i$，那么，k-means 聚类的最大似然函数是<br>$$<br>\Pi_{j=1}^k \Pi_{i=1}^{N_j} \frac{1}{\sqrt{2\pi}\sigma} \exp ^{-\frac{(x_i^{j} - \mu_j)}{2\sigma^2}}<br>$$<br>取对数后，只保留参数 $\mu_i$ 部分<br>$$<br>J(\mu_1, \mu_2, \cdots, \mu_k) = \frac{1}{2} \sum_{j=1}^k \sum_{i=1}^{N_j} (x_i^j - \mu_j)^2<br>$$<br>对函数 $J$ 关于参数变量 $\mu_1, \mu_2, \cdots, \mu_k$ 求偏导，得到<br>$$<br>\frac{\partial J}{\partial \mu_j} = - \sum_{i=1}^{N_j}(x_i^j - \mu_j) = 0 \Rightarrow \mu_j = \frac{1}{N_j} \sum_{i=1}^{N_j} x_i^j<br>$$<br>由此可以知道，k-means 运行的隐含假设是，每个类簇都服从高斯分布，且方差相同。即数据集服从方差相同的混合高斯分布。同时，该算法的目标函数是 MSE，且采用梯度下降算法进行迭代优化。因此，机器学习中非凸函数梯度下降算法的问题，该算法都会有，比如，初始点（初始聚类中心）的选择，局部最优问题，收敛震荡问题，鞍点问题等。同时，也提醒我们，可以使用 SGD 来求解 k-means（即 Mini-batch k-means 算法，不是把每个类的算有点个数 $N_j$ 都使用来计算均值，而是随机使用部分点 $N_j^{\prime} &lt; N_j$ 来计算均值），同样的，也可以采用 k-means++ 筛选初始点的方法来选择机器学习方法初始点。</p>
<p><font color='dd00dd'> k-means 聚类算法的优缺点 </font></p>
<p>优点：</p>
<ol>
<li>是解决聚类问题的一种经典算法，简单，快速</li>
<li>对处理大数据集，该算法保持可伸缩性和高效率</li>
<li>当簇近似分为高斯分布时，效果较好</li>
<li>可作为其他聚类方法的基础，如谱聚类</li>
</ol>
<p>缺点：</p>
<ol>
<li>在簇的平均值可被定义的情况下才能使用，可能不适应于某些应用</li>
<li>必须事先给出 $k$ 值（要生成的簇个数），而且对初值敏感，对于不同的初始值，可能会导致不同结果</li>
<li>不适合于发现非凸形状的簇或者大小差别很大的簇</li>
<li>对噪声和孤立点数据敏感</li>
</ol>
<p><strong>KMeans 算法的重要参数包括：n_clusters​.</strong></p>
<p>python 代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"></span><br><span class="line">X = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">10</span>, <span class="number">2</span>], [<span class="number">10</span>, <span class="number">4</span>], [<span class="number">10</span>, <span class="number">0</span>]])</span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">2</span>, random_state=<span class="number">0</span>).fit(X)</span><br><span class="line">kmeans.labels_</span><br><span class="line"><span class="comment"># 聚类结果如下</span></span><br><span class="line">array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], dtype=int32)</span><br><span class="line"></span><br><span class="line">kmeans.cluster_centers_</span><br><span class="line"><span class="comment"># 聚类中心</span></span><br><span class="line">array([[<span class="number">10.</span>,  <span class="number">2.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">2.</span>]])</span><br></pre></td></tr></table></figure>

<p>也可以直接返回聚类结果，不显示调用 clustering.labels_ </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">KMeans(n_clusters=<span class="number">2</span>, random_state=<span class="number">0</span>).fit_predict(X)</span><br><span class="line"><span class="comment"># 直接打印出来聚类结果</span></span><br><span class="line">array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], dtype=int32)</span><br></pre></td></tr></table></figure>

<p><strong>MiniBatchKMeans 算法的重要参数包括：n_clusters, batch_size​.</strong></p>
<p>MiniBatchKMeans 一般会比 KMeans 结果差，但是运行更快。</p>
<p>python 代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> MiniBatchKMeans</span><br><span class="line"></span><br><span class="line">X = np.array(</span><br><span class="line">    [</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">5</span>, <span class="number">5</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">-1</span>],</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">kmeans = MiniBatchKMeans(n_clusters=<span class="number">2</span>, random_state=<span class="number">0</span>, batch_size=<span class="number">6</span>, max_iter=<span class="number">10</span>).fit(X)</span><br><span class="line">kmeans.labels_</span><br><span class="line"><span class="comment"># 聚类结果如下</span></span><br><span class="line">array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], dtype=int32)</span><br><span class="line"></span><br><span class="line">kmeans.cluster_centers_</span><br><span class="line"><span class="comment"># 聚类中心</span></span><br><span class="line">array([[<span class="number">3.95918367</span>, <span class="number">2.40816327</span>],</span><br><span class="line">       [<span class="number">1.12195122</span>, <span class="number">1.3902439</span> ]])</span><br></pre></td></tr></table></figure>

<p>也可以直接返回聚类结果，不显示调用 clustering.labels_ </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MiniBatchKMeans(n_clusters=<span class="number">2</span>, random_state=<span class="number">0</span>, batch_size=<span class="number">6</span>, max_iter=<span class="number">10</span>).fit_predict(X)</span><br><span class="line"><span class="comment"># 直接打印出来聚类结果</span></span><br><span class="line">array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], dtype=int32)</span><br></pre></td></tr></table></figure>



<h1 id="DBSCAN"><a href="#DBSCAN" class="headerlink" title="DBSCAN"></a>DBSCAN</h1><p>DBSCAN（Density-Based Spatial Clustering of Applications with Noise）算法是一种基于密度的聚类算法。密度聚类方法的指导思想是，只要样本点的密度大于某阈值，则将该样本添加到最近的簇中。这类算法能克服基于距离的算法只能发现“类圆形”（凸）的聚类的缺点，可发现任意形状的聚类，且对噪声数据不敏感。但计算密度单元的计算复杂度大，需要建立空间索引来降低计算量。</p>
<p>DBSCAN 是一个比较有代表性的基于密度的聚类算法。与下面将要介绍的层次聚类方法不同，它将簇定义为密度相连的点的最大集合，能够把具有足够高密度的区域划分为簇，并可在有“噪声”的数据中发现任意形状的聚类。</p>
<p>介绍 DBSCAN 需要了解如下几个概念：</p>
<ol>
<li>对象的 $\varepsilon$-邻域：给定对象在半径 $\varepsilon$ 内的区域。</li>
<li>核心对象：对于给定的数目 $m$，如果一个对象的 $\varepsilon$-邻域至少包含 $m$ 个对象，则称该对象为核心对象。</li>
<li>直接密度可达：给定一个对象集合 $D$，如果 $p$ 是在 $q$ 的 $\varepsilon$-邻域内，而 $q$ 是一个核心对象，我们说对象 $p$ 从对象 $q$ 出发是直接密度可达的。 </li>
<li>密度可达：如果存在一个对象链 $p_1, p_2, \cdots, p_n, p_1 = q, p_n = p$，对 $p_i \in D, (i \leq i \leq n)$,  $p_{i+1}$ 是从 $p_i$ 关于 $\varepsilon$ 和 $m$ 直接密度可达的，则对象 $p$ 是从对象 $q$ 关于 $\varepsilon$ 和 $m$ 密度可达的。</li>
<li>密度相连：如果对象集合 $D$ 中存在一个对象 $o$，使得对象 $p$ 和 $q$ 是从 $o$ 关于 $\varepsilon$ 和 $m$ 密度可达的，那么对象 $p$ 和 $q$ 是关于 $\varepsilon$ 和 $m$ 密度相连的。</li>
<li>簇：一个基于密度的簇是最大的密度相连对象的集合。</li>
<li>噪声：不包含在任何簇中的对象称为噪声。</li>
</ol>
<p>DBSCAN 算法流程：</p>
<ol>
<li>如果一个点 $p$ 的 $\varepsilon$-邻域包含多于 $m$ 个对象，则创建一个 $p$ 作为核心对象的新簇；</li>
<li>寻找并合并核心对象直接密度可达的对象；</li>
<li>没有新点可以更新簇时，算法结束。</li>
</ol>
<p>从算法流程可以看出，每个簇至少包含一个核心对象。非核心对象可以是簇的一部分，构成了簇的边缘。包含过少对象的簇被认为是噪声。DBSCAN 不需要事先给定聚类个数。对于大数据集因为要计算密度，不太适用。</p>
<p>DBSCAN 优势：</p>
<ol>
<li>不需要指定簇的个数</li>
<li>可以发现任意形状的簇</li>
<li>擅长找到离群点（检测任务）</li>
<li>需要的参数较少</li>
</ol>
<p>DBSCAN 劣势：</p>
<ol>
<li>高纬数据处理比较困难（可以先降维）</li>
<li>参数难以选择（参数对结果的影响非常大）</li>
<li>scikit-learn 中效率很慢（使用数据消减策略）</li>
</ol>
<p><strong>DBSCAN 算法的重要参数包括：$\varepsilon$=eps, m=min_samples​.</strong></p>
<p>python 代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> DBSCAN</span><br><span class="line"></span><br><span class="line">X = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">8</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">8</span>], [<span class="number">25</span>, <span class="number">80</span>]])</span><br><span class="line">clustering = DBSCAN(eps=<span class="number">3</span>, min_samples=<span class="number">2</span>).fit(X)</span><br><span class="line">clustering.labels_</span><br><span class="line"><span class="comment"># 聚类结果如下</span></span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">1</span>, <span class="number">-1</span>])</span><br></pre></td></tr></table></figure>

<p>也可以直接返回聚类结果，不显示调用 clustering.labels_ </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DBSCAN(eps=<span class="number">3</span>, min_samples=<span class="number">2</span>).fit_predict(X)</span><br><span class="line"><span class="comment"># 直接打印出来聚类结果</span></span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">1</span>, <span class="number">-1</span>])</span><br></pre></td></tr></table></figure>



<h1 id="谱聚类"><a href="#谱聚类" class="headerlink" title="谱聚类"></a>谱聚类</h1><p>谱聚类通过计算矩阵的特征向量来实现。可以把谱聚类描述为 PCA + K-means.</p>
<p>谱聚类是一种基于图论的聚类方法，通过对样本数据的拉普拉斯矩阵的特征向量进行聚类，从而达到对样本数据聚类的目的。可以解决区域重叠问题。</p>
<p>谱分析的整体过程：</p>
<ol>
<li>给定一组数据 $x_1, x_2, \cdots, x_n$，记任意两个点之间的相似度（“距离” 的负函数）为 $s_{ij} = &lt;x_i, x_j&gt;$，形成相似度图：$G=(V, E)$. 如果 $x_i$ 和 $x_j$ 之间的相似度 $s_{ij}$ 大于一定的阈值，那么，两个点是连接的，权值记作 $s_{ij}$.</li>
<li>接下来，可以用相似度图来解决样本距离问题：找到图的一个划分，形成若干个组，使得不同组之间有较低的权值，组内有较高的权值。</li>
</ol>
<p><strong>谱聚类的流程：</strong></p>
<ol>
<li><p>计算任意两个样本之间的相似度，这里常采用高斯相似度 $w_{ij} = exp(-\frac{|x_i - x_j|^2}{2\sigma^2})$, 这里 $\sigma$ 是超参数；</p>
</li>
<li><p>构造相似度矩阵 $W = (w_{ij})$， 需要注意的是，主对角线元素本来是 $w_{ii} = 1$，这里替换成 0；</p>
</li>
<li><p>构造度矩阵 $D = diag(d_i)$，这里 $d_i = \sum_{i=1}^n w_{ij}$;</p>
</li>
<li><p>构造拉普拉斯矩阵 $L = D - W$，如二维的例子对应的拉普拉斯矩阵如下</p>
<p>$$D = \begin{bmatrix}<br>w_{12} + w_{13} &amp; 0 &amp; 0 \\<br>0 &amp; w_{21} + w_{23} &amp; 0 \\<br>0 &amp; 0 &amp; w_{31} + w_{32}<br>\end{bmatrix}$$  </p>
<p> $$W = \begin{bmatrix}<br>0 &amp; w_{12} &amp; w_{13} \\<br>w_{21} &amp; 0 &amp; w_{23} \\<br>w_{31} &amp; w_{32} &amp; 0<br>\end{bmatrix} $$ </p>
<p>$$L = \begin{bmatrix}<br> w_{12} + w_{13} &amp; -w_{12} &amp; -w_{13} \\<br> -w_{21} &amp; w_{21} + w_{23} &amp; -w_{23} \\<br> -w_{31} &amp; -w_{32} &amp; w_{31} + w_{32}<br> \end{bmatrix}$$</p>
</li>
</ol>
<ol start="5">
<li>求拉普拉斯矩阵的谱，即所有的特征向量，并从小到大进行排列，假设为 $\lambda_1, \lambda_2, \cdots, \lambda_k, \cdots, \lambda_n$, 其对应的特征向量分别为 $\mu_1, \mu_2, \cdots, \mu_k = (\mu_{ik})^T, \cdots, \mu_n$，其中，特征向量<br>$$<br>\begin{bmatrix}<br>\mu_{11} &amp; \mu_{12} &amp; \cdots &amp; \mu_{1k} &amp; \cdots &amp; \mu_{1n} \\<br>\mu_{21} &amp; \mu_{22} &amp; \cdots &amp; \mu_{2k} &amp; \cdots &amp; \mu_{2n} \\<br>\vdots   &amp; \vdots   &amp; \ddots &amp; \vdots   &amp; \ddots &amp; \vdots   \\<br>\mu_{n1} &amp; \mu_{n2} &amp; \cdots &amp; \mu_{nk} &amp; \cdots &amp; \mu_{nn}<br>\end{bmatrix}<br>$$</li>
</ol>
<p>   的每一行就是样本映射的特征。选取前 $k$ 列个特征向量（前 $k$ 小特征值对应的特征向量）作为主特征向量（类似 PCA），然后，对矩阵<br>   $$<br>   \begin{bmatrix}<br>   \mu_{11} &amp; \mu_{12} &amp; \cdots &amp; \mu_{1k} \\<br>   \mu_{21} &amp; \mu_{22} &amp; \cdots &amp; \mu_{2k} \\<br>   \vdots   &amp; \vdots   &amp; \ddots &amp; \vdots   \\<br>   \mu_{n1} &amp; \mu_{n2} &amp; \cdots &amp; \mu_{nk}<br>   \end{bmatrix}<br>   $$<br>   按行聚类，采用聚类方法 k-means，这样就得到了原始样本的谱聚类。</p>
<p><strong>证明，拉普拉斯矩阵 $L = D - W$ 是半正定矩阵。</strong></p>
<p>对任意非零向量 $f$<br>$$<br>f^T L f = f^T D f - f^T W f = \sum_{i=1}^n d_i f_i^2 - \sum_{i,j=1}^n f_i f_j w_{ij} \\<br>= \frac{1}{2} (\sum_{i=1}^n d_i f_i^2 - 2 \sum_{i,j=1}^n f_i f_j w_{ij} + \sum_{j=1}^n d_j f_j^2) \\<br>= \frac{1}{2} \sum_{i,j=1}^n w_{ij}(f_i - f_j)^2 \geq 0.<br>$$<br>$L$ 是对称半正定矩阵，最小特征值是0， 相应的特征向量是全1向量。其他特征值大于零。</p>
<p>它适用于少数群集，但不建议用于许多群集。</p>
<p><font color='dd0000'>谱聚类算法：未正则拉普拉斯矩阵</font></p>
<p>输入：$n$ 个点 ${x_i}_{i=1, 2, \cdots, n}$，簇的数目 $k$</p>
<ul>
<li>计算 $n \times n$ 的相似度矩阵 $W$ 和度矩阵 $D$</li>
<li>计算拉普拉斯矩阵 $L = D - W$</li>
<li>计算 $L$ 的前 $k$ 个特征向量 $\mu_1, \mu_2, \cdots, \mu_k$</li>
<li>将 $k$ 个列向量 $\mu_1, \mu_2, \cdots, \mu_k$ 组成矩阵 $U \in \mathbb{R}^{n \times k}$</li>
<li>对于 $i = 1, 2, \cdots, n$， 令 $y_i \in \mathbb{R}^k$ 是 $U$ 的第 $i$ 行的向量</li>
<li>使用 <strong>k-means</strong> 算法将点 ${y_i}_{i=1, 2, \cdots, n}$ 聚类成簇 $C_1, C_2, \cdots, C_k$</li>
<li>输出簇 $A_1, A_2, \cdots, A_k$，其中，$A_i = {j|y_j \in C_i}$</li>
</ul>
<p><font color='dd0000'>谱聚类算法：随机游走拉普拉斯矩阵</font></p>
<p>输入：$n$ 个点 ${x_i}_{i=1, 2, \cdots, n}$，簇的数目 $k$</p>
<ul>
<li>计算 $n \times n$ 的相似度矩阵 $W$ 和度矩阵 $D$</li>
<li><font color='dd00dd'>计算拉普拉斯矩阵 $L_{rw} = D^{-1}(D - W)$</font></li>
<li>计算 $L$ 的前 $k$ 个特征向量 $\mu_1, \mu_2, \cdots, \mu_k$</li>
<li>将 $k$ 个列向量 $\mu_1, \mu_2, \cdots, \mu_k$ 组成矩阵 $U \in \mathbb{R}^{n \times k}$</li>
<li>对于 $i = 1, 2, \cdots, n$， 令 $y_i \in \mathbb{R}^k$ 是 $U$ 的第 $i$ 行的向量</li>
<li>使用 <strong>k-means</strong> 算法将点 ${y_i}_{i=1, 2, \cdots, n}$ 聚类成簇 $C_1, C_2, \cdots, C_k$</li>
<li>输出簇 $A_1, A_2, \cdots, A_k$，其中，$A_i = {j|y_j \in C_i}$</li>
</ul>
<p><font color='dd0000'>谱聚类算法：对称拉普拉斯矩阵</font></p>
<p>输入：$n$ 个点 ${x_i}_{i=1, 2, \cdots, n}$，簇的数目 $k$</p>
<ul>
<li>计算 $n \times n$ 的相似度矩阵 $W$ 和度矩阵 $D$</li>
<li><font color='dd00dd'>计算拉普拉斯矩阵 $L_{sym} = D^{-1/2}(D - W)D^{-1/2}$</font></li>
<li>计算 $L$ 的前 $k$ 个特征向量 $\mu_1, \mu_2, \cdots, \mu_k$</li>
<li>将 $k$ 个列向量 $\mu_1, \mu_2, \cdots, \mu_k$ 组成矩阵 $U \in \mathbb{R}^{n \times k}$</li>
<li>对于 $i = 1, 2, \cdots, n$， 令 $y_i \in \mathbb{R}^k$ 是 $U$ 的第 $i$ 行的向量</li>
<li><font color='dd00dd'>对于 $i=1,2,\cdots, n$，将$y_i \in \mathbb{R}^k $ 依次单位化，使得 $|y_i| = 1$ </font></li>
<li>使用 <strong>k-means</strong> 算法将点 ${y_i}_{i=1, 2, \cdots, n}$ 聚类成簇 $C_1, C_2, \cdots, C_k$</li>
<li>输出簇 $A_1, A_2, \cdots, A_k$，其中，$A_i = {j|y_j \in C_i}$</li>
</ul>
<p><strong>有时候，也会使用拉普拉斯矩阵 $L = W - D$，或者 $L = D^{-1}W$ (因为 $L = D^{-1}(D-W) = I - D^{-1}W$，不考虑单位矩阵效果一样)，此时，需要对特征值进行从大到小排列，选取相应的特征向量。</strong></p>
<p><em>当未给定先验知识的情况下，优先选择随机游走拉普拉斯矩阵。对于 $n$ 个样本，通过相似度构建一个相似度连通图，共有 $n(n+1)/2$ 条边，边上的权重就是两个样本之间的相似度。那么谱聚类的目标函数就是使用剪刀剪断一个边使得损失值最小（即特征值）。</em></p>
<p>随机游走和拉普拉斯矩阵的关系（当拉普拉斯矩阵 $L = D^{-1}W$ 时）</p>
<p>图论中的随机游走是一个随机过程，它从一个顶点跳转到另外一个顶点。谱聚类即找到图的一个划分，使得随机游走在相同的簇中停留而几乎不会游走到其他簇。转移矩阵是 $P=D^{-1}W$，表示从顶点 $v_i$ 跳转到顶点 $v_j$ 的概率正比于边的权值，即 $p_{ij} = w_{ij}/d_i$.</p>
<p>进一步的，可以考虑：</p>
<ul>
<li>谱聚类中的 $k$ 如何确定？$k^{\star} = \arg \max_k |\lambda_{k+1} - \lambda_k|$</li>
<li>最后一步的 $k-means$ 的作用是什么？目标函数是关于子图划分指示向量的函数，该向量的值根据子图划分确定，是离散的。该问题是 NP 的，转化成求连续实数域上的解，最后用 $k-means$ 算法离散化</li>
<li>未正则、对称、随机游走拉普拉斯矩阵，首先哪个？随机游走拉普拉斯矩阵</li>
<li>谱聚类可以用切割图，随机游走，扰动论等解释</li>
</ul>
<p><strong>谱聚类算法的重要参数包括：n_clusters, assign_labels, eigen_solver​.</strong></p>
<p>这里 n_cluster 表示聚类个数，也表示投影子空间的维数。eigen_solver 表示矩阵分解求特征值的策略，可选取值有 $None, arpack, lobpcg, or\ amg$, 其中， $amg$ 需要安装 $pyamg$ 才能运行，该分解策略能够有效提高大数据集、稀疏问题的计算速度，但可能会导致结果的不稳定。assign_labels​ 用于在嵌入空间中分配标签的策略。拉普拉斯嵌入后，有两种分配标签的方法。可以应用 <strong>kmeans</strong>，它是一种流行的选择。但是它也可能对初始化敏感。<strong>discretize</strong> 是另一种对随机初始化不太敏感的方法。</p>
<p>python 代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> SpectralClustering</span><br><span class="line"></span><br><span class="line">X = np.array([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">4</span>, <span class="number">7</span>], [<span class="number">3</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">6</span>]])</span><br><span class="line">clustering = SpectralClustering(</span><br><span class="line">    n_clusters=<span class="number">2</span>, assign_labels=<span class="string">&quot;discretize&quot;</span>, random_state=<span class="number">0</span></span><br><span class="line">).fit(X)</span><br><span class="line">clustering.labels_</span><br><span class="line"><span class="comment"># 聚类结果如下</span></span><br><span class="line">array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>也可以直接返回聚类结果，不显示调用 clustering.labels_ </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SpectralClustering(</span><br><span class="line">    n_clusters=<span class="number">2</span>, assign_labels=<span class="string">&quot;discretize&quot;</span>, random_state=<span class="number">0</span></span><br><span class="line">).fit_predict(X)</span><br><span class="line"><span class="comment"># 直接打印出来聚类结果</span></span><br><span class="line">array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure>



<h1 id="层次聚类"><a href="#层次聚类" class="headerlink" title="层次聚类"></a>层次聚类</h1><p>层次聚类（Hierarchical clustering）方法对给定的数据集进行层次分解，直到满足某种条件为止。具体地，可分为凝聚式层次聚类和分裂式层次聚类。</p>
<h2 id="凝聚式层次聚类"><a href="#凝聚式层次聚类" class="headerlink" title="凝聚式层次聚类"></a>凝聚式层次聚类</h2><p>凝聚式层次聚类又叫作 AGNES 算法。该算法属于层次聚类常采用的算法。相对于下面分裂式层次聚类，该算法复杂度更小。</p>
<p>scikit-learn 中实现的层次聚类算法 <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering">AgglomerativeClustering</a>, 使用自底向上执行层次聚类。每个样本都从自己聚类开始，并且聚类被连续合并在一起。合并或链接的标准成为算法的关键点。实现的合并策略的链接标准有 Ward （最小化所有类平方差和，一种方差最小化方法，某种意义上与k -means相似）、Maximum or complete linkage（最小化两对类簇的最大距离）、Average linkage（最小化两对类簇所有观测样本的距离平均值）、Single linkage（最小化两对类簇之间的最小观测样本距离）。不同策略得到的层次聚类效果图如下：</p>
<p><img src="https://scikit-learn.org/stable/_images/sphx_glr_plot_linkage_comparison_001.png"></p>
<ol>
<li>最小距离<ul>
<li>两个集合中最近的两个样本的聚类，single</li>
<li>容易形成链状结构</li>
</ul>
</li>
<li>最大距离<ul>
<li>两个集合中最远的两个样本的距离，maximum or complete</li>
<li>若存在异常值则不稳定</li>
</ul>
</li>
<li>平均距离<ul>
<li>两个集合中样本间两两距离的平均值，average</li>
<li>两个集合中样本间两两距离的平方和，ward</li>
</ul>
</li>
</ol>
<p>注意，Agglomerative 聚类具有一种 “富人更富有” 的行为，这将导致聚类大小不均匀。在这方面，single linkage 策略是最糟糕的，ward 能够给出最公正的大小。但是，ward 无法更改相似性（或者距离），因此对于非欧度量，average linkage 是一个更好的选择。single linkage 虽然对噪声敏感，但是计算效率高，能够推广到大数据集上。同时，在非球形数据上表现良好。</p>
<p>层次聚类能够给出数据结构的可视化信息，如类似下面的树状图：</p>
<p><img src="https://scikit-learn.org/stable/_images/sphx_glr_plot_agglomerative_dendrogram_001.png"></p>
<p>当与连接矩阵一起使用时，AgglomerativeClustering 也可以扩展到大量样本，但是当在样本之间不添加连接限制时，计算开销很大，因为它在每一步都考虑了所有可能的合并。</p>
<p>AgglomerativeClustering 有趣的方面是，可以通过一个连通性矩阵将连通性约束添加到该算法中（只能将相邻的聚类合并在一起），该矩阵为每个样本定义遵循给定数据结构的相邻样本。例如，在下面的瑞士卷示例中，连接性约束禁止合并瑞士卷上不相邻的点，因此避免形成在卷的重叠折叠部分延伸的簇。</p>
<p><img src="https://scikit-learn.org/stable/_images/sphx_glr_plot_ward_structured_vs_unstructured_001.png"></p>
<p><img src="https://scikit-learn.org/stable/_images/sphx_glr_plot_ward_structured_vs_unstructured_002.png"></p>
<p>这些约束对于强加特定的局部结构很有用，同时它们也使算法更快，尤其是在样本数量很多时。</p>
<p><strong>层次聚类（这里指 Agglomerative Clustering）的重要参数：n_clusters, linkage.</strong></p>
<p>python 代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> AgglomerativeClustering</span><br><span class="line"></span><br><span class="line">X = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">4</span>, <span class="number">2</span>], [<span class="number">4</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">0</span>]])</span><br><span class="line">clustering = AgglomerativeClustering(n_clusters=<span class="number">2</span>, linkage=<span class="string">&#x27;ward&#x27;</span>).fit(X)</span><br><span class="line">clustering.labels_</span><br><span class="line"><span class="comment"># 运行结果如下</span></span><br><span class="line">array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接返回聚类结果，不需要调用 clustering.labels_</span></span><br><span class="line">AgglomerativeClustering(n_clusters=<span class="number">2</span>, linkage=<span class="string">&#x27;ward&#x27;</span>).fit_predict(X)</span><br><span class="line"><span class="comment">#运行结果如下</span></span><br><span class="line">array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h2 id="分裂式层次聚类"><a href="#分裂式层次聚类" class="headerlink" title="分裂式层次聚类"></a>分裂式层次聚类</h2><p>分裂式层次聚类是 DIANA 算法。采用自顶向下的策略，它首先将所有对象置于一个簇中，然后逐渐细分为越来越小的簇，直到达到了某个终结条件。</p>
<h1 id="Birch"><a href="#Birch" class="headerlink" title="Birch"></a>Birch</h1><p>Birch 算法叫做平衡迭代削剪聚类算法，它是对层次聚类算法的一种优化，能够处理大数据集。</p>
<p>Birch 使用三元组的聚类特征表示类簇。通过构建满足分支因子和簇直径限制的聚类特征树（Clustering Feature Tree，CFT）来求聚类，数据本质上是有损压缩到一组“群集特征”节点（CF节点）的。聚类特征树其实是一个具有两个参数<font color='dd0000'>分支因子</font>和<font color='dd0000'>类直径</font>的高度平衡树。分支因子规定了树的每个节点的子女的最多个数，而类直径体现了对这一类点的距离范围。非叶子节点为它的子女的最大特征值。聚类特征树的构建是一个动态过程，可以随时根据数据对模型进行更新操作。</p>
<p>假设一个类簇包含的样本点集合为 ${x_1, x_2, \cdots, x_n}$ ，三元组存储的信息分别是 $(n, s_1, s_2)$，其中 $n$ 表示样本点个数，$s_1 = x_1 + x_2 + \cdots + x_n$，$s_2 = x_1 \cdot x_1 + x_2 \cdot x_2 + \cdots + x_n \cdot x_n$. 根据这个三元组信息，类直径和分支因子可以做如下事情。</p>
<p>类直径：判断样本是否属于当前簇</p>
<p>分支因子：当一个节点的子节点数目超过分支因子的时候，将该节点划分为两个子节点。当一个叶子节点的样本数目超过分支因子的时候，将叶子节点分成两个叶子节点。</p>
<p>优点：</p>
<ol>
<li>适合大规模数据集，线性效率</li>
<li>节约内存，所有样本都在磁盘上，CFT 仅仅存储 CF 节点和对应的指针</li>
<li>可以识别噪声。还可以对数据集进行初步预处理，作为其他聚类算法的输入，如层次聚类</li>
</ol>
<p>缺点：</p>
<ol>
<li>只适合分布呈凸形或者球形的数据集，需要给定聚类个数和簇之间的相关参数</li>
<li>无法很好地缩放到高维数据。根据经验，如果特征维度大于20，通常最好使用 MiniBatchKMeans</li>
<li>由于 CFT 对每个节点的 CF 个数有限制，导致聚类结果可能和真实类别分布不同</li>
</ol>
<p><strong>Birch 算法的重要参数：threshold, branching_factor, n_clusters.</strong></p>
<p>python 代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> Birch</span><br><span class="line"></span><br><span class="line">X = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0.3</span>, <span class="number">1</span>], [<span class="number">-0.3</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">-1</span>], [<span class="number">0.3</span>, <span class="number">-1</span>], [<span class="number">-0.3</span>, <span class="number">-1</span>]]</span><br><span class="line">brc = Birch(n_clusters=<span class="literal">None</span>)</span><br><span class="line">brc.fit(X)</span><br><span class="line">brc.labels_</span><br><span class="line"><span class="comment"># 运行结果如下</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接返回聚类结果，不需要调用 clustering.labels_</span></span><br><span class="line">brc.fit_predict(X)</span><br><span class="line"><span class="comment">#运行结果如下</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>参考链接</p>
<ol>
<li><a href="https://www.cnblogs.com/pinard/p/6179132.html">BIRCH聚类算法原理</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/54837341">数据挖掘入门笔记——BIRCH聚类（一拍即合）</a></li>
</ol>
<h1 id="OPTICS"><a href="#OPTICS" class="headerlink" title="OPTICS"></a>OPTICS</h1><p>OPTICS(Ordering Points To Identify the Clustering Structure)聚类算法是前面 DBSCAN 算法的一种扩展，能够解决 DBSCAN 对超参数敏感（不易选择超参数）的问题。与 DBSCAN 相比，OPTICS 算法的改进主要在于对输入参数不敏感。</p>
<p>OPTICS 算法不显示地生成数据聚类，它只是对数据对象集合中的对象进行排序，得到一个有序的对象列表，其中包含了足够的信息用来提取聚类。</p>
<p>因为 OPTICS 算法是 DBSCAN 算法发发的改进，因此很多概念可以沿用，如（直接）密度可达，密度相连，核心点，半径参数 $\varepsilon$，最小点数 $M$ 等。假设数据集 $X = {x_1, x_2, \cdots, x_n }$，</p>
<p><font color='dd00dd'>核心距离（core distance）</font></p>
<p>点$x \in X$ 成为核心点的最小邻域半径定义为 $x$ 的核心距离，<br>$$<br>cd(x) =<br>\begin{cases}<br>undefined， &amp; |N_{\varepsilon}(x)|&lt; M \\<br>d(x, y(N_{\varepsilon}^M, x)) &amp; |N_{\varepsilon}(x)| \geq M<br>\end{cases}<br>$$<br>其中 $y(N_{\varepsilon}^i, x)$ 表示集合 $N_{\varepsilon}(x)$ 中与点 $x$ 第 $i$ 近邻的点。</p>
<p>从定义可以知道，如果 $x$ 是核心点，那么核心距离 $0 \leq cd(x) \leq \varepsilon$.</p>
<p><font color='dd00dd'>可达距离（reachability distance）</font></p>
<p>对于点 $x, y \in X$，$y$ 关于 $x$ 的可达距离定义为<br>$$<br>rd(y, x) =<br>\begin{cases}<br>undefined, &amp; |N_{\varepsilon}(x)| &lt; M \\<br>\max { cd(x), d(x, y) } &amp; |N_{\varepsilon}(x)| \geq M<br>\end{cases}<br>$$<br>即 $rd(y, x)$ 表示使得 $x$ 为核心点且 $y$ 从 $x$ 直接密度可达同时成立的最小邻域半径。</p>
<p>通俗理解就是，对于核心点 $x$ ，与点 $x$ 距离小于等于核心距离的可达距离调整为核心距离，大于核心距离的可达距离就是两点之间的距离。</p>
<p>可达距离 $rd(y, x)$ 的值与点 $y$ 所在空间的密度有关，密度越大，它从相邻节点直接密度可达的距离就越小。如果聚类时想要朝着数据尽量稠密的空间进行扩展，那么可达距离最小的点是最佳的选择。为此，OPTICS 算法中用一个可达距离<strong>升序排列</strong>的有序种子队列存储带扩展的点，以迅速定位稠密空间的数据对象。</p>
<p>在给出 OPTICS 算法之前，先引入以下定义</p>
<ol>
<li>$p_i, i = 1, 2, \cdots, N$：OPTICS 算法的输出序数组，$p_i \in { 1, 2, \cdots, N }$ 表示排在第 $i$ 个位置的节点的编号</li>
<li>$r_i, i = 1, 2, \cdots, N$：第 $i$ 号节点的可达距离</li>
<li>$c_i, i = 1, 2, \cdots, N$：第 $i$ 号节点的核心距离</li>
<li>$v_i, i = 1, 2, \cdots, N$：表示节点便函是否被访问过的辅助数组，$0$ 表示未访问过，$1$ 表示访问过。这里是否被访问过是指是否被加入到输出序数组 $p$ 中</li>
</ol>
<p>OPTICS 算法：</p>
<ul>
<li><p>初始化</p>
<ol>
<li>给定参数 $\varepsilon, M$</li>
<li>生成 $N_{\varepsilon}(i), i = 1, 2, \cdots, N$</li>
<li>生成 $c_i, i = 1, 2, \cdots, N$</li>
<li>令 $v_i = 0, i = 1, 2, \cdots, N$</li>
<li>令 $r_i = undefined, i = 1, 2, \cdots, N$</li>
<li>令 $k = 1, I = { 1, 2, \cdots, N }$</li>
<li>将队列 seedlist 初始化为空</li>
</ol>
</li>
<li><p>主流程</p>
<p>while ($I \neq 0$)</p>
<p>{</p>
<p>​    从 $I$ 中任取一个元素 $i$，令 $I:= I \ { i }$</p>
<p>​    if ($v_i = 0$)  # 表示 $i$ 号节点还没有被处理过</p>
<p>​    {</p>
<p>​        （1）令 $v_i = 1$</p>
<p>​        （2）令 $p_k = i, k = k + 1$</p>
<p>​        （3）若 $|N_{\varepsilon}(i)| \geq M$ (即 $i$ 为核心点)，则</p>
<p>​            （3.1）调用 insertlist($N_{\varepsilon}(i), {v_i}_{i=1}^N, {r_i}_{i=1}^N, c_i$, seedlist)，将 $N_{\varepsilon}(i)$ 中未被访问过的节点按照可达距离插入到队列 seedlist 中。（初始化 seedlist）</p>
<p>​            （3.2）while (seedlist not empty)</p>
<p>​                        {</p>
<p>​                            （a）从 seedlist 中取出<strong>第一个元素</strong> $j$ （其可达距离值最小）</p>
<p>​                            （b）令 $v_j = 1$</p>
<p>​                            （c）令 $p_k = j, k = k + 1$</p>
<p>​                            （d）若 $|N_{\varepsilon}(j)| \geq M$ （即 $j$ 为核心点），则调用 insertlist($N_{\varepsilon}(j), {v_l}_{l=1}^N, {r_l}_{l=1}^N, c_j$, seedlist)，将 $N_{\varepsilon}(j)$ 中未被访问过的节点按照可达距离插入到队列 seedlist 中</p>
<p>​                        }</p>
<p>​    }</p>
</li>
</ul>
<p>  }</p>
<ul>
<li><p>insertlist($N_{\varepsilon}(j), {v_l}_{l=1}^N, {r_l}_{l=1}^N, c_j$, seedlist) 模块的算法</p>
<p>for all $J \in N_{\varepsilon}(K)$ do</p>
<p>​    if ($v_J = 0$)</p>
<p>​        $rd = \max { cd_K, d(x_K, x_J)}$</p>
<p>​        if ($r_J = undefined$)</p>
<ol>
<li><p>令 $r_j = rd$</p>
</li>
<li><p>将节点 $J$ 按照可达距离值插入到队列 seedlist 的适当位置</p>
<p>else</p>
<p>if ($rd &lt; r_J$)</p>
<ol>
<li>令 $r_J = rd$</li>
<li>将节点 $J$ 按照可达距离值插入到队列 seedlist 的适当位置</li>
</ol>
</li>
</ol>
</li>
<li><p>得到数据 ${ p_i }_{i=1}^N, { c_i }_{i=1}^N, { r_i }_{i=1}^N$ 后，就可以利用它们进行聚类。此时还需要一个邻域半径参数 $\lambda \leq \varepsilon$</p>
</li>
<li><p>与 DBSCAN 类似，引入 cluster 标记数组<br>$$<br>m_i =<br>\begin{cases}<br>j(&gt;0), &amp;  x_i 属于第 j 个 cluster \\<br>-1, &amp; x_i 为噪声<br>\end{cases}<br>$$<br>所以，要得到一个聚类，只需要生成标记数组 ${ m_i }_{i=1}^N$ 即可</p>
</li>
<li><p>生成标记数组（ OPTICS Cluster extracting）</p>
<p>clusterID = -1</p>
<p>$k = 1$</p>
<p>for $i = 1, 2, \cdots, N$, do</p>
<p>​    $j = p_i$</p>
<p>​    if ($r_j &gt; \lambda$ or $r_j = undefined$)</p>
<p>​        if ($c_j \neq undefinde$ and $c_j \leq \lambda$)</p>
<p>​            clusterID = $k$</p>
<p>​            $k = k + 1$</p>
<p>​            $m_j = $ clusterID</p>
<p>​        else</p>
<p>​            $m_j = -1$</p>
<p>else</p>
<p>​    $m_j = $ clusterID</p>
</li>
</ul>
<p><strong>OPTICS 算法的重要参数：min_samples.</strong></p>
<p>python 代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> OPTICS</span><br><span class="line"></span><br><span class="line">X = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">6</span>], [<span class="number">8</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">8</span>], [<span class="number">7</span>, <span class="number">3</span>]])</span><br><span class="line">clustering = OPTICS(min_samples=<span class="number">2</span>).fit(X)</span><br><span class="line">clustering.labels_</span><br><span class="line"><span class="comment"># 运行结果如下</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接返回聚类结果，不需要调用 clustering.labels_</span></span><br><span class="line">OPTICS(min_samples=<span class="number">2</span>).fit_predict(X)</span><br><span class="line"><span class="comment">#运行结果如下</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>参考链接</p>
<ol>
<li><a href="https://blog.csdn.net/itplus/article/details/10089323">聚类算法初探（六）OPTICS</a></li>
<li><a href="https://www.biaodianfu.com/optics.html">密度聚类算法之OPTICS</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/41930932">OPTICS聚类算法</a></li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://scikit-learn.org/stable/modules/clustering.html">Scikit-learn Clustering</a></li>
</ol>
]]></content>
      <categories>
        <category>research</category>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>clustering</tag>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>目标跟踪算法的分类</title>
    <url>/2020/08/24/classification-of-object-tracking/</url>
    <content><![CDATA[<p>目标跟踪算法按照不同的分类方法可以分为很多类别，如按提取的特征分类、特征提取方法分类、最优候选框匹配模型分类等。研究者大多是按照最优候选框匹配模型分类，这里也按此给出目标跟踪的算法分类。</p>
<p>按此方法，可以分为生成式算法和判别式算法。前者较老、后者较优。</p>
<a id="more"></a>

<h1 id="生成式算法"><a href="#生成式算法" class="headerlink" title="生成式算法"></a>生成式算法</h1><p>核心思想是衡量前一帧的矩形框与后续帧的相似度，选择最相似的候选框作为跟踪结果。常按照相似性度量的选择细分为三类：空间距离、概率分布距离、综合方法。</p>
<h2 id="空间距离"><a href="#空间距离" class="headerlink" title="空间距离"></a>空间距离</h2><p>利用最优化理论将跟踪问题转化为空间距离最小化问题。如 IVT(Incremental Learning for Visual Tracking) 和 ASLS(Visual tracking via adaptive structural local sparse appearance model). 其算法的核心思想是：计算当前帧候选框的像素灰度值与上一帧预测目标的像素灰度值之间的Euclidean distance，然后取距离最小的候选框作为当前帧的预测目标。在特征提取时应用了奇异值分解等技术来减小计算复杂度。</p>
<h2 id="概率分布距离"><a href="#概率分布距离" class="headerlink" title="概率分布距离"></a>概率分布距离</h2><p>利用最优化理论将跟踪问题转换成概率分布距离最小化问题。如 CBP (Color-Based Probabilistic) 和 FRAG (robust FRAGments-based) 。其算法的核心思想是：计算当前帧候选框的颜色直方图分布与上一帧预测目标的颜色直方图分布之间的 Bhattacharyya distance，然后取距离最小的候选框作为当前帧的预测目标。</p>
<h2 id="综合方法"><a href="#综合方法" class="headerlink" title="综合方法"></a>综合方法</h2><p>隐式的计算连个矩形框的距离。如 Mean Shift 算法和 Cam Shift 算法。借鉴了机器学习中 mean shift 聚类算法的思想，在每一帧中利用上一帧预测目标的颜色直方图分布，计算该帧中相应位置的像素的颜色直方图分布，然后进行聚类得到其分布的均值，其对应的像素位置是该帧中预测目标的中心位置，然后加上候选框宽高等信息即可得到当前帧预测目标的空间位置。在 Mean Shift 算法中，宽高信息是固定的，因此其无法应对目标尺度和旋转变化，而 Cam Shift 通过将图像矩引入相似度匹配，得到目标尺度和旋转信息，进一步提高了算法的性能。</p>
<h1 id="判别式算法"><a href="#判别式算法" class="headerlink" title="判别式算法"></a>判别式算法</h1><p>判别式方法侧重于将目标视作前景，然后将其从其它被视作背景的内容中分离出来。判别式方法应用了分类算法的思想，将跟踪问题转换成二分类问题。包括经典机器学习算法、相关滤波算法、深度学习算法。</p>
<h2 id="经典机器学习算法"><a href="#经典机器学习算法" class="headerlink" title="经典机器学习算法"></a>经典机器学习算法</h2><p>STRUCK (STRUCtured output tracking with Kernels) 和 Tracking-Learning-Detection (TLD) 。STRUCK 和 TLD 算法分别采用经典机器学习算法中的支持向量机 (support vector machine) 和集成学习 (ensemble learning) 进行分类，并采取了一系列优化方法来提高算法的性能。</p>
<h2 id="相关滤波算法"><a href="#相关滤波算法" class="headerlink" title="相关滤波算法"></a>相关滤波算法</h2><p>方法来源于通信理论，用一个模板与输入进行相关操作，通过得到的响应（输出）来判断该输入与模板的相似程度，即相关性。如 KCF和ECO.</p>
<h2 id="深度学习算法"><a href="#深度学习算法" class="headerlink" title="深度学习算法"></a>深度学习算法</h2><p>利用CNN提取单帧的深度卷积特征。利用LSTM提取前后帧信息。如 SiamRPN 和 MDNet.</p>
<h1 id="目标跟踪算法分类"><a href="#目标跟踪算法分类" class="headerlink" title="目标跟踪算法分类"></a>目标跟踪算法分类</h1><p><img src="https://raw.githubusercontent.com/foolwood/benchmark_results/master/img/recent_Tracker_development.png" alt="avatar"></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://developer.aliyun.com/article/766769">视觉目标跟踪漫谈：从原理到应用</a></p>
]]></content>
      <categories>
        <category>research</category>
        <category>object tracking</category>
      </categories>
      <tags>
        <tag>vot</tag>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title>清理 Linux 系统内存 Cache</title>
    <url>/2021/06/20/clear-linux-memory-cache/</url>
    <content><![CDATA[<p>每个 Linux 系统都有三个选项可以在不中断任何进程或服务的情况下清除缓存。本篇代码以 root 身份在 Ubuntu 18.04演示。</p>
<a id="more"></a>

<h1 id="仅清除页面缓存-Clear-PageCache-only"><a href="#仅清除页面缓存-Clear-PageCache-only" class="headerlink" title="仅清除页面缓存(Clear PageCache only)"></a>仅清除页面缓存(Clear PageCache only)</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sync; <span class="built_in">echo</span> 1 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>

<h1 id="清除目录项和inode-Clear-dentries-and-inodes"><a href="#清除目录项和inode-Clear-dentries-and-inodes" class="headerlink" title="清除目录项和inode(Clear dentries and inodes)"></a>清除目录项和inode(Clear dentries and inodes)</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sync; <span class="built_in">echo</span> 2 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>

<h1 id="清理三者-Clear-PageCache-dentries-and-inodes"><a href="#清理三者-Clear-PageCache-dentries-and-inodes" class="headerlink" title="清理三者(Clear PageCache, dentries and inodes)"></a>清理三者(Clear PageCache, dentries and inodes)</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sync; <span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>

<p>同步 (<code>sync</code>) 将刷新文件系统缓冲区。命令以 “;” 分隔依次运行。在执行序列中的下一个命令之前，shell 等待每个命令终止。正如内核文档中提到的，写入 drop_cache 将清除缓存而不杀死任何应用程序/服务，命令 echo 正在执行写入文件的工作。</p>
<p>如果您必须清除磁盘缓存，第一个命令在企业和生产中是最安全的“…echo 1 &gt; …”。只会清除 PageCache。不建议在生产中使用“…echo 3 &gt;”上方的第三个选项，直到您知道自己在做什么，因为它会清除 PageCache、dentries 和 inode。</p>
<h1 id="定时清理缓存"><a href="#定时清理缓存" class="headerlink" title="定时清理缓存"></a>定时清理缓存</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim clearcache.sh</span><br></pre></td></tr></table></figure>

<p>写入如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Note, we are using &quot;echo 3&quot;, but it is not recommended in production instead use &quot;echo 1&quot;</span></span><br><span class="line">sync</span><br><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 755 clearcache.sh</span><br></pre></td></tr></table></figure>

<p>以 root 身份创建定时清理任务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>

<p>写入如下内容，每天0点，12点，18点的0分清理缓存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0  0,12,18  *  *  *  /path/to/clearcache.sh</span><br></pre></td></tr></table></figure>

<p><font size=5 color=red>不建议定时清理RAM</font></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://www.tecmint.com/clear-ram-memory-cache-buffer-and-swap-space-on-linux/">How to Clear RAM Memory Cache, Buffer and Swap Space on Linux</a></li>
<li><a href="https://colobu.com/2015/10/31/How-to-Clear-RAM-Memory-Cache-Buffer-and-Swap-Space-on-Linux/">在 Linux 上如何清除内存的 Cache、Buffer 和交换空间</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN 模型计算力 FLOPs</title>
    <url>/2021/08/02/cnn-flops/</url>
    <content><![CDATA[<p>在撰写论文时，当进行模型比较时，常常会比较模型准确度，但模型计算力消耗、参数个数也是重要的指标，特别是模型落地时。</p>
<a id="more"></a>

<h1 id="FLOPs"><a href="#FLOPs" class="headerlink" title="FLOPs"></a>FLOPs</h1><p>FLOPS 与 FLOPs 不同:</p>
<ul>
<li>FLOPS: FLoating point Operations Per Second，表示每秒浮点运算次数，衡量硬件（如 GPU ）的计算性能，可理解为计算速度；</li>
<li>FLOPs: FLoating point Operations，表示浮点运算数，衡量模型（如深度学习模型 CNN ）的复杂程度，可理解为计算量。 </li>
</ul>
<h1 id="计算-FLOPs"><a href="#计算-FLOPs" class="headerlink" title="计算 FLOPs"></a>计算 FLOPs</h1><p>计算 FLOPs 常常指深度学习模型前向传播是的计算量，而 CNN 中计算量主要集中在卷积层，除此之外，也有池化层、批归一化层、激活层，上采样层等。下面主要介绍卷积层计算 FLOPs 的方法。</p>
<p>假设卷积核的大小是 $k \times k$，通道数是 $c$，输出特征图的大小是 $H \times W$​​，通道数是 $C$​，则计算力消耗是</p>
<p>$k \times k \times c \times H \times W \times C$</p>
<h1 id="开源库"><a href="#开源库" class="headerlink" title="开源库"></a>开源库</h1><p>一种方便的开源库是 <a href="https://github.com/sovrasov/flops-counter.pytorch">ptflops</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install ptflops</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.models <span class="keyword">as</span> models</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> ptflops <span class="keyword">import</span> get_model_complexity_info</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.cuda.device(<span class="number">0</span>):</span><br><span class="line">  net = models.densenet161()</span><br><span class="line">  macs, params = get_model_complexity_info(net, (<span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>), as_strings=<span class="literal">True</span>,</span><br><span class="line">                                           print_per_layer_stat=<span class="literal">True</span>, verbose=<span class="literal">True</span>)</span><br><span class="line">  print(<span class="string">&#x27;&#123;:&lt;30&#125;  &#123;:&lt;8&#125;&#x27;</span>.format(<span class="string">&#x27;Computational complexity: &#x27;</span>, macs))</span><br><span class="line">  print(<span class="string">&#x27;&#123;:&lt;30&#125;  &#123;:&lt;8&#125;&#x27;</span>.format(<span class="string">&#x27;Number of parameters: &#x27;</span>, params))</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/137719986">CNN 模型所需的计算力flops是什么？怎么计算？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/364543528">FLOPS ？FLOPs！！ FLOPs ? MACs！！</a></li>
</ol>
]]></content>
      <categories>
        <category>research</category>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>dl</tag>
        <tag>python</tag>
        <tag>ml</tag>
        <tag>machine learning</tag>
        <tag>cv</tag>
        <tag>cnn</tag>
        <tag>neural network</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>常用不定积分公式</title>
    <url>/2020/07/18/commonly-used-indefinite-integral/</url>
    <content><![CDATA[<p>这里给出一些常用的不定积分公式。</p>
<a id="more"></a>
<p>$$<br>\int \frac{\mathrm{d}x}{x^2 + a^2} = \frac{1}{a}\arctan\frac{x}{a} + C<br>$$</p>
<p>$$<br>\int \frac{\mathrm{d}x}{x^2 - a^2} = \frac{1}{2a}\ln \left |\frac{x-a}{x+a} \right | + C<br>$$</p>
<p>$$<br>\int \frac{\mathrm{d}x}{\sqrt{a^2 - x^2}} = \arcsin\frac{x}{a} + C<br>$$</p>
<p>$$<br>\int \frac{\mathrm{d}x}{\sqrt{x^2 \pm a^2}} = \ln \left | x + \sqrt{x^2 \pm a^2} \right | + C<br>$$</p>
<p>$$<br>\int \ln x \mathrm{d}x = x \ln x - x + C<br>$$</p>
<p>$$<br>\int e^{ax} \cos bx \mathrm{d}x = \frac{e^{ax}}{a^2 + b^2} (a\cos bx + b\sin bx) + C<br>$$</p>
<p>$$<br>\int e^{ax} \sin bx \mathrm{d}x = \frac{e^{ax}}{a^2 + b^2} (a \sin bx - b \cos bx) + C<br>$$</p>
<p>$$<br>\int x \cos nx \mathrm{d}x = \frac{1}{n^2} \cos nx + \frac{x}{n} \sin nx + C<br>$$</p>
<p>$$<br>\int x \sin nx \mathrm{d}x = \frac{1}{n^2} \sin nx - \frac{x}{n} \cos nx + C<br>$$</p>
<p>$$<br>\int \sec x \mathrm{d}x = \ln \left | \sec x + \tan x \right | + C<br>$$</p>
<p>$$<br>I(m, n) = \int \cos^m x \sin^n x \mathrm{d}x =<br>\bigtriangleup  + \frac{m - 1}{m + n} I(m-2, n) \\<br>= \square + \frac{n - 1}{m + n} I(m, n-2)<br>$$</p>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>antiderivatiive</tag>
        <tag>indefinite integral</tag>
      </tags>
  </entry>
  <entry>
    <title>Colab 使用本地 Jupyter Notebook 内核运行时</title>
    <url>/2020/09/01/colab-with-local-jupyter-notebook/</url>
    <content><![CDATA[<p>众所周知，Colab 是一个美观、工具齐全、编写 Python 代码方便的网页版 notebook，结合本地运行时能够提高代码开发效率。注意本篇使用的 Jupyterlab 版本小于3.</p>
<a id="more"></a>

<p>设置前注意事项：</p>
<ul>
<li>调用任意命令（例如“<code>rm -rf /</code>”）</li>
<li>访问本地文件系统</li>
<li>在计算机上运行恶意内容</li>
</ul>
<h1 id="使用本地-Kernel"><a href="#使用本地-Kernel" class="headerlink" title="使用本地 Kernel"></a>使用本地 Kernel</h1><p>如果想使用 colab + 本地运行时，请按照如下步骤设置：</p>
<ol>
<li><p>安装 Jupyter</p>
<p>建议先安装 Miniconda</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install jupyterlab</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">conda install -c conda-forge jupyterlab</span><br><span class="line"><span class="comment"># or </span></span><br><span class="line">mamba install -c conda-forge jupyterlab</span><br></pre></td></tr></table></figure>

<p>安装后，建议<a href="https://jupyter-notebook.readthedocs.io/en/stable/config.html">生成配置文件</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure>

<p>对于 <a href="https://jupyter-server.readthedocs.io/en/latest/other/full-config.html">JupyterLab 版本大于3 的</a>, 推荐使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">jupyter server --generate-config</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>安装 jupyter_http_over_ws</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install jupyter_http_over_ws</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用 jupyter_http_over_ws</span></span><br><span class="line">jupyter serverextension <span class="built_in">enable</span> --py jupyter_http_over_ws</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>启动服务器并进行身份验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter notebook \</span><br><span class="line">  --NotebookApp.allow_origin=<span class="string">&#x27;https://colab.research.google.com&#x27;</span> \</span><br><span class="line">  --port=8888 \</span><br><span class="line">  --NotebookApp.port_retries=0</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 后面的三个配置都可以在 ～/.jupyter/jupyter_notebook_config.py 中进行设置</span></span><br><span class="line"><span class="comment"># 这样就不用每次启动 jupyter notebook 时手动配置，设置后启动方式如下</span></span><br><span class="line"><span class="comment"># 如果没有文件 jupyter_notebook_config.py，可以使用命令 jupyter notebook --generate-config 生成</span></span><br><span class="line">nohup jupyter notebook &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 查看 jupyter notebook 的 token 可使用如下代码</span></span><br><span class="line">jupyter notebook list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭运行的 jupyter notebook，使用如下命令</span></span><br><span class="line">jupyter notebook stop 8888</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>连接到本地运行时</p>
<p>在 Colaboratory 中，点击“连接”按钮，然后选择“连接到本地代码执行程序…”。在随即显示的对话框中输入上一步中的网址，然后点击“连接”按钮。完成此操作后，您应该就已经连接到本地运行时了。</p>
</li>
<li><p>卸载</p>
<p>您可以通过运行以下命令停用和移除 jupyter_http_over_ws jupyter 扩展程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter serverextension <span class="built_in">disable</span> --py jupyter_http_over_ws</span><br><span class="line">pip uninstall jupyter_http_over_ws</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="使用远程服务器的-Kernel"><a href="#使用远程服务器的-Kernel" class="headerlink" title="使用远程服务器的 Kernel"></a>使用远程服务器的 Kernel</h1><p>如果想要使用远程主机或 vps 的 jupyter notebook，可以先使用终端将远程主机的 jupyter notebook 的 8888 端口映射到本地 localhost 的 8888 端口，方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -L 8888:localhost:8888 jinzhongxu@3.2.1.0</span><br><span class="line"><span class="comment"># 也可以使用如下代码，不打开远程终端</span></span><br><span class="line">ssh -f -N -L 8888:localhost:8888 jinzhong@3.2.1.0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>colab</tag>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>开源许可协议</title>
    <url>/2020/04/30/codes-open-source-license/</url>
    <content><![CDATA[<p>开源许可协议有很多，常见的如：MIT, BSD, Apache, LGPL, GPL，它们之间的关系可以参见阮一峰的<a href="https://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">如何选择开源许可证？</a></p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/other/open-source-license.png"></p>
<a id="more"></a>

<p>该图是乌克兰程序员 Paul Bagwell 制作的分析图，阮一峰将其转化为中文版。此外，也可以参考GitHub提供的网站<a href="http://choosealicense.online/">选择一个开源软件协议</a>，英文版有<a href="https://choosealicense.com/">Choose an open source license</a>获取更多信息。下面对某些开源许可协议（证）进行介绍。</p>
<h1 id="没有License"><a href="#没有License" class="headerlink" title="没有License"></a>没有License</h1><p>没有 Licence 默认是被版权保护。想让大家使用，就需要选择一个合适的开源许可协议。</p>
<h1 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h1><p>MIT 是最宽泛、最自由，没有任何限制。可以售卖、可以使用作者名促销等。</p>
<h1 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h1><p>相对自由，与 Apache 差不多，教 MIT 严格一些，不允许使用作者名促销，需要保护版权。</p>
<h1 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h1><p>最严格，基于 GPL 协议的代码而开发的代码，以及修改的代码，都必须遵守 GPL 协议发布。GPL 也包含不同的版本，对权力进行适当的放开，其中 GPL  v3 是最严格的、最激进的，它也是 GPL 之父 Richard Stallman 不断在宣传和推进的开源许可协议。</p>
<h1 id="GUN"><a href="#GUN" class="headerlink" title="GUN"></a>GUN</h1><p>GNU 是 Lesser General Public License ，GNU 是一种较宽松通用公共许可证 。</p>
<h1 id="给-GitHub-代码仓库添加开源许可协议"><a href="#给-GitHub-代码仓库添加开源许可协议" class="headerlink" title="给 GitHub 代码仓库添加开源许可协议"></a>给 GitHub 代码仓库添加开源许可协议</h1><h2 id="新创建一个仓库的情况"><a href="#新创建一个仓库的情况" class="headerlink" title="新创建一个仓库的情况"></a>新创建一个仓库的情况</h2><p>可以直接在创建仓库时选择自己喜欢的开源许可协议即可。</p>
<h2 id="旧仓库增加开源许可协议"><a href="#旧仓库增加开源许可协议" class="headerlink" title="旧仓库增加开源许可协议"></a>旧仓库增加开源许可协议</h2><ol>
<li>进入 GitHub 该仓库主页，点击 “ Create new file ”; </li>
<li>输入文件名 ” LICENSE “, 然后点击右侧 “ Choose a license template “ ;</li>
<li>选择协议后，点击右侧的 “ Review and submit ”;</li>
<li>在 “ Commit  new file ” 下 输入 “ Create LICENSE ” 或者你喜欢的描述，点击 “ Commit directly to the master branch. ” 前面的圆点，再点击 “ Commit new file ” 提交即可。  </li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>license</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake make gcc 的关系</title>
    <url>/2021/02/03/cmake-make-gcc/</url>
    <content><![CDATA[<p>在运行 C 程序时，我们都知道需要通过 gcc(GNU Compiler Collection，可以编译C、C++、Objective-C、Fortran、Java等编写的源代码) 将源代码编译为二进制文件，才能够执行。</p>
<a id="more"></a>

<h1 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h1><p>简单代码使用 gcc 可直接编译。具体过程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 创建源文件</span></span><br><span class="line">vim hello.c</span><br></pre></td></tr></table></figure>

<p>编写源代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入如下C代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello 20210203 \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译源代码为机器码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用gcc编译</span></span><br><span class="line">gcc hello.c -o hello</span><br><span class="line"><span class="comment"># 也可以将-o和hello写在一起</span></span><br><span class="line">gcc hello.c -ohello</span><br><span class="line"><span class="comment"># 如果有多个源文件，可以这样编译</span></span><br><span class="line">gcc hello1.c hello2.c -o hello</span><br><span class="line"><span class="comment"># 运行的结果</span></span><br><span class="line">./hello</span><br></pre></td></tr></table></figure>

<p>这是一个小程序，可以使用该方法编译。但是，当在大型程序开发时，这种方法就显得笨拙。这时常使用 make 和 cmake 来自动进行编译。</p>
<h1 id="make"><a href="#make" class="headerlink" title="make"></a>make</h1><p>make 基于 makefile，其中 makefile 中包含了 gcc 进行编译的各种命令，make 通过 makefile 进行批处理。</p>
<p>对于相对简单的 makefile 可以使用人工进行书写，但是，对于复杂的工程，makefile 也将会变得很复杂，这时就需要一个自动创建 makefile 的工具，那就是 cmake。</p>
<h1 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h1><p>cmake 可以创建 makefile，方便 make 进行编译。但是 cmake 需要 CMakeLists.txt 才能够生成 makefile. 而一般 CMakeLists.txt 是非常简单的。</p>
<p>需要知道的是，出了 cmake，还有autotools，qmake等可生成 makefile。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://blog.csdn.net/libaineu2004/article/details/77119908">gcc,make,cmake傻傻分不清楚？</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>cmake</tag>
        <tag>gcc</tag>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>实数集的完备性</title>
    <url>/2020/03/20/completeness-of-real-number/</url>
    <content><![CDATA[<p>在数学分析中，实数集的完备性表现为六个定理，分别是实数集合的确界原理、数列的单调有界定理、区间套定理、数列的致密性定理与聚点定理、柯西收敛准则、有限覆盖定理。  它们称为<font color='dd0000'>实数完备性基本定理</font>。  </p>
<a id="more"></a>

<h1 id="区间套定理"><a href="#区间套定理" class="headerlink" title="区间套定理"></a>区间套定理</h1><p><strong>定义 1</strong> &emsp; 设闭区间列${[a_n, b_n]}$具有如下性质：</p>
<p>&emsp; 1. $[a_n, b_n] \supset [a_{n + 1}, b_{n + 1}], \ n = 1, 2, \cdots$;</p>
<p>&emsp; 2. $\lim_{n \to \infty}(b_n - a_n) = 0$,</p>
<p>则称${[a_n, b_n]}$为<strong>闭区间套</strong>，简称为<strong>区间套</strong>。  </p>
<p><strong>定理 7.1</strong> &emsp; （区间套定理）&emsp; 若${[a_n, b_n]}$是一个区间套，则在实数系中存在唯一的一个点$\xi$，使得$\xi \in [a_n, b_n], \ n = 1, 2, \cdots$，即<br>$$<br>a_n \leq \xi \leq b_n, \ n = 1, 2, \cdots.<br>$$<br><strong>推论</strong> &emsp; 若$\xi \in [a_n, b_n], (n = 1, 2, \cdots)$是区间套${[a_n, b_n]}$所确定的点，则对任给的$\varepsilon &gt; 0$，存在$N &gt; 0$，使得当$n &gt; N$时有<br>$$<br>[a_n, b_n] \subset U(\xi; \varepsilon).<br>$$<br><font color='dd00dd'>注意：这里的区间套是闭区间</font>。  </p>
<h1 id="聚点定理"><a href="#聚点定理" class="headerlink" title="聚点定理"></a>聚点定理</h1><p><strong>定义 2</strong> &emsp; 设$S$为数轴上的点集，$\xi$为定点（它可以属于$S$，也可以不属于$S$）。若$\xi$的任何邻域上都含有$S$中无穷多个点，则称$\xi$为点集$S$的一个聚点。  </p>
<p>另外两个等价定义：</p>
<p><strong>定义 $2^{\prime}$</strong> &emsp; 对于点集$S$，若点$\xi$的任何$\varepsilon$邻域上都含有$S$中异于$\xi$的点，即$U^o(\xi; \varepsilon) \cap S \neq \varnothing$，则称$\xi$为$S$的一个聚点。</p>
<p><strong>定义$2^{\prime\prime}$</strong> &emsp; 若存在各项互异的收敛数列${ x_n } \subset S$，则其极限$\lim_{n \to \infty} x_n = \xi$称为$S$的一个聚点。  </p>
<p><strong>定理 7.2</strong> &emsp; (魏尔斯特拉斯（Weierstrass）聚点定理) &emsp; 实轴上的任一有界无限点集$S$至少有一个聚点。  </p>
<h1 id="开覆盖定理"><a href="#开覆盖定理" class="headerlink" title="开覆盖定理"></a>开覆盖定理</h1><p><strong>定义 3</strong> &emsp; 设$S$为数轴上的点集，$H$为开区间的集合（即$H$的每一个元素都是形如$(\alpha, \beta)$的开区间）。若$S$中任何一点都含在$H$中至少一个开区间内，则称$H$为$S$的一个开覆盖，或称$H$覆盖$S$。若$H$中开区间的个数是无限（有限）的，则称$H$为$S$的一个无限开覆盖（有限开覆盖）。  </p>
<p><strong>定理 7.3</strong> &emsp; (海涅-博雷尔（Heine-Borel）有限覆盖定理) &emsp; 设$H$为闭区间$[a, b]$的一个（无限）开覆盖，则从$H$中可选出有限个开区间来覆盖$[a, b]$.  </p>
<p><font color='dd0000'>注意：涉及到有限开覆盖定理首先尝试反证法</font>  。  </p>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>completeness</tag>
        <tag>real number</tag>
      </tags>
  </entry>
  <entry>
    <title>为 Conda 设置可用源</title>
    <url>/2020/05/27/conda-add-channels/</url>
    <content><![CDATA[<p>Python 是一个非常优秀的编程语言，特别是在数据科学和人工智能领域。对于从事人工智能，尤其是深度学习方向研究的科研人员、学生及其他爱好者来说，Python 是一款神器，这主要是归功于 Python 的各种功能包，如 Numpy, Sympy, Matplotlib, Pandas, Scikit-learn, Tensorflow, Pytorch 等，那么如何有效的管理（安装、删除、更新升级、降级到特定版本等）这些包非常的重要。</p>
<a id="more"></a>

<p>Python 常用的包管理工具有 Pip 和 Conda 等。</p>
<p>Pip 是标准的 Python 包管理系统，用于安装和管理由 Python 编写的软件包，大多数包能够从默认的包及其依赖项源（PyPI, <a href="https://pypi.org/">Python Package Index</a>）中找到。</p>
<p>Conda 是一个多功能软件包管理软件，它不仅可以管理 Python 包，也可以管理 R 语言包等，因实际使用中发现 Pip 安装包是总是出现不兼容，安装包失败问题，所以建议使用 Conda 来管理 Python 包。同时，建议使用 Miniconda 或 Ananconda 来安装 Python 和常用依赖包。这会比从 Python 官网安装更加方便。</p>
<p>使用 Conda 来管理 Python 包出现的一个问题就是在国内安装时容易出现 HTTP ERROR，那是因为它的源在国外服务器上，容易导致连接超时问题。一种有效的解决方法就是为 Conda 添加国内源，目前，比较常用的国内源包括<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a> 和 中国科学技术大学开源软件镜像，在 Anaconda 一项中发现后者其实是指向前者的，所以这里以清华大学开源软件镜像源为例，通过实践测试来一步一步配置 Conda 国内镜像源，使得 Conda 管理安装 Python 包顺利进行。</p>
<h1 id="国内源添加方法"><a href="#国内源添加方法" class="headerlink" title="国内源添加方法"></a>国内源添加方法</h1><h2 id="查看-Conda-配置项"><a href="#查看-Conda-配置项" class="headerlink" title="查看 Conda 配置项"></a>查看 Conda 配置项</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda config --show</span><br></pre></td></tr></table></figure>

<p>可以观察 “channels:” 一项，默认为 “- defaults”</p>
<h2 id="添加清华源"><a href="#添加清华源" class="headerlink" title="添加清华源"></a>添加清华源</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --set show_channel_urls yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者使用如下方法：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://tuna.moe/oh-my-tuna/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://github.com/tuna/oh-my-tuna</span></span><br><span class="line">wget https://tuna.moe/oh-my-tuna/oh-my-tuna.py</span><br><span class="line"><span class="meta">#</span><span class="bash"> For yourself</span></span><br><span class="line">python oh-my-tuna.py</span><br><span class="line"><span class="meta">#</span><span class="bash"> ...or <span class="keyword">for</span> everyone!</span></span><br><span class="line">sudo python oh-my-tuna.py --global</span><br><span class="line"><span class="meta">#</span><span class="bash"> Get some <span class="built_in">help</span></span></span><br><span class="line">python oh-my-tuna.py -h</span><br></pre></td></tr></table></figure>

<p>推荐添加 “main” 和 “cloud/conda-forge”，不推荐 “free”（如下），因为 “main” 比 “free” 更新更完善更全，”cloud/conda-forge” 对应 Anaconda 的 conda-forge  ，包含一些 conda 中没有的第三方软件包。但是，实际测试发现清华源里的 conda-forge 更新慢于 Anaconda.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda config --remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br></pre></td></tr></table></figure>



<h2 id="删除默认源"><a href="#删除默认源" class="headerlink" title="删除默认源"></a>删除默认源</h2><p>添加完清华源后，可以使用如下命令查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.condarc</span><br></pre></td></tr></table></figure>

<p>此时，发现”defaults” 仍然存在，而且是在最后一个，当使用 Conda 安装更新 Python 包时，发现仍然出现 HTTP ERROR，因为没有删除 “defaults” 的缘故。删除方法有两种，一种是直接在文件 “~/.condara” 中删除，一种是使用如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda config --remove channels defaults</span><br></pre></td></tr></table></figure>

<p>也可以使用命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure>

<p>删除全部源。</p>
<p>同样，以上删除默认源的方法也适合与清华源的删除。</p>
<h2 id="使用-Conda"><a href="#使用-Conda" class="headerlink" title="使用 Conda"></a>使用 Conda</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda update --all</span><br></pre></td></tr></table></figure>

<h1 id="配置代理使用默认源"><a href="#配置代理使用默认源" class="headerlink" title="配置代理使用默认源"></a>配置代理使用默认源</h1><p>虽然切换到国内源比较快，但是，国内源更新教迟缓一些，对于某些包不能及时更新，这时，可以配置代理，使用默认源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.condarc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加或修改成如下内容</span></span><br><span class="line">channels:</span><br><span class="line">  - https://repo.anaconda.com/pkgs/main</span><br><span class="line">  - conda-forge</span><br><span class="line">show_channel_urls: true</span><br><span class="line">proxy_servers:</span><br><span class="line">  http: socks5://127.0.0.1:1080</span><br><span class="line">  https: socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<p>此时，可以直接使用conda的默认源安装最新的包了。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://docs.anaconda.com/anaconda/user-guide/tasks/using-repositories/">Using default repositories</a></li>
<li><a href="https://docs.conda.io/projects/conda/en/latest/user-guide/configuration/use-condarc.html#config-proxy">Configure conda for use behind a proxy server (proxy_servers)</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>conda</tag>
      </tags>
  </entry>
  <entry>
    <title>Conda 配置其他虚拟环境 jupyter kernel</title>
    <url>/2020/03/25/conda-jupyter-env-kernel/</url>
    <content><![CDATA[<p>Miniconda 是一个 python 简约发行版，集成了 python、pip、conda 等，利用 conda 进行 python 软件包管理非常方便。另外，也可以为特定的项目创建特定的运行环境，再结合 jupyter 等能够非常方便切换各种独立环境。下面给出如何利用 conda 创建特定环境。</p>
<a id="more"></a>

<h1 id="安装-Miniconda"><a href="#安装-Miniconda" class="headerlink" title="安装 Miniconda"></a>安装 Miniconda</h1><p>从官网下载 miniconda 并安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装最新版 miniconda</span></span><br><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line">chmod +x Miniconda3*</span><br><span class="line">./Miniconda3*</span><br></pre></td></tr></table></figure>

<h1 id="安装特定环境"><a href="#安装特定环境" class="headerlink" title="安装特定环境"></a>安装特定环境</h1><p>创建新的环境，命名为 toplayer，安装 python 版本 3.8</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果安装 miniconda 时没有初始化，需要初始化，重新登陆</span></span><br><span class="line">conda init</span><br><span class="line"><span class="comment"># 建议安装 jupyterlab，这样在虚拟环境中就可以不用安装了</span></span><br><span class="line">pip install jupyterlab</span><br></pre></td></tr></table></figure>

<p>创建虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装虚拟环境</span></span><br><span class="line">conda create -n toplayer python=3.8</span><br><span class="line"><span class="comment"># 激活虚拟环境</span></span><br><span class="line">conda activate toplayer</span><br><span class="line"><span class="comment"># 退出虚拟环境</span></span><br><span class="line">conda deactivate</span><br></pre></td></tr></table></figure>

<p><font size=3 color=cyan>删除虚拟环境</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除虚拟环境</span><br><span class="line">conda remove -n toplayer --all</span><br></pre></td></tr></table></figure>

<p>注意，conda 版本要求 4.6+</p>
<p>列出所有安装的环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在主环境下</span></span><br><span class="line">conda env list</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">conda info -e</span><br></pre></td></tr></table></figure>

<h1 id="安装-jupyter-kernel"><a href="#安装-jupyter-kernel" class="headerlink" title="安装  jupyter kernel"></a>安装  jupyter kernel</h1><p>在虚拟环境安装需要的软件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先激活虚拟环境</span></span><br><span class="line">conda activate toplayer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装需要软件</span></span><br><span class="line">conda install ipython jupyterlab</span><br><span class="line"><span class="comment"># 如果在 base 主环境中已经安装了 jupyterlab，那么可以只需要安装 ipykernel</span></span><br><span class="line">pip install ipykernel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在虚拟环境安装 jupyter kernel，并命名</span></span><br><span class="line">python -m ipykernel install --user --name toplayer --display-name <span class="string">&quot;Python3(toplayer)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在主环境中打开 jupyterlab</span></span><br><span class="line">conda deactivate</span><br><span class="line"><span class="comment"># 注意这里尝试退出虚拟环境，并进入到主环境，主环境以 base 显示，如果没有显示任何环境名，可以使用如下命令进入主环境</span></span><br><span class="line">conda activate</span><br><span class="line"><span class="comment"># 打开 jupyterlab</span></span><br><span class="line">jupyterlab</span><br></pre></td></tr></table></figure>

<p>此时，刷新 jupyter notebook 就可以从 kernel 中看到名为 Python3(toplayer) 的 kernel</p>
<h1 id="卸载不想要的-jupyter-kernel"><a href="#卸载不想要的-jupyter-kernel" class="headerlink" title="卸载不想要的 jupyter kernel"></a>卸载不想要的 jupyter kernel</h1><p>查看有哪些 jupyter kernel</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter kernelspec list</span><br></pre></td></tr></table></figure>

<p>显示结果如下（示例）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Available kernels:</span><br><span class="line">  perslay     /home/jinzhongxu/.<span class="built_in">local</span>/share/jupyter/kernels/perslay</span><br><span class="line">  toplayer    /home/jinzhongxu/.<span class="built_in">local</span>/share/jupyter/kernels/toplayer</span><br><span class="line">  python3     /usr/<span class="built_in">local</span>/miniconda/share/jupyter/kernels/python3</span><br><span class="line">  c           /usr/<span class="built_in">local</span>/share/jupyter/kernels/c</span><br></pre></td></tr></table></figure>

<p>删除不需要的 kernel</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter kernelspec uninstall toplayer</span><br><span class="line">jupyter kernelspec uninstall perslay</span><br><span class="line">jupyter kernelspec uninstall c</span><br></pre></td></tr></table></figure>

<h1 id="把包版本号写入文件"><a href="#把包版本号写入文件" class="headerlink" title="把包版本号写入文件"></a>把包版本号写入文件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>

<h1 id="从环境文件安装特定版本的包"><a href="#从环境文件安装特定版本的包" class="headerlink" title="从环境文件安装特定版本的包"></a>从环境文件安装特定版本的包</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><p><a href="http://echrislynch.com/2019/02/01/adding-an-environment-to-jupyter-notebooks/">Adding An Environment to Jupyter Notebooks</a></p>
</li>
<li><p><a href="https://blog.csdn.net/lyy14011305/article/details/59500819">用conda创建python虚拟环境</a></p>
</li>
<li><p><a href="https://pip.pypa.io/en/stable/cli/pip_freeze/">pip freeze</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>jupyter</tag>
        <tag>conda</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>凸函数和拐点</title>
    <url>/2020/03/18/convex-function-and-inflection-point/</url>
    <content><![CDATA[<p>凸函数（Convex function）和拐点（Inflection point）。 此部分为参考 华东师范大学《数学分析上册》。以下内容为学习中的重点总结。</p>
<p>凸函数一般用来证明不等式；注意左右导数和凸函数定义公式的联系；凸函数的性质比较好，在机器学习中是理想的代价函数，因为好求最小值点；注意拐点中的鞍点（是一阶导数等于0的点，即拐点中的驻点或稳定点）。</p>
<a id="more"></a>

<h1 id="凸函数"><a href="#凸函数" class="headerlink" title="凸函数"></a>凸函数</h1><p><strong>定义1</strong> 设$f$为定义在区间$I$上的函数，若对$I$上的任意两点$x_1, x_2$和任意实数$\lambda\in(0,1)$总有<br>$$<br>f(\lambda x_1 + (1-\lambda) x_2)\leq \lambda f(x_1) + (1 - \lambda)f(x_2),<br>$$<br>则称$f$为$I$上的凸函数。反之，如果总有<br>$$<br>f(\lambda x_1 + (1 - \lambda) x_2)\geq \lambda f(x_1) + (1 - \lambda) f(x_2),<br>$$<br>则称$f$为$I$上的凹函数。</p>
<p>另外，</p>
<ol>
<li>如果上面的不等式为严格不等式，那么称严格凸函数和严格凹函数。</li>
<li>如果$-f$为区间$I$上的凹函数，那么$f$为区间$I$上的凸函数。</li>
</ol>
<p><strong>引理</strong> $f$为$I$上的凸函数的充要条件是对于$I$上的任意三点$x_1 &lt; x_2 &lt; x_3$，总有<br>$$<br>\frac{f(x_2) - f(x_1)}{x_2 - x_1} \leq \frac{f(x_3) - f(x_2)}{x_3 - x_2}.<br>$$<br>同样地，$f$为$I$上的凸函数的充要条件是对于$I$上的任意三点$x_1 &lt; x_2 &lt; x_3$，有<br>$$<br>\frac{f(x_2) - f(x_1)}{x_2 - x_1} \leq \frac{f(x_3) - f(x_1)}{x_3 - x_1} \leq \frac{f(x_3) - f(x_2)}{x_3 - x_2}.<br>$$<br><strong>注意，这里把$x_2, x_3$看着一个变量时，函数$\frac{f(x_3) - f(x_1)}{x_3 - x_1}$是一个增函数，可以利用单调有界定理，取极限</strong></p>
<p><strong>定理6.14</strong> 设$f$为区间$I$上的可导函数，则下述论断互相等价：</p>
<ol>
<li><p>$f$为$I$上的增函数；</p>
</li>
<li><p>$f^{\prime}$为$I$上的增函数；</p>
</li>
<li><p>对$I$上的任意两点$x_1, x_2$有<br>$$<br>f(x_2) \geq f(x_1) + f^{\prime}(x_1)(x_2 - x_1).<br>$$<br>论断3的几何意义就是说曲线$y=f(x)$总是在它的任一切线上方。</p>
</li>
</ol>
<p><strong>定理 6.15</strong> 设$f$为区间$I$上的二阶可导函数，则在$I$上$f$为凸函数（凹函数）的充要条件是<br>$$<br>f^{(2)}(x) \geq 0 \ (f^{(2)}(x) \leq 0), \ x \in I.<br>$$<br><strong>定理</strong> 若函数$f$为定义在开区间$(a, b)$上的可导的凸函数（凹函数），则$x_0 \in (a, b)$为$f$的极小值点（极大值点）的充要条件是$x_0$为$f$的稳定点，即$f^{\prime}(x_0) = 0$.</p>
<p><strong>定理</strong> 设函数$f(x)$为<strong>开区间</strong>$(a, b)$上的凸函数，不恒为常数，则$f(x)$不取最大值。</p>
<p>​        凸函数的最大值只能在端点处取得。即，若函数$f(x)$是闭区间$[a, b]$上的凸的连续函数，那么<br>$$<br>f(x) \leq \max{f(a), f(b)}.<br>$$<br><strong>詹森（Jensen）不等式</strong> 若$f$为$[a, b]$上的凸函数，则对任意$x_i \in [a, b], \lambda_i &gt; 0 \ (i = 1, 2, \cdots, n), \ \sum^n_{i = 1} \lambda_i = 1$，有<br>$$<br>f(\sum^n_{i=1} \lambda_i x_i) \leq \sum^n_{i=1} \lambda_i f(x_i).<br>$$<br><strong>引理</strong> 设$f$为开区间$I$内的凸函数（凹函数），则$f$在$I$内任一点$x_0$都存在左、右导数。从而$f$在$x_0$连续。</p>
<h1 id="拐点"><a href="#拐点" class="headerlink" title="拐点"></a>拐点</h1><p><strong>定义2</strong> 设曲线$y = f(x)$在点$(x_0, f(x_0))$处有穿过曲线的切线，且在切点近旁，曲线在切线的两侧分别是严格凸和严格凹的，这时称点$(x_0, f(x_0))$为曲线$y = f(x)$的拐点。</p>
<p>拐点是凹和凸曲线的分界点。</p>
<p><strong>定理6.16</strong> 若$f$在$x_0$二阶可导，则$(x_0, f(x_0))$为曲线$y = f(x)$的拐点的必要条件是$f^{(2)} = 0$.</p>
<p><strong>定理6.17</strong> 设$f$在$x_0$可导，在某领域$U^o(x_0)$上二阶可导。若在$U^o_{+}(x_0)$和$U^o_{-}(x_0)$上$f^{(2)}$的符号相反，则$(x_0, f(x_0))$为曲线$y = f(x)$的拐点。</p>
<p><strong>注意：若$(x_0, f(x_0))$是曲线$y = f(x)$的一个拐点，$y = f(x)$在$x_0$的导数不一定存在，如$y = \sqrt[3]{x}$在$x = 0$。</strong></p>
<p><strong>定理</strong> 如下三个陈述成立。</p>
<ol>
<li>若$f$为凸函数，$\lambda$为非负实数，则$\lambda f$为凸函数；</li>
<li>若$f, g$均为凸函数，则$f + g$为凸函数；</li>
<li>若$f$为区间$I$上凸函数，$g$为$J \supset f(I)$上凸增函数，则$g \circ f$为$I$上凸函数。</li>
</ol>
<p><strong>定理</strong> 设$f$为区间$I$上严格凸函数，$x_0 \in I$为$f$的极小值点，则$x_0$为$f$在$I$上唯一的极小值点。</p>
<p><strong>定理</strong> 若$f, g$均为区间$I$上凸函数，则$F(x) = \max {f(x), g(x)}$也是$I$上凸函数。</p>
<h1 id="几个重要不等式"><a href="#几个重要不等式" class="headerlink" title="几个重要不等式"></a><strong>几个重要不等式</strong></h1><p><strong>均值不等式</strong> 设$a_i &gt; 0 \ (i = 1, 2, \cdots, n)$，有<br>$$<br>\frac{n}{\frac{1}{a_1} + \frac{1}{a_2} + \cdots + \frac{1}{a_n}} \leq \sqrt[n]{a_1 a_2 \cdots a_n} \leq \frac{a_1 + a_2 + \cdots + a_n}{n}<br>$$<br>证明，构造函数$f(x) = \ln(x)$可证明第二个不等号，然后用变化$x = \frac{1}{t}$和第二个不等号证明第一个不等号。</p>
<p><strong>Young 不等式</strong> 设$a, b, p, q$均是正实数，且$\frac{1}{p} + \frac{1}{q} = 1$，则<br>$$<br>ab \leq \frac{a^p}{p} + \frac{b^q}{q}<br>$$<br>等号成立当且仅当 $a^p = b^q$. </p>
<p>证明，利用函数$y = e^x$的凸性<br>$$<br>ab = e^{\ln(a)} e^{\ln(b)} = e^{\frac{1}{p} \ln(a^p) + \frac{1}{q} \ln(b^q)} \leq \frac{1}{p} e^{\ln(a^p)} + \frac{1}{q} e^{\ln(b^q)} = \frac{a^p}{p} + \frac{b^q}{q}.<br>$$<br>可以用该不等式证明如下的Holder不等式。</p>
<p><strong>Holder 不等式</strong> 设$a_i, b_i &gt; 0 \ (i = 1, 2, \cdots, n)$，有<br>$$<br>\sum^n_{i = 1} a_i b_i \leq (\sum^n_{i = 1} a^p_i)^{\frac{1}{p}}(\sum^n_{i = 1} b^q_i)^{\frac{1}{q}}<br>$$<br>其中$p &gt; 1, q &gt; 1, \frac{1}{p} + \frac{1}{q} = 1$.</p>
<p>证明，取$a = \frac{a_k}{(\sum^n_{i = 1}a^p_i)^{\frac{1}{p}}}$, $b = \frac{b_k}{(\sum^n_{i = 1}b^q_i)^{\frac{1}{q}}}$ ，并带入Young不等式。</p>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>convex</tag>
        <tag>inflection</tag>
      </tags>
  </entry>
  <entry>
    <title>分组卷积、深度卷积和全局深度卷积</title>
    <url>/2021/07/02/convolution-classification-group-depthwise/</url>
    <content><![CDATA[<p>卷积能够提取图像特征，不同的卷积操作能够获得不同的效果，同时有些卷积能够降低待学习的参数量，达到正则化的目的。</p>
<a id="more"></a>

<h1 id="分组卷积"><a href="#分组卷积" class="headerlink" title="分组卷积"></a>分组卷积</h1><p>分组卷积（Group Convolution）最早见于2012年 ImageNet 竞赛中的 AlexNet 网路中，被用来切分网络，使得模型能够在2个GPU上并行运行，AlexNet 的网络结构如下：</p>
<p><img src="https://s2.ax1x.com/2019/01/08/FLPm1P.png"></p>
<h2 id="分组卷积的定义"><a href="#分组卷积的定义" class="headerlink" title="分组卷积的定义"></a>分组卷积的定义</h2><p>对于常规卷积，如果输入的特征图是 $C * H * W$，卷积核个数是 $N$，输出特征图的数量也是 $N$，其与卷积核的数量相同。假设卷积和的尺寸是 $C * K * K$，那么 $N$ 个卷积核的总参数量为 $N * C * K * K$，输入特征图与输出特征图的连接方式如下左图：</p>
<p><img src="https://s2.ax1x.com/2019/01/08/FLPc1x.png"></p>
<p>分组卷积是对输入特征图先分组，然后每组分别卷积。假设输入特征图的尺寸仍为 $C * H * W$，输出特征图的数量为 $N$个，如果要分成 $G$ 个组，则每组的输入特征数量为  $\frac{C}{G}$，每组的输出特征图数量为 $\frac{N}{G}$，每个卷积核的尺寸为 $\frac{C}{G} * K * K$，卷积核的总数仍为 $N$个，每组的卷积核数量为 $\frac{N}{G}$，卷积核只与其同组的输入特征图进行卷积，卷积核的总参数量为 $N * \frac{C}{G} * K * K$，可见，总参数量减少为原来的 $\frac{1}{G}$，输入特征图与输出特征图的连接方式如上右图。针对 group1 （group2, group3 相同）的输入特征图是4个，因此其卷积核的通道数为4，输出特征图的通道数为2，表示有两个卷积核，卷积核不与其他组的输入特征图做卷积，只与同组的特征图卷积。</p>
<h2 id="分组卷积的意义"><a href="#分组卷积的意义" class="headerlink" title="分组卷积的意义"></a>分组卷积的意义</h2><ol>
<li><font size=3 color=red>减少参数量，分成 $G$组，则该层的参数量减少为原来的 $\frac{1}{G}$</font></li>
<li>分组卷积可以看成是 structured sparse，每个卷积核的尺寸从 $C * K * K$ 变为 $\frac{C}{G} * K *K$，可以将其余的 $(C - \frac{C}{G}) * K * K$的参数视为 0，有时甚至可以在减少参数量的同时获得更好的效果（相当于正则化）</li>
<li>当分组数量等于输出特征图的数量时，即每一个通道的输入特征图一个分组，输出特征图的数量等于输入特征图的数量，即 $G = N = C$，$N$ 个卷积核每个尺寸为 $1 * K * K$是，分组卷积 Group Convolution 就变成了深度卷积 Depthwise Convolution，参数量进一步减少，参加 <a href="https://arxiv.org/abs/1704.04861">MobileNet</a>, <a href="https://arxiv.org/abs/1610.02357">Xception</a>. 如下图所示</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/01/08/FLkxED.png"></p>
<ol start="4">
<li><p>更进一步，如果分组数 $G = N = C$，即每个通道一个分组，同时卷积核的尺寸与输入特征图的尺寸相同，即 $K = H = W$，则输出特征图为 $C * 1 * 1$，得到长度为 $C$ 的向量，此时称之为  Global Depthwise Convolution (GDC)，参加 <a href="https://arxiv.org/abs/1804.07573">MobileFaceNet</a>，可以看成是全局加权池化，与 Global Average Pooling (GAP) 的不同之处在于 GDC 给每个位置赋予可学习的权重（对于已经对齐的图像很有效，比如人脸，中心位置和边界位置的权重自然应该不同），而 GAP 每个位置的权重相同，全局取平均，如下图所示</p>
<p><img src="https://s2.ax1x.com/2019/01/08/FLEneK.png"></p>
</li>
</ol>
<h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><ol>
<li><a href="https://www.cnblogs.com/shine-lee/p/10243114.html">Group Convolution分组卷积，以及Depthwise Convolution和Global Depthwise Convolution</a></li>
</ol>
]]></content>
      <categories>
        <category>research</category>
        <category>object tracking</category>
      </categories>
      <tags>
        <tag>convolution</tag>
      </tags>
  </entry>
  <entry>
    <title>置信度与置信区间</title>
    <url>/2019/12/20/confidence-statistic-probability/</url>
    <content><![CDATA[<h2 id="如何理解“置信度是95-的置信区间”？"><a href="#如何理解“置信度是95-的置信区间”？" class="headerlink" title="如何理解“置信度是95% 的置信区间”？"></a>如何理解“置信度是95% 的置信区间”？</h2><p>首先，置信区间是根据采样得到的样本点计算得到的，用来估计总体的某个参数值。</p>
<p>其次，对于固定的置信度“95%” ，不同的采样样本集计算得到的置信区间是不一样的。</p>
<p>最后，如何理解置信度“95%”，就是说所有的采样批次中（不同批次可以计算得到不同置信区间），算得的置信区间，有95%个包含总体的那个参数值。</p>
]]></content>
      <categories>
        <category>maths</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>probability</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习中不同的卷积操作</title>
    <url>/2020/11/03/convolution-in-deep-learning/</url>
    <content><![CDATA[<p>本篇参考<a href="https://towardsdatascience.com/types-of-convolutions-in-deep-learning-717013397f4d">An Introduction to different Types of Convolutions in Deep Learning</a> 介绍一下深度学习中不同的卷积操作。</p>
<a id="more"></a>

<h1 id="卷积（Convolutions）"><a href="#卷积（Convolutions）" class="headerlink" title="卷积（Convolutions）"></a>卷积（Convolutions）</h1><p>常规卷积操作如下动图所示，下方（浅蓝色矩形）为输入图像或特征图（feature map），阴影矩形（$3 \times 3$） 为卷积核，上方为输出的特征图。下方虚线边缘矩形为填充，为了在特定卷积核大小和步长下，得到合适的特征图。</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ml/convolution.gif"></p>
<p>这里需要先介绍几个概念。</p>
<h2 id="卷积核（kernel）"><a href="#卷积核（kernel）" class="headerlink" title="卷积核（kernel）"></a>卷积核（kernel）</h2><p>卷积核（卷积核包含至少一个 filter，有时也称 filter 为卷积核）中每个 filter 的大小决定了卷积操作的感受野。如上图所示，卷积核（也是filter，这里输出是单通道）是移动的阴影部分，大小为3，即 $3 \times 3$ 像素。对于输入图像，如果是RGB三通道，那么 filter 也应该是三通道的。如果想输出多通道，可设置多个 filter。即 filter 的通道数和输入图像一样，输出通道由卷积核的个数（filter 的个数）决定。</p>
<p>卷积核的大小一般设置成奇数，如 $1 \times 1, 3 \times 3, 5 \times 5, 7 \times 7$ 等，这是因为如下两点考虑：</p>
<ol>
<li>更容易 padding. 常常想要保持卷积后图像尺寸不变，假设图像大小为 $n \times n$，卷积核大小为 $k \times k$，当 padding 的幅度设为 $(k - 1)/2$ 时，步幅为1，卷积输出为 $(n - k + 2 \times ((k - 1)/2))/1 + 1 = n$. 但是，如果 $k$ 是偶数时，padding 的幅度就不能设置为 $(k - 1)/2$，因为它不再是整数，无法实现；</li>
<li>更容易找到锚点。卷积时一般选择卷积核的某个位置为基准进行移动，通常选择卷积核的中心，如果卷积核大小为偶数，则无法找到锚点。</li>
</ol>
<p>卷积输出图像尺寸的计算公式：</p>
<p>假设输入图像为 $n \times n$，卷积核大小为 $k \times k$，填充为 $p$，步幅为 $s$，那么输入图像大小为<br>$$<br>\lfloor \frac{n + 2p - k}{s} \rfloor + 1<br>$$</p>
<h2 id="步幅（stride）"><a href="#步幅（stride）" class="headerlink" title="步幅（stride）"></a>步幅（stride）</h2><p>步幅决定了卷积核在图像上一次跨越的像素个数。如上图所示，卷积核在图像上一次平移一个像素。步幅常设为1，当设置更大步长时，类似于对图像进行下采样（如MaxPooling），即进行信息压缩，使得输出图像尺寸小于输入图像。步幅值就是缩放的倍数，如果步长设为2，输出就是输入的1/2.</p>
<h2 id="填充（Padding）"><a href="#填充（Padding）" class="headerlink" title="填充（Padding）"></a>填充（Padding）</h2><p>填充定义了如何处理图像的边界。常用方法有两种，分别是 ‘same’ 和 ‘valid’:</p>
<ul>
<li>same padding: 进行填充（通常填充0），允许卷积核超出原始图像边界，并使得卷积后的特征图与原来一致；</li>
<li>valid padding: 不进行任何处理，只使用原始图像，不允许卷积核超出原始图像边界。</li>
</ul>
<h2 id="输入输出通道"><a href="#输入输出通道" class="headerlink" title="输入输出通道"></a>输入输出通道</h2><p>输入通道数决定了卷积核中每个 filter 的通道数，如输入通道数为 3，类似于 RGB 彩色图像。输出通道数决定了卷积核中有多少个 filter，如输出通道为 5，假设每个 filter 的尺寸为 $7 \times 7$，那么该卷积层需要的训练学习的参数个数为 $3 \times 7 \times 7 \times 5 = 735$.</p>
<h1 id="膨胀卷积（Dilated-Convolutions）"><a href="#膨胀卷积（Dilated-Convolutions）" class="headerlink" title="膨胀卷积（Dilated Convolutions）"></a>膨胀卷积（Dilated Convolutions）</h1><p>膨胀卷积（a.k.a, also known as, atrous convolutions, 圆卷积），膨胀卷积为卷积层引入了另一个参数，称为膨胀率。这定义了卷积核中的值之间的间隔。膨胀率为 2 的 $3 \times 3$ 卷积核与 $5 \times 5$ 卷积核具有相同的视野，而仅使用 9 个参数。</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ml/dilated_convolutions.gif"></p>
<p>这以相同的计算成本提供了更广阔的视野。膨胀卷积在实时分割领域中特别流行。如果您需要广阔的视野并且无法承受多次卷积或更大的卷积核，请使用它们。</p>
<h1 id="转置卷积（Transposed-Convolutions）"><a href="#转置卷积（Transposed-Convolutions）" class="headerlink" title="转置卷积（Transposed Convolutions）"></a>转置卷积（Transposed Convolutions）</h1><p>转置卷积（a.k.a. deconvolutions or fractionally strided convolutions，又称为反卷积或分数步卷积）。有些文献使用反卷积名称，这是不合适的，因为它不是反卷积。更糟糕的是，确实存在反卷积，但在深度学习领域并不常见。实际的反卷积可还原卷积的过程。想象一下将图像输入到单个卷积层中。现在获取输出，将其放入黑盒，然后再次输出原始图像。这个黑匣子进行去卷积。它是卷积层功能的数学逆运算。</p>
<p>转置卷积有些类似，因为它产生的空间分辨率与假设的反卷积层相同。但是，对值执行的实际数学运算是不同的。转置的卷积层执行常规卷积，但还原其空间变换。</p>
<p>我们看一个具体的例子。 $5 \times 5$ 的图像被输入到卷积层。步幅设置为 2，禁用填充，卷积核尺寸为 $3 \times 3$，这将产生 $2 \times 2$ 的图像。</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ml/transposed_convolution_p1.gif"></p>
<p>如果我们想逆转此过程，则需要进行逆数学运算，以便从我们输入的每个像素中生成 9 个值。然后，我们以 2 的步幅遍历输出图像。这将是反卷积。</p>
<p>转置卷积不会这样做。唯一的共同点是它可以确保输出也将是 $5 \times 5$ 的图像，同时仍执行正常的卷积操作。为了实现这一点，我们需要对输入执行一些华丽的填充。</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ml/transposed_convolution_p2.gif"></p>
<p>就像您现在可以想象的那样，此步骤不会从上面逆转该过程。至少不涉及数学逆操作。它仅从以前重建空间分辨率并执行卷积。这可能不是数学上的逆运算，但是对于 Encoder-Decoder 架构，它仍然非常有帮助。这样，我们可以将图像的放大与卷积结合在一起，而不必执行两个单独的过程。</p>
<h2 id="可分离卷积（Separable-Convolutions）"><a href="#可分离卷积（Separable-Convolutions）" class="headerlink" title="可分离卷积（Separable Convolutions）"></a>可分离卷积（Separable Convolutions）</h2><p>在可分离卷积中，我们能够把卷积操作分成多步进行。假设卷积表示为 $y = conv(x, k)$，其中 $y$ 为输出图像，$x$ 为输入图像，$k$ 为卷积核。并假设卷积核可以通过 $k = k_1.dot(k_2)$ 计算。这样可以进行可分离卷积，在 2D 上进行 $k$ 卷积等价于作两个 1D 的卷积 $k_1, k_2$.</p>
<p>以图像处理中常常使用的 Sobel 卷积核为例，可以通过将向量 $[1, 0, -1]$ 和 $[1, 2, 1]^T$ 相乘得到，在相同操作下，它只需要 6 个参数，而不是 9 个参数。</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ml/sobel_x_y_filters.png"></p>
<p>这种卷积操作称为空间可分离卷积。</p>
<p>但在深度学习中，深度可分离卷积常会遇到。假设输入图像是 16 通道，卷积核尺寸是 $3 \times 3$，输出通道是 32，按照上面的计算方法常规的卷积操作共有 $16 \times 3 \times 3 \times 32 = 4608$ 个参数。但是，如果进行深度可分离卷积，首先 16 个通道每一个经过 $3 \times 3$ 卷积，得到 16 个特征图，然后，再进行 32（得到 32 通道） 个 $1 \times 1$（每一个都是 16 通道） 的卷积，整个过程一共需要 $16 \times 3 \times 3 + 16 \times 1 \times 1 \times 32 = 656$ 个参数。这里设置的深度乘子是 1.</p>
<p>之所以这样做是因为这样的假设，即空间和深度信息可以解耦。观察 Xception 模型的性能，该理论似乎行得通。深度可分离卷积由于其对参数的有效利用而也用于移动设备。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/77471866">CNN基础知识</a></li>
<li><a href="https://towardsdatascience.com/types-of-convolutions-in-deep-learning-717013397f4d">An Introduction to different Types of Convolutions in Deep Learning</a></li>
<li><a href="https://github.com/vdumoulin/conv_arithmetic">GitHub: Convolutions animations</a></li>
</ol>
]]></content>
      <categories>
        <category>research</category>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>dl</tag>
        <tag>machine learning</tag>
        <tag>convolution</tag>
      </tags>
  </entry>
  <entry>
    <title>查看Linux系统电脑的cpu和内存</title>
    <url>/2020/03/04/cpu-memory/</url>
    <content><![CDATA[<p>CPU情况和内存情况</p>
<p>cpu配置和内存配置决定了电脑的主要性能</p>
<p>电脑cpu配置和内存配置决定了电脑的主要性能。Windows系统非常简单的通过任务管理器查看，而Linux系统更偏向于利用命令行，下面介绍如何通过命令行有效的查看Linux系统的cpu和内存的情况。</p>
<a id="more"></a>

<h1 id="查看cpu情况"><a href="#查看cpu情况" class="headerlink" title="查看cpu情况"></a>查看cpu情况</h1><h2 id="物理cpu个数"><a href="#物理cpu个数" class="headerlink" title="物理cpu个数"></a>物理cpu个数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l</span><br></pre></td></tr></table></figure>

<h2 id="每个物理cpu的核心数"><a href="#每个物理cpu的核心数" class="headerlink" title="每个物理cpu的核心数"></a>每个物理cpu的核心数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo | grep &quot;cpu cores&quot; | uniq</span><br></pre></td></tr></table></figure>

<h2 id="总的逻辑cpu个数"><a href="#总的逻辑cpu个数" class="headerlink" title="总的逻辑cpu个数"></a>总的逻辑cpu个数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo | grep &quot;processor&quot; | wc -l</span><br></pre></td></tr></table></figure>

<h2 id="查看cpu型号"><a href="#查看cpu型号" class="headerlink" title="查看cpu型号"></a>查看cpu型号</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br></pre></td></tr></table></figure>

<h1 id="查看内存信息"><a href="#查看内存信息" class="headerlink" title="查看内存信息"></a>查看内存信息</h1><h2 id="查看内存运行情况"><a href="#查看内存运行情况" class="headerlink" title="查看内存运行情况"></a>查看内存运行情况</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure>

<p>或者使用如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure>

<h1 id="使用htop查看"><a href="#使用htop查看" class="headerlink" title="使用htop查看"></a>使用htop查看</h1><p>命令htop不仅能够显示的给出cpu和内存的多少信息，而且可以给出它们的消耗情况，给出系统的运行压力情况，运行时间情况等信息。所以，htop是一个非常有用的命令。如何使用该命令，直接在终端输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">htop</span><br></pre></td></tr></table></figure>

<p>就会显示上述信息。想要退出，可以按一下键盘上的q</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉目标跟踪算法简介</title>
    <url>/2021/08/20/cv-ot-algorithms-intro/</url>
    <content><![CDATA[<p>单目标跟踪是指给定第一帧目标框的情况下，在视频的后续帧中自动地给出目标的位置和大小。难点在于复杂场景下目标姿态变化、环境光照变化、尺寸变化、背景干扰、遮挡等，以及实际应用中需要满足实时性。</p>
<a id="more"></a>

<h1 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h1><p>目标跟踪算法的发展大致分成两个阶段，一个是2012年以前，一个是2012年以后。以深度学习方法的引入为拐点。</p>
<p>目标跟踪算法的种类大致分为两类，一类是生成式（<strong>generative</strong>）算法，一类是判别式（<strong>discriminative</strong>）算法，目前判别式算法是主流算法。</p>
<p>目标跟踪算法的研究大致分为两个方向，一个是相关滤波方向，一个是深度学习方法，基于相关滤波的跟踪算法因利用快速傅里叶变换，处理速度较快，基于深度学习的跟踪算法因能自动提取目标图像更强大的特征，精度较高。</p>
<p><img src="https://github.com/xujinzh/benchmark_results/blob/master/img/recent_Tracker_development.png?raw=true"></p>
<h1 id="生成式算法"><a href="#生成式算法" class="headerlink" title="生成式算法"></a>生成式算法</h1><p>生成式算法采用特征模型描述目标的外观特征，再最小化跟踪目标与候选目标之间的重构误差来确认目标。此方法着重于目标本身的特征提取，忽略目标的背景信息，因而在目标外观发生剧烈变化或者遮挡时，容易出现目标漂移或目标丢失。</p>
<p>生成式目标跟踪算法主要是在2010年以前发展起来的，代表算法有卡尔曼滤波（Kalman Filters）、CAMShift 等。</p>
<h2 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h2><p>卡尔曼滤波器用于估计线性系统的状态，其中假设状态服从高斯分布。卡尔曼滤波目标跟踪算法是一种单目标跟踪算法。</p>
<p>Broida 和 Chellappa [<a href="https://ieeexplore.ieee.org/abstract/document/4767755">1986-TPAMI-Estimation of Object Motion Parameters from Noisy Images</a>] 使用卡尔曼滤波器来跟踪噪声图像中的点。在基于立体相机的对象跟踪中，Beymer 和 Konolige [<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.46.7987&rep=rep1&type=pdf">1999-ICCV- Real-time tracking of multiple people using continuous detection</a>] 使用卡尔曼滤波器来预测对象在 $x-z$ 维度上的位置和速度。 Rosales 和 Sclaroff [<a href="https://ieeexplore.ieee.org/abstract/document/784618">1999-CVPR-3D trajectory recovery for tracking multiple objects and trajectory guided recognition of actions</a>] 使用扩展卡尔曼滤波器从 2D 运动估计对象的 3D 轨迹。 KalmanSrc 提供了用于卡尔曼滤波的 Matlab 工具箱。</p>
<p>卡尔曼滤波器的一个限制是假设状态变量呈正态分布（高斯分布），这个限制在粒子滤波（单目标跟踪算法）中得到解决。ParticleFltSrc 提供了使用粒子滤波进行跟踪的 Matlab 工具箱。</p>
<h2 id="CAMShift"><a href="#CAMShift" class="headerlink" title="CAMShift"></a>CAMShift</h2><p>CAMShift (<strong>Continuously Adaptive Mean Shift</strong>) 是 Gary Bradski 于 [<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.7673">1998-Computer Vision Face Tracking For Use in a Perceptual User Interface</a>] 引入的一种基于颜色直方图（colour histogram，常使用HSV颜色命名空间）的目标跟踪方法。 CAMShift 算法（又叫连续自适应均值偏移算法）衍生自均值偏移（mean shift）算法，它负责寻找要跟踪的对象的概率分布的中心。主要区别在于 CAMShift 会根据搜索窗口大小自行调整，例如，当对象大小随着它们靠近或远离相机而发生变化时。</p>
<h1 id="判别式算法"><a href="#判别式算法" class="headerlink" title="判别式算法"></a>判别式算法</h1><p>判别式算法将目标跟踪看作一个二元分类问题，通过训练关于目标和背景的分类器来从候选场景中确定目标，可以显著区分背景和目标，性能鲁棒，渐渐成为目标跟踪领域的主流方法，目前大多数基于深度学习的目标跟踪算法都属于判别式方法。</p>
<p>判别式目标跟踪算法主要是在2010年以后开始流行，代表算法有 Struck、TLD、相关滤波类算法、深度学习类算法等。</p>
<h2 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h2><p>Struct 目标跟踪算法是 Sam Hare 等学者于 [<a href="https://ieeexplore.ieee.org/document/6126251">2011-ICCV-Struck: Structured output tracking with kernels</a>] 引入的一种使用 kernelized structured output support vector machine (SVM) 的自适应 tracking-by-detection、判别式、在线学习的 structured output prediction 目标跟踪算法。Struct 主要提出一种基于结构输出预测的自适应视觉目标跟踪的框架，通过明确引入输出空间满足跟踪功能，能够避免中间分类环节，直接输出跟踪结果。同时，为了保证实时性，该算法还引入了阈值机制，防止跟踪过程中支持向量的过增长。</p>
<p>Struct C++ 源码地址: <a href="https://github.com/gnebehay/STRUCK">https://github.com/gnebehay/STRUCK</a></p>
<p>VOTR (视觉目标跟踪算法库): <a href="https://github.com/gnebehay/VOTR">https://github.com/gnebehay/VOTR</a></p>
<h2 id="TLD"><a href="#TLD" class="headerlink" title="TLD"></a>TLD</h2><p>TLD 目标跟踪算法是 Zdenek Kalal 等学者于 [<a href="https://ieeexplore.ieee.org/abstract/document/6104061">2010-TPAMI-Tracking-Learning-Detection</a>] 引入的一种长时间（long-term）目标跟踪算法，主要包含了三个模块：检测模块、跟踪模块、学习模块。TLD 最适合在跟踪对象被遮挡，不连续出现情况下，进行长时跟踪的应用场合。</p>
<p>TLD Matlab 源码地址：<a href="https://github.com/gnebehay/TLD">https://github.com/gnebehay/TLD</a></p>
<h2 id="相关滤波"><a href="#相关滤波" class="headerlink" title="相关滤波"></a>相关滤波</h2><p>相关滤波类算法最重要的特点是快，都是基于手工设计的特征，最早提出是由 David S. Bolme 在 <a href="https://ieeexplore.ieee.org/abstract/document/5539960">2010-MOSSE-Visual object tracking using adaptive correlation filters</a> 中提出，基于单通道灰度特征, MOSSE 表示 Minimum Output Sum of Squared Error，达到 669 FPS.</p>
<p>在此基础上，Jo˜ao F. Henriques 在 <a href="https://link.springer.com/chapter/10.1007/978-3-642-33765-9_50">2012-ECCV-CSK-Exploiting the Circulant Structure of Tracking-by-Detection with Kernels</a> 中提出 CSK，其在 MOSSE 的基础上扩展了密集采样 (加 padding) 和 kernel-trick，达到 362 FPS. </p>
<p>进一步，João F. Henriques 在 <a href="https://ieeexplore.ieee.org/document/6870486">2015-TPAMI-KCF-High-Speed Tracking with Kernelized Correlation Filters</a> 中提出 KCF，其在 CSK 的基础上扩展了多通道梯度的 HOG 特征（梯度特征），达到 172 FPS. </p>
<p>同期，Martin Danelljan 在 <a href="https://openaccess.thecvf.com/content_cvpr_2014/papers/Danelljan_Adaptive_Color_Attributes_2014_CVPR_paper.pdf">2014-CVPR-CN-Adaptive Color Attributes for Real-Time Visual Tracking</a> 中提出 CN，其在 CSK 的基础上扩展了多通道颜色的 Color Names （颜色特征），达到 152 FPS. </p>
<p>上面的相关滤波类目标跟踪算法都没有考虑目标尺度的变化，当目标缩小或扩大都会使跟踪结果不理想。因此，针对该问题有学者提出如下改进的相关滤波类目标跟踪算法。</p>
<p>学者 Yang Li 基于 CSK 提出 <a href="https://link.springer.com/chapter/10.1007/978-3-319-16181-5_18">2014-ECCV-SAMF-A Scale Adaptive Kernel Correlation Filter Tracker with Feature Integration</a>，融合 HOG，CN特征，采用平移滤波器在多尺度缩放的图像块上进行目标检测，取响应最大的那个平移位置及其所在的尺度。</p>
<p>学者 Martin Danelljan 提出 <a href="https://www.diva-portal.org/smash/record.jsf?pid=diva2:785778&dswid=-4498">2014-BMVC-DSST-Accurate Scale Estimation for Robust Visual Tracking</a> DSST 算法，只使用 HOG 特征，DCF 专门用于平移位置检测，并且，又专门训练了类似 MOSSE 的相关滤波器检测尺度变化，创造性地使用了平移滤波+尺度滤波。之后，提出 <a href="https://ieeexplore.ieee.org/abstract/document/7569092">2015-TPAMI-fDSST-Discriminative Scale Space Tracking</a> fDSST 算法对DSST的加速优化，速度提升50%+，精度提升6%+.</p>
<p>进一步，Martin Danelljan 提出 <a href="https://www.cvl.isy.liu.se/research/objrec/visualtracking/conttrack/C-COT_ECCV16.pdf">2016-ECCV-C-COT-Beyond Correlation Filters: Learning Continuous Convolution Operators for Visual Tracking</a> C-COT (Continuous Convolution Operator Tracker) 基于DCF，提出<strong>训练连续卷积滤波器</strong>，在<strong>连续</strong>空间域中，用<strong>隐式插值模型</strong>训练。</p>
<p>更进一步，Martin Danelljan 提出 <a href="https://openaccess.thecvf.com/content_cvpr_2017/html/Danelljan_ECO_Efficient_Convolution_CVPR_2017_paper.html">2017-CVPR-ECO-Efficient Convolution Operators for Tracking</a> ECO 在 C-COT 的基础上进一步提高速度。</p>
<h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><p>DLT</p>
<p>MDNet</p>
<p>SiameseFC</p>
<p>SiameseRPN</p>
<p>DaSiameseRPN</p>
<p>SiameseRPN++</p>
<h1 id="代表性学者"><a href="#代表性学者" class="headerlink" title="代表性学者"></a>代表性学者</h1><h2 id="University-of-Oxford-英国牛津大学"><a href="#University-of-Oxford-英国牛津大学" class="headerlink" title="University of Oxford 英国牛津大学"></a>University of Oxford 英国牛津大学</h2><p><a href="https://www.robots.ox.ac.uk/~joao/"><strong>Joao F. Henriques</strong></a> 和 <a href="https://www.robots.ox.ac.uk/~luca/"><strong>Luca Bertinetto</strong></a></p>
<p>代表作：CSK, KCF, DCF, Staple, SiamFC, CFNet, Learnet</p>
<h2 id="Linkoping-University-瑞典林雪平大学-amp-the-Computer-Vision-Lab-at-ETH-Zurich-Switzerland-瑞士苏黎世联邦理工学院计算机视觉实验室"><a href="#Linkoping-University-瑞典林雪平大学-amp-the-Computer-Vision-Lab-at-ETH-Zurich-Switzerland-瑞士苏黎世联邦理工学院计算机视觉实验室" class="headerlink" title="Linköping University 瑞典林雪平大学 &amp; the Computer Vision Lab at ETH Zurich, Switzerland.瑞士苏黎世联邦理工学院计算机视觉实验室"></a>Linköping University 瑞典林雪平大学 &amp; the Computer Vision Lab at ETH Zurich, Switzerland.瑞士苏黎世联邦理工学院计算机视觉实验室</h2><p><a href="https://martin-danelljan.github.io/"><strong>Martin Danelljan</strong></a></p>
<p>代表作：CN, DSST, SRDCF, DeepSRDCF, SRDCFdecon, C-COT, ECO, ATOM, DiMP, PrDiMP, KeepTrack</p>
<h2 id="中国科学院"><a href="#中国科学院" class="headerlink" title="中国科学院"></a>中国科学院</h2><p><a href="http://www.zhengzhu.net/"><strong>朱政</strong></a> （目前清华在读博后）</p>
<p>代表作：UCT, DaSiameseRPN</p>
<h2 id="大连理工大学-智能图像分析与理解实验室（IIAU-LAB-Intelligent-Image-Analysis-and-Understanding-Lab）"><a href="#大连理工大学-智能图像分析与理解实验室（IIAU-LAB-Intelligent-Image-Analysis-and-Understanding-Lab）" class="headerlink" title="大连理工大学 智能图像分析与理解实验室（IIAU-LAB, Intelligent Image Analysis and Understanding Lab）"></a>大连理工大学 智能图像分析与理解实验室（IIAU-LAB, Intelligent Image Analysis and Understanding Lab）</h2><p><a href="http://ice.dlut.edu.cn/lu/index.html">卢胡川</a></p>
<p>代表作：Online Visual Tracking, LTMU, STARK</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://blog.csdn.net/dengheCSDN/article/details/78896933">VOT, OTB——目标追踪的发展概况</a></li>
</ol>
]]></content>
      <categories>
        <category>research</category>
        <category>object tracking</category>
      </categories>
      <tags>
        <tag>ml</tag>
        <tag>vot</tag>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉方向顶级会议和顶级期刊</title>
    <url>/2019/12/21/cv-sci/</url>
    <content><![CDATA[<p>计算机视觉（Computer Vision，简称CV）方向是一个非常热门的方向，有关CV的会议和期刊因此也有很多，这里我介绍CV方向的三个顶级会议和两个顶级期刊。</p>
<h2>三大顶会</h2>
<p>CV方向的顶级会议包括国际计算机视觉大会（IEEE International Conference on Computer Vision，简称ICCV）、欧洲计算机视觉会议（European Conference on Computer Vision，简称ECCV）、国际计算机视觉与模式识别会议（Conference on Computer Vision and Pattern Recognition，简称CVPR），下面分别介绍它们。</p>
<ol><li><strong>ICCV</strong> <br>
ICCV是由电气电子工程师学会（Institute of Electrical and Electronics Engineers，简称IEEE）于1987年发起和主办，隔一年举行一次，因此都是在奇数年举行。会议通常需要4-5天，最近有延长的趋势，举办地不固定，今年（2019年）ICCV将于10月27日（星期日）到11月2日（星期六）在韩国首尔举办，投稿截止日期是4月22日，关于本届会议信息参见<a href="http://iccv2019.thecvf.com/">官网</a>。</li><li><strong>ECCV</strong> <br>
ECCV<a href="https://link.springer.com/conference/eccv">论文集</a>由 Springer Science+Business Media出版，隔一年举行一次，都是在偶数年举行，与ICCV正好错开。会议通常需要5-6天，举办地固定在欧洲范围内，去年（2018年）ECCV于9月8日-14日在德国慕尼黑举办，该届论文集参加网站<a href="http://openaccess.thecvf.com/ECCV2018.py">cvf</a>。</li><li><strong>CVPR</strong><br>
CVPR是由Takeo Kanade 和 Dana Ballard于1983年首次在华盛顿举办，1985年后主要由IEEE举行，每年一次，都是在美国举行。会议通常需要5-6天，CVPR于2019年6月16日-20日在美国加州长滩举行，回顾<a href="http://cvpr2019.thecvf.com/">网站</a>，下一届将于2020年6月13日（星期六）-19日（星期五）举行。</li></ol>
<h2>两大顶刊</h2>
<p>CV方向的顶级期刊包括模式分析与机器智能汇刊（IEEE Transactions on Pattern Analysis and Machine Intelligence，简称PAMI）、计算机视觉国际期刊（International Journal of Computer Vision，简称IJCV），下面分别介绍它们。</p>
<ol><li><strong>PAMI</strong> <br>
PAMI自1979年由IEEE学会出版，属月刊，主编是Sven J. Dickinson（多伦多大学），2018年影响因子是17.730，<a href="http://mjl.clarivate.com/cgi-bin/jrnlst/jlresults.cgi?PC=K&amp;ISSN=0162-8828">SCI</a>收录。它涵盖了计算机视觉和图像理解，模式分析和识别以及机器智能的研究，机器学习，搜索技术，文档和手写分析，医学图像分析，视频和图像序列分析，基于内容的图像和视频检索，以及面部和手势识别。<a href="https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=34">投稿</a>及了解更多参见<a href="https://www.computer.org/csdl/journal/tp">官网</a>。</li><li><strong>IJCV</strong><br>
IJCV自1987年由Springer出版，属月刊，主编是Martial Hebert（Carnegie Mellon University, USA ）、Svetlana Lazebnik （University of Illinois at Urbana-Champaign, USA）、Xiaoou Tang（Chinese University of Hong Kong, Hong Kong），2017、2018年影响因子分别是11.541、6.071，<a href="http://mjl.clarivate.com/cgi-bin/jrnlst/jlresults.cgi?PC=K&amp;ISSN=*0920-5691">SCI</a>收录。它涵盖计算机视觉的数学，物理和计算方面：图像形成，处理，分析和解释；机器学习技术；统计方法；传感器。及其应用：基于图像的渲染，计算机图形，机器人，照片解释，图像检索，视频分析和注释，多媒体等。投稿及了解更多参见<a href="https://www.springer.com/computer/image+processing/journal/11263">官网</a>。</li></ol>
<p>以上汇总的是目前CV方向比较重要的会议和期刊，关注它们可以获得该方向的最新进展。</p>]]></content>
      <categories>
        <category>research</category>
      </categories>
      <tags>
        <tag>cv</tag>
        <tag>sci</tag>
      </tags>
  </entry>
  <entry>
    <title>一个脚本启动、关闭和查看大数据处理平台集群Zookeeper、Kafka等</title>
    <url>/2020/03/28/daemons-scirpts-for-zookeepr-etc/</url>
    <content><![CDATA[<p>对于分布式大数据处理框架，如Zookeeper、Kafka、Storm等，在启动、关闭、查看状态时都需要一个一个的去各节点机器上查看，效率非常低，这里给出一个脚本，用于管理大数据处理框架如Zookeeper集群，具体脚本代码参看我的GitHub网站：<a href="https://github.com/xujinzh/archive/tree/master/big-data">https://github.com/xujinzh/archive/tree/master/big-data</a>    </p>
<a id="more"></a>

<p>命令使用说明，这里假设Zookeeper集群部署在box0, box1, box2上，我们在本地可以通过ssh连接这些集群服务器。在本地运行shell脚本。注意，这里的脚本需要你修改为自己的启动参数，如用户名，启动初始位置等。可以通过vim zks-daemons.sh来修改相应内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) jinzhongxu@jinzhongxu-PowerEdge-R740:~/Documents/daemons$ ./zks-daemons.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /home/jinzhongxu/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Mode: leader</span><br><span class="line">Zookeeper node is box0, run status <span class="built_in">command</span>.</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /home/jinzhongxu/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Mode: follower</span><br><span class="line">Zookeeper node is box1, run status <span class="built_in">command</span>.</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /home/jinzhongxu/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Mode: follower</span><br><span class="line">Zookeeper node is box2, run status <span class="built_in">command</span>.</span><br></pre></td></tr></table></figure>

<p>可以发现，box0被选为leader，box1和box2为follower.</p>
<p>同样的，我们可以关闭zookeeper集群</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./zks-daemons.sh stop</span><br></pre></td></tr></table></figure>

<p>启动Zookeeper集群</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./zks-daemons.sh start</span><br></pre></td></tr></table></figure>

<p>类似的，我们可以使用脚本管理Kafka集群等。</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>big data</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习中的数据划分技巧</title>
    <url>/2020/08/17/data-spliting-technique-in-machine-learning/</url>
    <content><![CDATA[<p>机器学习中划分数据集的主要目的是为了避免过拟合。</p>
<p>在机器学习领域，为了避免过拟合和模型选择偏差常常划分数据集为三类：</p>
<ol>
<li><p>训练集（training set）</p>
</li>
<li><p>验证集（cross-validation set or development set or dev set）</p>
</li>
<li><p>测试集（testing set）</p>
<a id="more"></a>

</li>
</ol>
<p>我们尝试在训练集上构建模型，然后在验证集上尽可能优化超参数。最后，在我们的模型准备好后，在测试集上评估我们的模型。</p>
<p>对于机器学习算法研究员，有时候会省略测试集。测试集旨在对算法在现实世界中数据上进行无偏估计，此时，整个数据集分为两部分。将数据集分为两部分的研究员通常将验证集称为测试集。</p>
<h1 id="训练集"><a href="#训练集" class="headerlink" title="训练集"></a>训练集</h1><p>用于拟合模型的数据样本，即我们用于训练模型的数据集的实际子集（在神经网络的中估算权重和偏差）。该模型从该数据中学习并优化模型参数。</p>
<h1 id="验证集"><a href="#验证集" class="headerlink" title="验证集"></a>验证集</h1><p>我们通过最小化交叉验证集上的误差来选择适当的模型或多项式的阶数（如果仅使用回归模型）。</p>
<h1 id="测试集"><a href="#测试集" class="headerlink" title="测试集"></a>测试集</h1><p>用于对训练数据集上的最终模型进行无偏评估的数据样本。仅在使用训练集和验证集对模型进行完全训练之后，才使用它。因此，测试集是一种用于一旦将模型部署在现实场景使用时将遇到的情况评估集。</p>
<p>该测试集通常用于评估Kaggle或Analytics Vidhya的竞赛中的不同模型。通常，在机器学习黑客马拉松中，交叉验证集会与训练集一起发布，而实际测试集只会在比赛即将结束时才发布，而测试集上模型的得分决定了优胜者。</p>
<h1 id="如何划分数据集"><a href="#如何划分数据集" class="headerlink" title="如何划分数据集"></a>如何划分数据集</h1><p>答案通常在于数据集本身。比例是根据我们可用数据的大小和类型（对于时间序列数据，拆分技术有所不同）确定的。</p>
<p>如果我们的数据集的大小在100到1000000之间，则将其按60:20:20的比例进行分配。即60％的数据将进入训练集，20％的数据将进入验证集，其余数据将进入测试集。 如果数据集的大小大于一百万，那么我们可以将其拆分为类似98：1：1或99：0.5：0.5的大小。</p>
<p>决定分割率的主要目的是所有三个集合都应具有原始数据集的总体趋势。如果我们的研究员收集的数据很少，那么最终我们可能会选择一些偏向于仅在研究员收集数据表现的趋势的模型。训练集也是如此-太少的数据会使模型偏向仅在数据集的那个子集中发现的某些趋势。</p>
<p>我们部署的模型不过是估算器，用于了解数据中的统计趋势。因此，重要的是用于学习的数据以及用于验证或测试模型的数据应遵循尽可能相似的统计分布。尽可能完美地实现这一目标的方法之一是随机选择子集（这里是训练集，验证集和/或测试集）。例如，假设您正在进行人脸检测项目，并且人脸训练图片是从网络上拍摄的，而验证/测试图片是从用户手机中获取的，那么训练集和验证/测试集的属性将不匹配。</p>
<p>一种划分训练集、验证集、测试集为0.6，0.2，0.2的方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入scikit-learn中数据集划分包</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机划分20%的数据样本为测试集</span></span><br><span class="line">x, x_test, y, y_test = train_test_split(data, labels, test_size=<span class="number">0.2</span>, train_size=<span class="number">0.8</span>, random_state=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 随机划分剩下（80%）的25%为验证集（整个样本的20%=80%*25%）和75%为训练集（整个样本的60%=80%*75%）</span></span><br><span class="line">x_train, x_cross_validation, y_train, y_cross_validation = train_test_split(x, y, test_size=<span class="number">0.25</span>, train_size=<span class="number">0.75</span>, random_state=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>research</category>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>ml</tag>
        <tag>data</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian 系统如何增加系统用户和删除用户</title>
    <url>/2020/01/10/debian-adduser-deluser/</url>
    <content><![CDATA[<p>Debian 系统是一各非常优秀的 Linux 操作系统，Ubuntu 是基于 Debian 的衍生版本，具有相同的包管理工具和系统命令。有时候我们需要给 Debian 系统的服务器添加用户，那么可以通过如下命令非常简单的操作。本篇演示默认在 root 用户下操作。</p>
<a id="more"></a>

<h1 id="使用-adduser-添加用户"><a href="#使用-adduser-添加用户" class="headerlink" title="使用 adduser 添加用户"></a>使用 adduser 添加用户</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adduser jinzhongxu</span><br></pre></td></tr></table></figure>

<p>该命令是 Perl 脚本命令，可以交互式的创建用户，需要设置新用户密码，并同时创建同名用户组和家目录。</p>
<p>将该用户添加到 sudo 次组（主组名同用户名）中，使其具有 sudo 权限，命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -a -G sudo jinzhongxu</span><br></pre></td></tr></table></figure>

<h1 id="使用-deluser-删除用户"><a href="#使用-deluser-删除用户" class="headerlink" title="使用 deluser 删除用户"></a>使用 deluser 删除用户</h1><p>有时候不想再使用用户了，可以删除用户，同时也可以删除该用户所有的文件，使用如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deluser --remove-all-files jinzhongxu</span><br></pre></td></tr></table></figure>

<h1 id="其他添加用户命令"><a href="#其他添加用户命令" class="headerlink" title="其他添加用户命令"></a>其他添加用户命令</h1><p>其实，除了上面比较方面的 Perl 脚本命令，用更加强大的 Linux 命令 useradd 和 userdel 来添加用户和删除用户，但是，需要的参数比较多，记忆比较复杂，下面列出各参数</p>
<h2 id="useradd-添加用户"><a href="#useradd-添加用户" class="headerlink" title="useradd 添加用户"></a>useradd 添加用户</h2><p>-c 备注：备注出现在 /etc/passwd 第 5 项字段中<br>        -d 用户主文件夹：指定用户登录所进入的目录，同时赋予用户对该目录的的完全控制权<br>        -e 有效期：指定用户的有效期限。格式为 YYYY-MM-DD，信息存储在 /etc/shadow 中<br>        -f 缓冲天数：限定密码过期后多少天，将该用户帐号停用<br>        -g 主要组：设置用户所属的主要组<br>        -G 次要组：设置用户所属的次要组，可设置多组<br>        -M 强制不创建用户主文件夹<br>        -m 强制建立用户主文件夹，并将 /etc/skel/ 当中的文件复制到用户的根目录下<br>        -p 密码：设置用户密码<br>        -s shell：指导用户登录 shell<br>        -u uid：指定用户标志符 user id，即 uid</p>
<h3 id="建一个带有家目录并且可以登录-bash-的用户"><a href="#建一个带有家目录并且可以登录-bash-的用户" class="headerlink" title="建一个带有家目录并且可以登录 bash 的用户"></a>建一个带有家目录并且可以登录 bash 的用户</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -m -s /bin/bash jinzhongxu</span><br></pre></td></tr></table></figure>

<h3 id="指定创建用户家目录的路径"><a href="#指定创建用户家目录的路径" class="headerlink" title="指定创建用户家目录的路径"></a>指定创建用户家目录的路径</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -m -d /home/jinzhongxu jinzhongxu</span><br></pre></td></tr></table></figure>

<h3 id="创建时把用户加入不同的用户组"><a href="#创建时把用户加入不同的用户组" class="headerlink" title="创建时把用户加入不同的用户组"></a>创建时把用户加入不同的用户组</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -m -G sudo jinzhongxu</span><br></pre></td></tr></table></figure>

<h3 id="创建类似于-adduser-方法的用户"><a href="#创建类似于-adduser-方法的用户" class="headerlink" title="创建类似于 adduser 方法的用户"></a>创建类似于 adduser 方法的用户</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -m -s /bin/bash -d /home/jinzhongxu -G sudo jinzhongxu</span><br></pre></td></tr></table></figure>

<h3 id="创建用户的同时设置密码"><a href="#创建用户的同时设置密码" class="headerlink" title="创建用户的同时设置密码"></a>创建用户的同时设置密码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不建议显示设置密码</span></span><br><span class="line">useradd -m -s /bin/bash -d /home/jinzhongxu -G sudo -p <span class="string">&quot;<span class="subst">$(openssl passwd -1 121212)</span>&quot;</span>  jinzhongxu</span><br><span class="line">useradd -m -s /bin/bash -d /home/jinzhongxu -G sudo -p `openssl passwd -1 -salt <span class="string">&#x27;salt&#x27;</span> 121212` jinzhongxu</span><br></pre></td></tr></table></figure>

<h2 id="userdel-删除用户"><a href="#userdel-删除用户" class="headerlink" title="userdel 删除用户"></a>userdel 删除用户</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该命令删除用户所有的文件</span></span><br><span class="line">userdel -r jinzhongxu</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>debian</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习中常用的正则化</title>
    <url>/2021/11/11/deep-learning-normalization/</url>
    <content><![CDATA[<p>Normalization 在深度学习中常被使用，它能够正则化神经网络中的输出数据，一定程度上消除内部协变量偏移（Internal Covariate Shift），加速网络训练，为初始化网络参数松绑，提高模型精度等。本篇介绍在深度学习中常用的正则化方法。</p>
<a id="more"></a>

<h1 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h1><p><a href="http://proceedings.mlr.press/v37/ioffe15.html">Batch Normalization</a> 是对输入的的多个向量（即一批向量 $x_i,i=1,⋯,m$），对每个维度（<font color=orange>特征</font>）上进行正则化，也即每个神经元单独进行一批数据（分量）的正则化。首先计算该维度上的均值和标准差，然后该维度上各个分量减去均值再除以标准差。下面公式都是按照逐元素操作的。说白了，批正则化是针对每个神经元进行批次正则化。均值分母是批次大小。<br>$$<br>\mu_{\mathcal{B}} \leftarrow \frac{1}{m}\sum^m_{i=1} x_i<br>$$</p>
<p>$$<br>\sigma^2_{\mathcal B} \leftarrow \frac{1}{m}\sum^m_{i=1}(x_i - \mu_{\mathcal B})^2<br>$$</p>
<p>$$<br>\hat x_i \leftarrow \frac{x_i - \mu_{\mathcal B}}{\sqrt{\sigma^2_{\mathcal B} + \epsilon}}<br>$$</p>
<p>$$<br>y^i \leftarrow \gamma \hat x_i + \beta \equiv \mathbf{BN}_{\gamma, \beta}(x_i)<br>$$</p>
<p>其中 $\gamma, \beta$ 为可学习参数。最后一个公式表示<strong>反正则化</strong>，即与正则化相反，它能够通过参数进行反正则化，参数值是神经网络通过学习来决定的，所以，是否进行反正则化或者进行正则化是有神经网络对数据在学习中决定，这使得神经网络能够自动学习决定是否进行正则化，以适应数据。这些参数与原始模型参数一起学习，并恢复网络的表示能力。</p>
<p>下面给出一个实际例子，展示如何进行批正则化计算（前向），这里输入批次中包含两个向量 $x_1 = (1, 2, 3), x_2 = (4, 5, 6)$，对其进行批正则化，批次是 2，每个向量维数是 $1 \times 3$，按照算法，依照每个维度进行正则化计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">x</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">       </span><br><span class="line">N, D = x.shape</span><br><span class="line">N, D</span><br><span class="line">array([<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">mu = <span class="number">1.</span>/N * np.sum(x, axis=<span class="number">0</span>)</span><br><span class="line">mu</span><br><span class="line">array([<span class="number">2.5</span>, <span class="number">3.5</span>, <span class="number">4.5</span>])</span><br><span class="line"></span><br><span class="line">xmu = x - mu</span><br><span class="line">xmu</span><br><span class="line">array([[<span class="number">-1.5</span>, <span class="number">-1.5</span>, <span class="number">-1.5</span>],</span><br><span class="line">       [ <span class="number">1.5</span>,  <span class="number">1.5</span>,  <span class="number">1.5</span>]])</span><br><span class="line">       </span><br><span class="line">sq = xmu ** <span class="number">2</span></span><br><span class="line">sq</span><br><span class="line">array([[<span class="number">2.25</span>, <span class="number">2.25</span>, <span class="number">2.25</span>],</span><br><span class="line">       [<span class="number">2.25</span>, <span class="number">2.25</span>, <span class="number">2.25</span>]])</span><br><span class="line"></span><br><span class="line">var = <span class="number">1.0</span> / N * np.sum(sq, axis=<span class="number">0</span>)</span><br><span class="line">var</span><br><span class="line">array([<span class="number">2.25</span>, <span class="number">2.25</span>, <span class="number">2.25</span>])</span><br><span class="line"></span><br><span class="line">sqrtvar = np.sqrt(var + <span class="number">0.0</span>)</span><br><span class="line">sqrtvar</span><br><span class="line">array([<span class="number">1.5</span>, <span class="number">1.5</span>, <span class="number">1.5</span>])</span><br><span class="line"></span><br><span class="line">ivar = <span class="number">1.</span>/sqrtvar</span><br><span class="line">ivar</span><br><span class="line">array([<span class="number">0.66666667</span>, <span class="number">0.66666667</span>, <span class="number">0.66666667</span>])</span><br><span class="line"></span><br><span class="line">xhat = xmu * ivar</span><br><span class="line">xhat</span><br><span class="line">array([[<span class="number">-1.</span>, <span class="number">-1.</span>, <span class="number">-1.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line">gamma = np.array([<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line">gammax = gamma * xhat</span><br><span class="line">gammax</span><br><span class="line">array([[<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">-0.5</span>],</span><br><span class="line">       [ <span class="number">0.5</span>,  <span class="number">0.5</span>,  <span class="number">0.5</span>]])</span><br><span class="line"></span><br><span class="line">beta = np.array([<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>])</span><br><span class="line">out = gammax + beta</span><br><span class="line">out</span><br><span class="line">array([[<span class="number">-0.4</span>, <span class="number">-0.4</span>, <span class="number">-0.4</span>],</span><br><span class="line">       [ <span class="number">0.6</span>,  <span class="number">0.6</span>,  <span class="number">0.6</span>]])</span><br></pre></td></tr></table></figure>

<p>使用批正则化的好处是，一方面使得网络对初始化要求降低（初始化同时扩大K倍对于批正则化后的结果没有影响），另一方面，可以使用较大的学习率，增加收敛速度。</p>
<p>批正则化的提出是解决内部协变量偏移（Internal Covariate Shift, 简写为 ICS）的问题。所谓<em>协变量偏移</em>（<a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.370.4921&rep=rep1&type=pdf">Covariate Shift</a>）是指当输入数据的分布在训练环境和实际环境之间发生变化时。尽管输入分布可能会发生变化，但输出分布或标签保持不变。在监督机器学习中，模型将通过离线或本地环境中的训练数据集学习输入和输出数据之间的关系。然后，该模型可用于使用它学到的模式进行预测或对新数据进行分类。当训练数据中的变量分布与现实世界或测试数据不同时，就会发生协变量偏移。这意味着模型一旦部署就可能会做出错误的预测，其准确率会明显降低。所谓<em>内部协变量偏移</em> 是指神经网络隐藏层的输入会因为学习参数导致与输出的数据分布不一致，而造成协变量偏移。也就是说训练过程中深度网络内部节点分布的变化称为<strong>内部协变量偏移</strong>。 Internal Covariate Shift 主要是由于训练过程中由于网络参数的变化而导致的网络激活分布的变化。</p>
<p>理想情况下，在整个训练集上进行正则化，但要将正则化与随机优化方法结合使用，使用全局信息是不切实际的。因此，在训练过程中，正则化被限制在每个小批量上。</p>
<p><font color=cyan>批正则化不适用于 RNN 等动态网络，而且当批次较小时效果不好。</font></p>
<p>注意，推理阶段批正则化将发生改变。具体参考原论文。</p>
<h1 id="Layer-normalization"><a href="#Layer-normalization" class="headerlink" title="Layer normalization"></a>Layer normalization</h1><p>Layer norm （<a href="https://arxiv.org/abs/1607.06450">Layer Normalization</a>）是由 Geoffrey E. Hinton 等于 16 年提出，来解决 Batch norm 的缺点（不能应用在 RNN 中）。对一个向量来做正则化。首先计算该向量的均值和标准差，然后用该向量的各分量减去均值再除以标准差。说白了，层正则化是针对数据进行该层神经元的正则化。均值分母是该层神经元的个数。</p>
<p>在批正则化中，隐层神经元有单独的均值和标准差，而在层正则化中，一个隐藏层中的神经元共享相同的均值和标准差。</p>
<p>训练和推断处理方式一致。</p>
<p>在卷积网络中，层正则化没有批正则化好，但在 RNN 中层正则化更好。</p>
<h1 id="Instance-normalization-and-Group-normalization"><a href="#Instance-normalization-and-Group-normalization" class="headerlink" title="Instance normalization and Group normalization"></a>Instance normalization and Group normalization</h1><p><a href="https://arxiv.org/pdf/1607.08022.pdf">Instance normalization</a> 是2016年提出的，针对某一次输入某一个神经元的输出（特征图）进行正则化得到的。</p>
<p>Group Normalization 是由 Yuxin Wu 和 Kaiming He 于2018年在ECCV上发表的文章：<a href="https://openaccess.thecvf.com/content_ECCV_2018/papers/Yuxin_Wu_Group_Normalization_ECCV_2018_paper.pdf">Group Normalization</a> 中提出的。它介于 Layer Norm 和 Instance Norm 之间。对通道进行分组，然后分布正则化。效果上较 Batch Norm 要好。</p>
<h1 id="四者图示"><a href="#四者图示" class="headerlink" title="四者图示"></a>四者图示</h1><p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ml/layer-norm.png"></p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ml/group-norm.png"></p>
<ul>
<li>Batch Norm 在 batch 的维度上正则化，正则化维度为 $[N，H，W]$，对 batch 中对应的 channel 正则化；</li>
<li>Layer Norm 避开了 batch 维度，正则化的维度为 $[C，H，W]$；</li>
<li>Instance Norm 正则化的维度为 $[H，W]$；</li>
<li>Group Norm 介于 Instance Norm 和 Instance Norm 之间，其首先将 channel 分为许多 group，对每一个 group 做正则化。即先将 feature 的维度由 $[N, C, H, W]$ reshape 为 $[N, G，C/G , H, W]$，正则化的维度为 $[C/G , H, W]$.</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://kratzert.github.io/2016/02/12/understanding-the-gradient-flow-through-the-batch-normalization-layer.html">Understanding the backward pass through Batch Normalization Layer</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/35005794">全面解读Group Normalization-（吴育昕-何恺明 ）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/56542480">模型优化之Instance Normalization</a></li>
</ol>
]]></content>
      <categories>
        <category>research</category>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>dl</tag>
        <tag>normalization</tag>
      </tags>
  </entry>
  <entry>
    <title>由平行截面面积求体积</title>
    <url>/2020/10/17/definite-integral-calculate-volume/</url>
    <content><![CDATA[<p>本节讲通过定积分求解三维空间中立体的体积。</p>
<a id="more"></a>

<p>假设 $\Omega$ 为三维空间中的一个立体，它夹在垂直于 $x$ 轴的两平面 $x = a$ 与 $x = b$ 之间，这里 $a &lt;b$. 若在任意一点 $x \in [a, b]$ 处作垂直于 $x$ 轴的平面，它截得 $\Omega$ 的截面面积显然是 $x$ 的函数，记为 $A(x), x \in [a, b]$，并称之为 $\Omega$ 的截面面积函数。假设截面面积函数 $A(x)$ 是 $[a, b]$ 上的一个连续函数，且把 $\Omega$ 的上述平行截面投影到某一垂直于 $x$ 轴的平面上，它们永远是一个含在另一个里面。对 $[a, b]$ 作分割<br>$$<br>T: a = x_0 &lt; x_1 &lt; \cdots &lt; x_n = b.<br>$$<br>过各个分点作垂直于 $x$ 轴的平面 $x = x_i, i = 1, 2, \cdots, n$，它们把 $\Omega$ 切割成 $n$ 个薄片 $\Omega_i, i = 1, 2, \cdots, n$. 任取 $\xi_i \in [x_{i-1}, x_i]$，那么每一个薄片的体积<br>$$<br>\Delta V_i \approx A(\xi_i) \Delta x_i.<br>$$<br>于是<br>$$<br>V \approx \sum_{i=1}^n A(\xi_i)\Delta x_i.<br>$$<br>由定积分的定义和连续函数的可积性，当 $|T|\to 0$时，上式右边的极限存在，即为函数 $A(x)$ 在 $[a, b]$ 上的定积分。于是我们定义立体 $\Omega$ 的体积为<br>$$<br>V = \int_a ^b A(x) \mathrm{d}x.<br>$$<br>假设 $\Omega_A, \Omega_B$ 为位于同一区间 $[a, b]$ 上的两个立体，其体积分别为 $V_A, V_B$，若在 $[a, b]$ 上它们的截面面积函数 $A(x)$ 与 $B(x)$ 皆连续，且 $A(x) = B(x)$，则$V_A = V_B$. 该定理在我国齐梁时期的数学家祖暅（祖冲之之子）早发现，在《九章算术》一书中记载的祖暅原理是：“夫叠棊成立积，缘幂势既同则积不容异”。</p>
<p>对于旋转体，体积计算公式定义如下。</p>
<p>假设 $f$ 是 $[a, b]$ 上的连续函数，$\Omega$ 是由平面图形<br>$$<br>0 \leq |y| \leq |f(x)|, a \leq x \leq b<br>$$<br>绕 $x$ 轴旋转一周所得的旋转体。那么易知截面面积函数为<br>$$<br>A(x) = \pi [f(x)]^2, x \in [a, b].<br>$$<br>得旋转体 $\Omega$ 的体积公式为<br>$$<br>V = \pi \int_a ^b [f(x)]^2 \mathrm{d}x.<br>$$</p>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>definite integral</tag>
        <tag>volume</tag>
      </tags>
  </entry>
  <entry>
    <title>定积分定义</title>
    <url>/2020/07/27/definite-integral/</url>
    <content><![CDATA[<p>导数的逆运算是不定积分，而定积分是某种特殊和式的极限。不定积分与定积分既有联系又有区别。</p>
<a id="more"></a>

<h1 id="概念的引出"><a href="#概念的引出" class="headerlink" title="概念的引出"></a>概念的引出</h1><p>定积分的概念提出是基于：1、曲边梯形的面积；2、变力所做的功。总体思想是：<strong>分割，近似求和，取极限</strong>。</p>
<h1 id="定积分的定义"><a href="#定积分的定义" class="headerlink" title="定积分的定义"></a>定积分的定义</h1><p><strong>定义</strong>    设闭区间 $[a, b]$ 上有 $n-1$ 个点，依次为<br>$$<br>a = x_0 &lt; x_1 &lt; x_2 &lt; \cdots &lt; x_{n-1} &lt; x_n = b,<br>$$<br>它们把 $[a, b]$ 分成 $n$ 个小区间 $\Delta_i = [x_{i-1}, x_i], i=1,2,\cdots,n$. 这些分点或这些闭区间构成对 $[a,b]$ 的一个分割，记为<br>$$<br>T = {x_0, x_1, \cdots, x_n} 或 {\Delta_1, \Delta_2, \cdots, \Delta_n}.<br>$$<br>小区间 $\Delta_i$ 的长度为 $\Delta x_i = x_i - x_{i-1},$ 并记<br>$$<br>|T| = \max_{1\leq i \leq n} {\Delta x_i},<br>$$<br>称为分割 $T$ 的模。</p>
<p><strong>注意</strong>    由于 $\Delta x_i \leq |T|, i = 1, 2, \cdots, n,$ 因此 $|T|$ 可用来反应 $[a, b]$ 被分割的细密程度。另外，分割 $T$ 一旦给出，$|T|$ 就随之而确定；但是，具有同一细度 $|T|$ 的分割 $T$ 却有无限多个。</p>
<p><strong>定义</strong>    设 $f$ 是定义在 $[a, b]$ 上的一个函数，对于 $[a, b]$ 的一个分割 $T = {\Delta_1, \Delta_2, \cdots, \Delta_n}$，任取点 $\xi_i \in \Delta_i, i = 1,2,\cdots, n,$ 并作和式<br>$$<br>\sum^n_{i=1}f(\xi_i)\Delta x_i.<br>$$<br>称此和式为函数 $f$ 在 $[a, b]$ 上的一个积分和，也称为黎曼和。</p>
<p>有定义可知，积分和既与分割 $T$ 有关，又与所选取的点集 ${\xi_i}$ 有关。</p>
<p><strong>定义</strong>    设 $f$ 是定义在 $[a, b]$ 上的一个函数，$J$ 是一个确定的实数，若对任给的正数 $\varepsilon$, 总存在某一正数 $\delta$, 使得对 $[a, b]$ 的任何分割 $T$, 以及在其上任意选取的点集 ${\xi_i}$，只要 $|T| &lt; \delta$，就有<br>$$<br>\left | \sum^n_{i=1}f(\xi_i)\Delta x_i - J \right | &lt; \varepsilon,<br>$$<br>则称函数 $f$ 在区间 $[a, b]$ 上可积或黎曼可积；数 $J$ 称为 $f$ 在 $[a, b]$ 上的定积分或黎曼积分，记作<br>$$<br>J = \int^b_a f(x) \mathrm{d}x.<br>$$<br>其中， $f$ 称为被积函数，$x$ 称为积分变量，$[a, b]$ 称为积分区间，$a, b$ 分别称为这个定积分的下限和上限。</p>
<p>定积分的几何意义    对于 $[a, b]$ 上的连续函数 $f$，当 $f \geq 0, x\in[a,b]$ 时，定积分的几何意义就是该曲边梯形的面积；当 $f(x) \leq 0, x\in [a,b]$ 时，这时 $J = - \int^b_a [-f(x)] \mathrm{d}x$ 是位于 $x$ 轴下方的曲边梯形面积的相反数，不妨称之为“负面积”；对于一般非定号的 $f(x)$ 而言，定积分 $J$ 的值则是曲线 $y=f(x)$ 在 $x$ 轴上方部分所有曲边梯形的正面积与下方部分所有曲边梯形的负面积的代数和。</p>
<p><strong>注意</strong>    定积分作为积分和的极限，它的值只与被积函数 $f$ 和积分区间 $[a, b]$ 有关，而与积分变量所用的符号无关，即<br>$$<br>\int^b_a f(x) \mathrm{d}x = \int^b_a f(t) \mathrm{d}t = \int^b_a f(\theta) \mathrm{d} \theta.<br>$$</p>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>integral</tag>
      </tags>
  </entry>
  <entry>
    <title>方向导数和梯度</title>
    <url>/2020/07/26/directional-derivative-and-gradient/</url>
    <content><![CDATA[<p>方向导数 $D_{\boldsymbol{l}}f(\boldsymbol{x})$ 一般是对多元函数而言的，表示函数  $f(\boldsymbol{x})$ 沿着某一方向 $\boldsymbol{l}$ 在点 $\boldsymbol{x}$ 的导数。方向导数的大小表示函数沿着该方向 $\boldsymbol{l}$ 在点 $\boldsymbol{x}$ 的函数值的变化率。对于多元函数有无穷多个方向，但只有一个方向是使得函数在点 $\boldsymbol{x}$ 的变化率（增长率）最大，那就是梯度方向 $\nabla f$ （其中，$\nabla$ 表示 nabla symbol），有时也用记号 grad $f(\boldsymbol{x})$ 表示函数 $f(\boldsymbol{x})$ 在点 $\boldsymbol{x}$ 的梯度（gradient）向量。那为什么变化率最大的方向是梯度方向呢？下面给出解释，不是一般性，假设 $\boldsymbol{x} = (x, y)$ ，记这里假设是 $f(\boldsymbol{x})$ 二元函数。</p>
<a id="more"></a>

<h1 id="方向导数"><a href="#方向导数" class="headerlink" title="方向导数"></a>方向导数</h1><p>方向导数是一元函数导数概念推广到多元函数，在一元函数 $f(x)$ 中，导数 $f^{\prime}(x)$ 定义为<br>$$<br>f^{\prime}(x) = \lim_{\Delta x \to 0}\frac{f(x + \Delta x) - f(x)}{\Delta x }<br>$$<br>方向导数 $D_{\boldsymbol{l}}f(\boldsymbol{x})$ 定义为<br>$$<br>D_{\boldsymbol{l}}f(\boldsymbol{x}) = \lim_{\left |\boldsymbol{l} \right | \to 0}\frac{f(\boldsymbol{x} + \boldsymbol{l}) - f(\boldsymbol{x})}{\left | \boldsymbol{l} \right |}<br>$$<br>方向 $\boldsymbol{l}$ 表示与从 $\boldsymbol{x} = (x, y)$ 到 $\boldsymbol{x} + \Delta \boldsymbol{x} = (x + \Delta x, y + \Delta y)$ 的向量 $\Delta \boldsymbol{x} = (\Delta x, \Delta y)$ 同向的向量，因此，可以把定义式写成<br>$$<br>D_{\boldsymbol{l}}f(\boldsymbol{x}) = \lim_{\left | \Delta \boldsymbol{x} \right | \to 0} \frac{f(\boldsymbol{x} + \Delta \boldsymbol{x}) - f(\boldsymbol{x})}{\left | \Delta \boldsymbol{x} \right |}<br>$$<br>为了方便，记 $\left | \Delta \boldsymbol{x} \right | = \rho$ ，$\cos \alpha, \cos \beta$ 分别表示方向 $\boldsymbol{l}$ 与 $x, y$ 轴的夹角，那么当偏导数 $f_x, f_y$ 存在时，<br>$$<br>D_{\boldsymbol{l}}f(\boldsymbol{x}) = \lim_{\rho \to 0}\frac{f(x + \Delta x, y + \Delta y) - f(x, y)}{\rho} \\<br>= \lim_{\rho \to 0} \frac{f(x + \Delta x, y + \Delta y) - f(x, y + \Delta y) + f(x, y + \Delta y) - f(x, y)}{\rho} \\<br>= \lim_{\rho \to 0} \frac{f(x + \Delta x, y + \Delta y) - f(x, y + \Delta y)}{\rho} + \lim_{\rho \to 0} \frac{f(x, y + \Delta y) - f(x, y)}{\rho} \\<br>= \lim_{\rho \to 0} \frac{f(x + \Delta x, y + \Delta y) - f(x, y + \Delta y)}{\Delta x} \cdot \frac{\Delta x}{\rho} + \lim_{\rho \to 0} \frac{f(x, y + \Delta y) - f(x, y)}{\Delta y}\cdot \frac{\Delta y}{\rho} \\<br>= f_x \cos \alpha + f_y \cos \beta = (f_x, f_y) \cdot (\cos \alpha, \cos \beta) = (f_x, f_y)\cdot \Delta \boldsymbol{x}/\rho<br>$$<br>上面推导表示，方向导数可以利用偏导数表示。</p>
<h1 id="梯度方向"><a href="#梯度方向" class="headerlink" title="梯度方向"></a>梯度方向</h1><p>方向导数有正有负，那么何时取得最大值呢？<br>$$<br>\left | D_{\boldsymbol{l}}f(\boldsymbol{x}) \right | = \left | (f_x, f_y)\cdot (\cos \alpha, \cos \beta) \right | = \left | (f_x, f_y) \right | \left | (\cos \alpha, \cos \beta) \right |\cos \gamma \leq \left | (f_x, f_y) \right |<br>$$<br>这里 $\left | (\cos \alpha, \cos \beta) \right | = \sqrt{\cos^2 \alpha + \cos^2 \beta} = 1$ ，角度 $\gamma$ 表示梯度向量 $\nabla f = (f_x, f_y)$ 与向量 $\boldsymbol{l}$ 同向单位向量 $\Delta \boldsymbol{x}/\rho = (\cos \alpha, \cos \beta)$ 之间的夹角。可以知道，当两者同向时方向导数取得最大值，反向时取得最小值。</p>
<h1 id="更多学习"><a href="#更多学习" class="headerlink" title="更多学习"></a>更多学习</h1><p><a href="https://www.cnblogs.com/bingjianing/p/9014246.html">导数、方向导数与梯度</a></p>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>gradient</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习的 GPU 环境的配置</title>
    <url>/2019/12/21/dl-gpu/</url>
    <content><![CDATA[<p>本篇介绍如何安装 nvidia drivers（GPU显卡驱动），cuda toolkit（GPU 通用并行计算架构） 和 cudnn（深度学习模型专用库），以 ubuntu18.04 为例，下载的软件选择 runfile(local) 版本。</p>
<a id="more"></a>

<h1 id="nvidia-drivers"><a href="#nvidia-drivers" class="headerlink" title="nvidia drivers"></a>nvidia drivers</h1><p>该模块就是安装显卡驱动。</p>
<p><a href="https://www.nvidia.com/content/DriverDownload-March2009/confirmation.php?url=/tesla/440.118.02/NVIDIA-Linux-x86_64-440.118.02.run&lang=us&type=Tesla">ubuntu18.04-nvidia drivers 10.2</a></p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ml/nvidia-driver.png"></p>
<p><font size=3 color=red><strong>其实该步骤安装可以省略，在安装 CUDA-TOOLKIT 时可同时选择安装驱动 NVIDIA-DRIVERS</strong> </font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装前需退出 X-SERVER</span></span><br><span class="line">sudo su</span><br><span class="line">sudo init 3</span><br><span class="line">sudo sh NVIDIA-Linux-x86_64-440.118.02.run</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当遇到安装失败时，可能是因为头文件缺少，运行下面代码即可</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install linux-headers-$(uname -r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看安装是否成功</span></span><br><span class="line">nvidia-smi</span><br><span class="line"><span class="comment"># nvidia-smi 全称是 NVIDIA System Management Interface，</span></span><br><span class="line"><span class="comment"># 基于 NVIDIA Management Library(NVML) 构建的命令行实用工具，</span></span><br><span class="line"><span class="comment"># 旨在帮助管理和监控 NVIDIA GPU 设备。</span></span><br></pre></td></tr></table></figure>

<p>还有一种方法是直接使用系统命令检测合适的 GPU 显卡驱动版本，安装最适合的驱动版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新系统</span></span><br><span class="line">sudo apt update </span><br><span class="line">sudo apt upgrade -y</span><br><span class="line"><span class="comment"># 检测</span></span><br><span class="line">nvidia-detector</span><br><span class="line"><span class="comment"># 图形界面安装</span></span><br><span class="line">打开 “Software and Updates”，安装相应驱动</span><br><span class="line"><span class="comment"># 或者命令行安装</span></span><br><span class="line">sudo apt install nvidia-driver-440</span><br><span class="line"><span class="comment"># 重启系统，使驱动生效</span></span><br><span class="line">sudo shutdown -r now</span><br></pre></td></tr></table></figure>

<p>卸载驱动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove --purge <span class="string">&#x27;^nvidia-.*&#x27;</span></span><br><span class="line">sudo apt autoremove</span><br></pre></td></tr></table></figure>



<h1 id="cuda-toolkit"><a href="#cuda-toolkit" class="headerlink" title="cuda toolkit"></a>cuda toolkit</h1><p>cuda (Compute Unified Device Architecture) 模块为并行计算的加速包。CUDA™是一种由NVIDIA推出的通用并行计算架构，该架构使GPU 能够解决复杂的计算问题。按照<a href="https://link.zhihu.com/?target=https://blogs.nvidia.com/blog/2012/09/10/what-is-cuda-2/">官方</a>的说法是，<strong>CUDA是一个并行计算平台和编程模型，能够使得使用GPU进行通用计算变得简单和优雅</strong>。</p>
<p><a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA Toolkit Archive</a></p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ml/cuda-toolkit.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/10.2/Prod/local_installers/cuda_10.2.89_440.33.01_linux.run</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常规安装</span></span><br><span class="line">sudo sh cuda_10.2.89_440.33.01_linux.run</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建议覆盖 (override) 安装，以免出错</span></span><br><span class="line">sudo sh cuda_10.2.89_440.33.01_linux.run --toolkit --silent --override</span><br></pre></td></tr></table></figure>

<p>在安装过程中截取其中比较重要的几个选择：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Do you accept the previously <span class="built_in">read</span> EULA?</span><br><span class="line">accept/decline/quit: accept</span><br><span class="line"></span><br><span class="line">Install NVIDIA Accelerated Graphics Driver <span class="keyword">for</span> Linux-x86_64 460.81?</span><br><span class="line">(y)es/(n)o/(q)uit: n <span class="comment"># 如果在这之前已经安装好更高版本的显卡驱动就不需要再重复安装，</span></span><br><span class="line"><span class="comment"># 如果需要重复安装就选择 yes,此外还需要关闭图形界面。</span></span><br><span class="line"></span><br><span class="line">Install the CUDA 10.2 Toolkit?</span><br><span class="line">(y)es/(n)o/(q)uit: y</span><br><span class="line"></span><br><span class="line">Enter Toolkit Location</span><br><span class="line"> [ default is /usr/<span class="built_in">local</span>/cuda-10.2 ]: <span class="comment"># 一般选择默认即可，也可以选择安装在其他目录，</span></span><br><span class="line"> <span class="comment"># 在需要用的时候指向该目录或者使用软连接 link 到 /usr/local/cuda。</span></span><br><span class="line"></span><br><span class="line">/usr/<span class="built_in">local</span>/cuda-10.2 is not writable.</span><br><span class="line">Do you wish to run the installation with <span class="string">&#x27;sudo&#x27;</span>?</span><br><span class="line">(y)es/(n)o: y</span><br><span class="line"></span><br><span class="line">Please enter your password: </span><br><span class="line">Do you want to install a symbolic link at /usr/<span class="built_in">local</span>/cuda? <span class="comment"># 是否将安装目录通过软连接的方式 link</span></span><br><span class="line"><span class="comment"># 到 /usr/local/cuda，yes or no 都可以，取决于你是否使用 /usr/local/cuda 为默认的 cuda 目录。</span></span><br><span class="line">(y)es/(n)o/(q)uit: n</span><br><span class="line"></span><br><span class="line">Install the CUDA 10.2 Samples?</span><br><span class="line">(y)es/(n)o/(q)uit: n</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看安装是否成功</span></span><br><span class="line">nvcc -V</span><br><span class="line"><span class="comment"># nvcc其实就是CUDA的编译器, 类似于gcc就是c语言的编译器</span></span><br></pre></td></tr></table></figure>

<p>卸载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最简单的方法</span></span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/cuda-10.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高级方法</span></span><br><span class="line"><span class="comment"># Uninstall just nvidia-cuda-toolkit</span></span><br><span class="line">sudo apt-get remove nvidia-cuda-toolkit</span><br><span class="line"></span><br><span class="line"><span class="comment"># Uninstall nvidia-cuda-toolkit and it&#x27;s dependencies</span></span><br><span class="line">sudo apt-get remove --auto-remove nvidia-cuda-toolkit</span><br><span class="line"></span><br><span class="line"><span class="comment"># Purging config/data</span></span><br><span class="line">sudo apt-get purge nvidia-cuda-toolkit </span><br><span class="line"><span class="comment"># or </span></span><br><span class="line">sudo apt-get purge --auto-remove nvidia-cuda-toolkit</span><br></pre></td></tr></table></figure>



<h1 id="cudnn"><a href="#cudnn" class="headerlink" title="cudnn"></a>cudnn</h1><p>cudnn 模块其实就是一个专门为深度学习计算设计的软件库，里面提供了很多专门的计算函数，如卷积等。</p>
<p>cudnn 下载时需要登录，下载对应的版本：<a href="https://developer.nvidia.com/rdp/cudnn-download">cudnn</a></p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ml/cudnn.jpeg"></p>
<p>然后，参考官网 <a href="https://docs.nvidia.com/deeplearning/cudnn/install-guide/index.html#installlinux">NVIDIA CUDNN DOCUMENTATION</a> 安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzvf cudnn-x.x-linux-x64-v8.x.x.x.tgz</span><br><span class="line">sudo cp cuda/include/cudnn*.h /usr/<span class="built_in">local</span>/cuda/include </span><br><span class="line">sudo cp -P cuda/lib64/libcudnn* /usr/<span class="built_in">local</span>/cuda/lib64 </span><br><span class="line">sudo chmod a+r /usr/<span class="built_in">local</span>/cuda/include/cudnn*.h /usr/<span class="built_in">local</span>/cuda/lib64/libcudnn*</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p>需要把 CUDA_HOME 添加到环境变量，一般CUDA_HOME=/usr/locdal/cuda-*/bin，我的配置如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CUDA_HOME=/usr/<span class="built_in">local</span>/cuda</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$&#123;CUDA_HOME&#125;</span>/lib64:<span class="variable">$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;</span>&#125;</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$CUDA_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li>所有都安装成功后，可以运行 <code>nvidia-smi</code> 和 <code>nvcc --version</code> 来检验是否完美安装</li>
</ol>
<h1 id="莫名-nvidia-smi-无法使用的解决方法"><a href="#莫名-nvidia-smi-无法使用的解决方法" class="headerlink" title="莫名 nvidia-smi 无法使用的解决方法"></a>莫名 nvidia-smi 无法使用的解决方法</h1><p>在平常使用时，偶尔会出现命令 nvidia-smi 无法使用的情况，这种一般是 Linux 内核更新导致的，一种解决方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装头文件</span></span><br><span class="line">sudo apt install linux-headers-$(uname -r)</span><br><span class="line"><span class="comment"># 查看当前安装的 nvidia 版本</span></span><br><span class="line">whereis nvidia</span><br><span class="line"><span class="comment"># 再次安装，如版本 440.33.01，请改成自己对于的版本号</span></span><br><span class="line">sudo dkms install -m nvidia -v 440.33.01</span><br></pre></td></tr></table></figure>



<h1 id="建议参考官网安装"><a href="#建议参考官网安装" class="headerlink" title="建议参考官网安装"></a>建议参考官网安装</h1><h2 id="NVIDIA-CUDA-Installation-Guide-for-Linux"><a href="#NVIDIA-CUDA-Installation-Guide-for-Linux" class="headerlink" title="NVIDIA CUDA Installation Guide for Linux"></a><a href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html#abstract">NVIDIA CUDA Installation Guide for Linux</a></h2><p><a href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html#post-installation-actions">https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html#post-installation-actions</a></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://benpaodewoniu.github.io/2019/12/07/nvidia0/">gpu 的驱动，cuda，cudnn的关系</a></li>
<li><a href="https://www.cnblogs.com/whenyd/p/7787447.html">Ubuntu下安装CUDA</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/91334380">显卡，显卡驱动,nvcc, cuda driver,cudatoolkit,cudnn到底是什么？</a></li>
<li><a href="https://itectec.com/ubuntu/ubuntu-removing-nvidia-cuda-toolkit-and-installing-new-one/">Ubuntu – Removing Nvidia CUDA Toolkit and installing new one</a></li>
<li><a href="https://www.cnblogs.com/carle-09/p/11363020.html"><strong>Ubuntu系统—系统驱动丢失、Kernel内核卸载、禁止更新</strong></a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>dl</tag>
        <tag>gpu</tag>
        <tag>cuda</tag>
        <tag>nvcc</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 简单介绍</title>
    <url>/2020/11/05/docker-simple/</url>
    <content><![CDATA[<p>docker 容器技术使得开发测试非常方便，自2013年发布至今，一直广受瞩目。软件开发最大的麻烦事之一，就是环境配置。虚拟机虽然能够解决上面问题，但是有如下缺点：1.<strong>资源占用多</strong>，2.<strong>冗余步骤多</strong>，3. <strong>启动慢</strong>；由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。<strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong>或者说，在正常进程的外面套了一个<a href="https://opensource.com/article/18/1/history-low-level-container-runtimes">保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。由于容器是进程级别的，相比虚拟机有很多优势。1.<strong>启动快</strong>, 2,<strong>资源占用少</strong>,3.<strong>体积小</strong>.总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。<strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。下面介绍2020年08月以后，如何安装使用docker，本篇以 Windows 10 wsl 2 Ubuntu-20.04 为例。</p>
<a id="more"></a>

<h1 id="Docker-的主要用途，目前有三大类。"><a href="#Docker-的主要用途，目前有三大类。" class="headerlink" title="Docker 的主要用途，目前有三大类。"></a>Docker 的主要用途，目前有三大类。</h1><p><strong>（1）提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p>
<p><strong>（2）提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p>
<p><strong>（3）组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p>
<h1 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment"># 安装 apt 依赖包，用于通过HTTPS来获取仓库</span></span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br><span class="line"><span class="comment"># 添加 Docker 的官方 GPG 密钥：</span></span><br><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="comment"># 验证秘钥</span></span><br><span class="line">sudo apt-key fingerprint 0EBFCD88</span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">&quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">  stable&quot;</span></span><br><span class="line"> </span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br><span class="line">sudo service docker status</span><br><span class="line">sudo service docker restart</span><br><span class="line"><span class="comment"># 把常用用户添加到docker组，这样运行docker命令时不需要添加sudo，但需重启终端。注意，service命令时仍然需要sudo</span></span><br><span class="line">sudo usermod -a -G docker jinzhongxu</span><br><span class="line">sudo docker run hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证是否安装成功。查看版本信息</span></span><br><span class="line">docker version</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>

<h1 id="docker使用"><a href="#docker使用" class="headerlink" title="docker使用"></a>docker使用</h1><p>因某些原因，需要给docker添加国内镜像，方法如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 添加如下内容</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://registry.docker-cn.com&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;https://cr.console.aliyun.com/&quot;</span>],</span><br><span class="line">  <span class="string">&quot;insecure-registries&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;debug&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;experimental&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">docker pull tensorflow/tensorflow:latest</span><br></pre></td></tr></table></figure>

<h1 id="image"><a href="#image" class="headerlink" title="image"></a>image</h1><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从 docker 官方拉取 image 文件 hello-world</span></span><br><span class="line">docker image pull hello-world</span><br><span class="line"><span class="comment"># 运行这个 image 文件。该命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的 docker image pull 命令并不是必需的步骤。</span></span><br><span class="line">docker container run hello-world</span><br><span class="line"><span class="comment"># 查看下载到本地的镜像文件</span></span><br><span class="line">docker image ls</span><br><span class="line"><span class="comment"># 为本地的 image 标注用户名和版本。username 为 hub.docker.com 或 cloud.docker.com 注册的账户</span></span><br><span class="line">docker image tag (IMAGE ID) (username)/(repository):(tag)</span><br><span class="line"><span class="comment"># 也可以不标注用户名，重新构建一下 image 文件。</span></span><br><span class="line">docker image build -t (username)/(repository):(tag) .</span><br><span class="line"><span class="comment"># 发布 image 文件。</span></span><br><span class="line">docker image push (username)/(repository):(tag)</span><br><span class="line"><span class="comment"># 删除不需要的本地镜像文件</span></span><br><span class="line">docker image rm (IMAGE ID)</span><br></pre></td></tr></table></figure>

<h1 id="container"><a href="#container" class="headerlink" title="container"></a>container</h1><p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器(Container)文件。</strong>也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line">docker container ls</span><br><span class="line"><span class="comment"># 查看所有运行过的容器，包括正在运行的和停止运行的</span></span><br><span class="line">docker ps -a</span><br><span class="line">docker container ls -all</span><br><span class="line"><span class="comment"># 把运行的容器关闭. 相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</span></span><br><span class="line">docker stop &#123;CONTAINER ID&#125;</span><br><span class="line">docker container stop &#123;CONTAINER ID&#125;</span><br><span class="line"><span class="comment"># 把运行的容器关闭. 相当于向容器里面的主进程发出 SIGKILL 信号</span></span><br><span class="line">docker <span class="built_in">kill</span> &#123;CONTAINER ID&#125;</span><br><span class="line">docker container <span class="built_in">kill</span> &#123;CONTAINER ID&#125;</span><br><span class="line"><span class="comment"># 把停止运行的容器打开</span></span><br><span class="line">docker start &#123;CONTAINER ID&#125;</span><br><span class="line">docker container start &#123;CONTAINER ID&#125;</span><br><span class="line"><span class="comment"># 查看 docker 容器的输出，即容器里面 Shell 的标准输出。</span></span><br><span class="line">docker container logs &#123;CONTAINER ID&#125;</span><br><span class="line"><span class="comment"># 从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</span></span><br><span class="line">docker container cp &#123;CONTAINER ID&#125;:&#123;/path/to/file&#125; .</span><br><span class="line"><span class="comment"># 进入运行中的ubuntu容器</span></span><br><span class="line"><span class="comment"># 推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。</span></span><br><span class="line"><span class="comment"># 使用 docker attach &#123;CONTAINER ID&#125;，当退出容器终端时，将导致容器停止。</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &#123;CONTAINER ID&#125; /bin/bash</span><br><span class="line"><span class="comment"># 以后台（-d）方式打开新的容器并命名</span></span><br><span class="line">docker run -itd --name=<span class="string">&#x27;centos&#x27;</span> &#123;IMAGE ID&#125; /bin/bash</span><br><span class="line"><span class="comment"># 删除不需要的容器</span></span><br><span class="line">docker container rm &#123;CONTAINER ID&#125;</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<ol>
<li>CONTAINER ID 和 IMAGE ID 只需要输入前几个字符，只要能够唯一识别它们；</li>
<li>docker image 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。image 文件可以看作是容器的模板；</li>
<li>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image；</li>
<li>一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作；</li>
</ol>
<h1 id="制作docker-image"><a href="#制作docker-image" class="headerlink" title="制作docker image"></a>制作docker image</h1><p>需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p>
<p>首先，克隆项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/xxx/demos.git</span><br><span class="line"><span class="built_in">cd</span> demos</span><br></pre></td></tr></table></figure>

<p>在项目的根目录下，新建一个文本文件<code>.dockerignore</code>, 把要排除的文件或文件夹路径按行写到文件里，参考如下，即说明那些不需要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure>

<p>在项目的根目录下，新建一个文本文件 Dockerfile，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM node:11</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br><span class="line">CMD node demos/01.js</span><br></pre></td></tr></table></figure>

<p>说明如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM node:11：该 image 文件继承官方的 node image，冒号表示标签，这里标签是 11，即 11 版本的 node。</span><br><span class="line">COPY . /app：将当前目录下的所有文件（除了.dockerignore 排除的路径），都拷贝进入 image 文件的/app目录。</span><br><span class="line">WORKDIR /app：指定接下来的工作路径为 /app。</span><br><span class="line">RUN npm install：在/app目录下，运行 npm install 命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</span><br><span class="line">EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。</span><br><span class="line">CMD node demos/01.js：表示容器启动后自动执行 node demos/01.js。RUN命令与CMD命令的区别在哪里？简单说，RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个 RUN 命令，但是只能有一个 CMD 命令。注意，指定了 CMD 命令以后，docker container run 命令就不能附加命令了（比如前面的 /bin/bash），否则它会覆盖 CMD 命令。</span><br></pre></td></tr></table></figure>

<p>创建 image 文件. 有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image build -t demo .</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker image build -t demo:0.0.1 .</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latest</code>。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</p>
<p>如果运行成功，就可以看到新生成的 image 文件<code>demo</code>了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure>

<p>发布 image 的命令参考上面。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><p><a href="https://www.cnblogs.com/StivenYang/p/13843397.html">docker国内镜像源</a></p>
</li>
<li><p><a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a></p>
</li>
<li><p><a href="https://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html">Docker 微服务教程</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>无人驾驶6个等级划分</title>
    <url>/2021/06/22/driving-autonomous-classification/</url>
    <content><![CDATA[<p>美国汽车工程师学会 (<a href="https://www.sae.org/standards/content/j3016_201806/">SAE</a>) 定义了6个无人驾驶等级 — 从 0 级（完全手动）到 5 级（完全自动）。这些无人驾驶等级准则已经被美国交通部采纳。 </p>
<a id="more"></a>

<p><img src="https://www.synopsys.com/content/dam/synopsys/solutions/images/cs327718450-automotive-levels-infographic-v4.jpg.imgw.850.x.jpg"></p>
<h1 id="0-级（无自动驾驶）"><a href="#0-级（无自动驾驶）" class="headerlink" title="0 级（无自动驾驶）"></a>0 级（无自动驾驶）</h1><p>在当今的道路上行驶的大多数汽车都是 0 级：手动控制。由人来完成”动态驾驶任务”，尽管可能有相应的系统来辅助驾驶员，例如紧急制动系统，但从技术方面来讲，该辅助系统并未主动”驱动”车辆，所以算不上自动化驾驶。 </p>
<h1 id="1-级（驾驶员辅助）"><a href="#1-级（驾驶员辅助）" class="headerlink" title="1 级（驾驶员辅助）"></a>1 级（驾驶员辅助）</h1><p>这是自动化的最低级别。车辆具有单独的自动化驾驶员辅助系统，例如转向或加速（巡航控制）。自适应巡航控制系统可以让车辆与前车保持安全距离，驾驶员负责监控驾驶的其他方面（例如转向和制动），因此符合 1 级标准。 </p>
<h1 id="2-级（部分自动驾驶）"><a href="#2-级（部分自动驾驶）" class="headerlink" title="2 级（部分自动驾驶）"></a>2 级（部分自动驾驶）</h1><p>这指的是高级驾驶员辅助系统或 ADAS。车辆能够控制转向以及加速或减速。因为有驾驶员坐在汽车座位上，并且可以随时控制汽车，所以这一阶段的自动驾驶还算不上无人驾驶。特斯拉的 Autopilot 和凯迪拉克的（通用汽车）Super Cruise 系统都符合 2 级标准。</p>
<h1 id="3-级（受条件制约的自动驾驶）"><a href="#3-级（受条件制约的自动驾驶）" class="headerlink" title="3 级（受条件制约的自动驾驶）"></a>3 级（受条件制约的自动驾驶）</h1><p>从技术角度来看，从 2 级到 3 级实现了重大飞跃，但从驾驶人员的角度来看，差别虽不是微不足道，却也算不上明显。</p>
<p>3 级无人驾驶汽车具有“环境检测”能力，可以自己根据信息做出决定，例如加速经过缓慢行驶的车辆。但是这个级别仍然需要人类操控。驾驶员必须保持警觉，并且在系统无法执行任务时进行操控。</p>
<p>差不多两年前，奥迪（大众汽车）宣布下一代 A8（奥迪旗舰轿车）将成为世界上第一款量产的 3 级无人驾驶汽车。他们的确做到了。奥迪 A8L 将于 2019 年秋季驶入经销市场。奥迪 A8L 采用 Traffic Jam Pilot 技术，该技术结合了激光雷达扫描仪以及先进的传感器融合和处理能力（如果某一组件发生故障，还可以使用内置冗余）。</p>
<p>然而，虽然奥迪正在开创汽车驾驶技术的奇迹，但美国在这方面的监管程序，已经从联邦层面的指导准则，转变为各州针对自动驾驶汽车制定不同的要求。所以目前 A8L 在美国<a href="https://www.cnet.com/roadshow/news/2019-audi-a8-level-3-traffic-jam-pilot-self-driving-automation-not-for-us/">仍被归类为 2 级</a> 无人驾驶汽车，并且在交车时不提供达到 3 级功能所需的关键硬件和软件。然而在欧洲，奥迪将在德国首先推出带有 Traffic Jam Pilot 技术的真正 3 级无人驾驶汽车 A8L。 </p>
<h1 id="4-级（高度自动驾驶）"><a href="#4-级（高度自动驾驶）" class="headerlink" title="4 级（高度自动驾驶）"></a>4 级（高度自动驾驶）</h1><p>3 级和 4 级自动化之间的关键区别在于，如果发生意外或系统失效，4 级自动驾驶汽车可以进行干预。从这个意义上来说，这些汽车<em>在大多数情况下</em>不需要人为干预。但是，驾驶员仍然可以选择手动超控。</p>
<p>4 级自动驾驶汽车可以采用无人驾驶模式运行。但由于立法和基础设施发展欠缺，4 级无人驾驶汽车只能在限定区域行驶（通常是在城市路况，最高平均速度达 30 英里/小时）。这被称之为地理围栏（geofencing）。因此，现有的大多数 4 级自动驾驶汽车都面向共享出行领域。例如：</p>
<ul>
<li><a href="https://www.motorauthority.com/news/1118809_navya-already-sells-fully-self-driving-cars-including-in-us">NAVYA</a> ，一家法国公司，已经在美国建造和销售 4 级自动驾驶纯电动班车和出租车，最高时速可达 55 mph。</li>
<li>Alphabet 的 <a href="https://www.reuters.com/article/us-waymo-selfdriving-focus/waymo-unveils-self-driving-taxi-service-in-arizona-for-paying-customers-idUSKBN1O41M2">Waymo</a> 一直在亚利桑那州测试无人驾驶汽车，至今已超过一年，路测行程已达到 1000 万英里以上，最近推出了 4 级无人驾驶出租车服务，车内不设任何安全驾驶员。</li>
<li>加拿大汽车供应商 <a href="https://www.magna.com/insights/article/max4-magna-s-formula-for-winning-the-self-driving-car-race">Magna</a> 开发的 MAX4 自动驾驶技术，可在城市和高速公路环境中实现高达 4 级的自动驾驶功能。他们正在与 Lyft 合作，提供将普通车转化为自动驾驶车型的高科技套件。</li>
<li>就在几个月前，<a href="https://www.autonews.com/article/20181101/MOBILITY/311019997/volvo-baidu-team-up-for-level-4-autonomous-evs-in-china">沃尔沃和百度</a>宣布建立战略合作伙伴关系，共同开发 4 级电动汽车，为中国的自动驾驶出租车市场提供服务。</li>
</ul>
<h1 id="5-级（完全自动驾驶）"><a href="#5-级（完全自动驾驶）" class="headerlink" title="5 级（完全自动驾驶）"></a>5 级（完全自动驾驶）</h1><p>5 级自动驾驶汽车不需要人为关注，从而免除了“动态驾驶任务”。5 级自动驾驶汽车甚至都不会有方向盘或加速/制动踏板。他们将不受地理围栏限制，能够去任何地方并完成任何有经验的人类驾驶员可以完成的操控。完全自动驾驶的汽车正在世界各地的几个试点区进行测试，但尚未向公众提供。向公众提供这一服务尚需数年时间。但是可以想象一下，您上车后，说”送我去上班”，剩下的事情就交给汽车来处理，与此同时，您可以润色一下演讲、在 Netflix 上煲剧或者整理下发型，真是太奇妙了。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://www.synopsys.com/zh-cn/automotive/autonomous-driving-levels.html">我的无人车现在处于哪一阶段？ 了解6个无人驾驶等级</a></li>
</ol>
]]></content>
      <categories>
        <category>research</category>
        <category>object tracking</category>
      </categories>
      <tags>
        <tag>cv</tag>
        <tag>object tracking</tag>
      </tags>
  </entry>
  <entry>
    <title>Canny 图像边缘检测算法</title>
    <url>/2021/05/24/edge-detection-canny/</url>
    <content><![CDATA[<p>图像边缘检测（Edge Detection）作为图像处理和计算机数据的基本问题，其<strong>目的</strong>是识别数字图像中亮度变化明显的点。图像中这些显著变化的部分反映了重要事件或其他变化，包括深度上的不连续，表面方向的不连续，物质属性的改变和场景照明的变化等。<strong>图像边缘检测能够剔除认为不相关的信息，大幅度地减少数据量，同时保留图像重要的结构属性。</strong>有两类边缘检测方法，一类是基于查找（一阶），一类是基于零穿越（二阶）。（根本上基于数学分析中方法，查找方法是寻求梯度最大的点，零穿越是寻求拐点，即二阶导数为 0 的点）基于查找的方法通过寻找图像一阶导数中的最大和最小值来检测边界，通常是将边界定位在梯度最大的方向。基于零穿越的方法通过寻找图像二阶导数零穿越来寻找边界，通常是 Laplacian 过零点或者非线性差分表示的过零点。</p>
<a id="more"></a>

<p>常用的边缘检测算子有：</p>
<ul>
<li>一阶：Roberts Cross 算子, Prewitt 算子, Sobel 算子, Canny 算子，罗盘算子</li>
<li>二阶：Marr-Hildreth, 在梯度方向的二阶导数过零点。</li>
</ul>
<p><strong>Canny算子</strong>是最常用的边缘检测方法，图像边缘检测效果相对较优。</p>
<p>本篇主要介绍 Canny 图像边缘检测方法，因其作用的对象是数字图像，所以会简短介绍什么是数字图像处理、常见的数字图像分类、常用的边缘检测算子，最后重点介绍 Canny 边缘检测。</p>
<h1 id="数字图像处理"><a href="#数字图像处理" class="headerlink" title="数字图像处理"></a>数字图像处理</h1><p>数字图像处理（Digital Image Processing）是使用计算机处理图像成为更易于人类理解或需要的形式。常见的有，改善图示信息以便人类解释，优化图像存储、传输、表示，以便机器自动理解。具体的包括，人脸识别、车牌识别、图像边缘检测、图像目标分割、图像语义分割、视频目标跟踪等。</p>
<h1 id="数字图像分类"><a href="#数字图像分类" class="headerlink" title="数字图像分类"></a>数字图像分类</h1><p>数字图像是在计算机中以二维矩阵表示，每个元素都是数字像素灰度值，范围一般是 0 ~ 255. 常见的数字图像有二值图像、灰度图像、彩色图像等。</p>
<p><strong>二值图像</strong>（Binary Image）：每个像素的灰度值仅取 0 或 1，即分别是黑和白，因此可以理解为黑白图像。</p>
<p><strong>灰度图像</strong>（Gray Scale Image）：每个像素的灰度值取值于 0 ~ 255，0 表示纯黑，255 表示纯白，其他值表示由黑到白的渐变色。</p>
<p><strong>彩色图像</strong>（Color Image）：同灰度图像，但是是有三幅灰度图像层叠在一起组成，分别表示红（R）、绿（G）、蓝（B）三通道。</p>
<p>把彩色图像转化为灰度图像可以通过只选择三通道中的一个，也可以通过三通道对应位置进行加权平均计算得到，常用的加权系数有：</p>
<ol>
<li><font size=3 color=red> G = 0.299 R + 0.587 G + 0.114 B </font></li>
<li><font size=3 color=green> G = 0.2126 R + 0.7152 G + 0.0722 B </font></li>
<li><font size=3 color=blue> G = 0.2627 R + 0.6780 G + 0.0593 B </font></li>
</ol>
<p>这些系数大多是基于人类对三种基准色的感官接收能力而定的。</p>
<h1 id="像素邻域"><a href="#像素邻域" class="headerlink" title="像素邻域"></a>像素邻域</h1><p>既然数字图像是有像素（矩阵中的数值）组成，那么类似于矩阵，每个元素都有邻域元素，因此，数字图像像素也有像素邻域。常使用的邻域有：<strong>4 邻域、D 邻域和 8 邻域</strong>。</p>
<p>4 邻域：某个像素的上、下、左、右最邻近的像素点组成的 4 个像素集合；</p>
<p>D 邻域：某个像素的左上、左下、右上、右下最邻近的像素点组成的 4 个像素集合；</p>
<p>8 邻域：某个像素的 4 邻域和 D 邻域组成的 8 个像素集合；</p>
<h1 id="图像滤波"><a href="#图像滤波" class="headerlink" title="图像滤波"></a>图像滤波</h1><p>常指的图像滤波是在保留图像细节特征的条件下对目标图像噪声进行抑制，作为图像预处理不可缺少的操作，结果直接影响后续图像处理和分析的有效性和可靠性。</p>
<p>当把数字图像的某一行取出后，其可以看作一个时间序列或波，同样，整幅图像也可以看作一种波，图像中亮度突变的部分就是高频部分，平滑的部分就是低频部分。对图像进行低通滤波就是使图像变得更平滑，滤除突变部分（包括噪声），图像变得模糊；对图像进行高通滤波就是提取图像的高频部分，只保留那些变化最快速最剧烈的区域，如边缘检测。</p>
<p>可通过<a href="https://fellipe.com/demos/lena-js/">在线网址</a>进行图像滤波演示。浏览器实现滤波的范例代码，可以看这个<a href="https://github.com/rssilva/web-audio-image-filtering">仓库</a>。</p>
<p>因此，广义的图像滤波不仅指消除图像噪声，还指通过滤波进行图像特征提取，简化图像信息，便于后续图像处理。</p>
<p>数字图像是二维数字矩阵，常用的滤波器（filter）也是一个二维数字矩阵，一般常取 $3\times 3$ 或 $5 \times 5$，奇数是为了保证中心点唯一，此时滤波器的半径分别是 1 和 2. 如深度学习中卷积神经网络中的卷积核就是一种滤波器，但是，其取值是通过大量图像数据经过反向传播学习得到的。本节介绍的边缘检测中使用的滤波器的每一个元素值是固定的，根据人们研究推断出来的。由此可看出，深度学习依据大数据学习得到合适的滤波器（模型参数），而传统的数字图像处理依据经验选择的滤波器。</p>
<h1 id="边缘检测和常用滤波器"><a href="#边缘检测和常用滤波器" class="headerlink" title="边缘检测和常用滤波器"></a>边缘检测和常用滤波器</h1><p>边缘检测是一种提取图像高频信息的过程，因此是一种图像高通滤波算法。如何得到滤波器呢？</p>
<h2 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h2><p>既然边缘检测是提取高频部分，那么就需要通过一种手段描述高频部分，然后提取。把图像的某一行单独拿出来可以看作是一个函数曲线在自然数点上的采样，高频部分对应着导数绝对值比较大的部分。具体到图像上，就是使用差分近似导数。因为数字图像是二维的，所以有两个方向的导数，分别是 $x,y$，坐标原点是图像左上角，向下为 $y$ 轴，向右为 $x$ 轴。某一点的高频信息就使用该点在 $x,y$ 方向上的梯度来表示，梯度的模或大小是 $x,y$ 两方向导数的平方和再取平方根。梯度的方向是于 $x$ 轴的夹角。数学公式如下</p>
<p>假设某像素点 $P(x,y)$ 在 $x,y$ 方向的导数（差分）是<br>$$<br>d_x, d_y<br>$$<br>那么该点的梯度大小是<br>$$<br>G(x,y) = \sqrt{d_x^2 + d_y^2}<br>$$<br>梯度的方向是<br>$$<br>\theta = \arctan(\frac{d_y}{d_x})<br>$$<br>那么如何计算某像素点处导数或差分呢？常采用该像素 4 邻域或 8 邻域来计算得到，系数值组成滤波器，如下面的</p>
<p>Roberts 算子<br>$$<br>s_x =<br>\left [<br>\begin{matrix}<br>1 &amp; 0 \\<br>0 &amp; -1<br>\end{matrix}<br>\right],<br>s_y =<br>\left[<br>\begin{matrix}<br>0 &amp; -1 \\<br>1 &amp; 0<br>\end{matrix}<br>\right]<br>$$<br>Prewitt 算子<br>$$<br>s_x =<br>\left[<br>\begin{matrix}<br>-1 &amp; 0 &amp; 1 \\<br>-1 &amp; 0 &amp; 1 \\<br>-1 &amp; 0 &amp; 1<br>\end{matrix}<br>\right],<br>s_y =<br>\left[<br>\begin{matrix}<br>1 &amp; 1 &amp; 1 \\<br>0 &amp; 0 &amp; 0 \\<br>-1 &amp; -1 &amp; -1<br>\end{matrix}<br>\right]<br>$$<br>Sobel 算子<br>$$<br>s_x =<br>\left[<br>\begin{matrix}<br>1 &amp; 0 &amp; -1 \\<br>2 &amp; 0 &amp; -2 \\<br>1 &amp; 0 &amp; -1<br>\end{matrix}<br>\right],<br>s_y =<br>\left[<br>\begin{matrix}<br>1 &amp; 2 &amp; 1 \\<br>0 &amp; 0 &amp; 0 \\<br>-1 &amp; -2 &amp; -1<br>\end{matrix}<br>\right]<br>$$<br>使用检测算子对图像进行滤波的方法类似卷积神经网络，对于每一个像素，将滤波器矩阵的中心对应图像像素点，依次计算对应位置的矩阵元素乘积，然后将结果加到一起，得到该像素的滤波值。特别的对于边界点，超出边界部分填报 0. 计算后的图像和原图像同尺寸。</p>
<p>Sobel 算子 $s_x$ 表示检测 $x$ 轴方向边缘，计算得到 $x$ 轴方向的梯度，注意此时的边界方向应是垂直于 $x$ 轴，即 $y$ 轴，即梯度方向与边界方向垂直。</p>
<p>同理，Sobel 算子 $s_x$ 表示检测 $y$ 轴方向边缘，计算得到 $y$ 轴方向的梯度，注意此时的边界方向应是垂直于 $y$ 轴，即 $x$ 轴，即梯度方向与边界方向垂直。</p>
<p>注意，当计算的梯度值超出范围 $[0, 255]$ 时，常采用取绝对值。</p>
<p>同时，可以看到，简单的采用 Sobel 算子得到的梯度值图像（滤波后的图像）容易受噪声像素点的影响（可以考虑先滤波噪声，即低通滤波），也没有对结果进行后续处理，因为边缘信息可能很多不连续，断断续续比较多。</p>
<h1 id="Canny-图像边缘检测"><a href="#Canny-图像边缘检测" class="headerlink" title="Canny 图像边缘检测"></a>Canny 图像边缘检测</h1><p>针对上述问题，1986年澳洲计算机科学家 John F. Canny 在文章 <a href="https://d1wqtxts1xzle7.cloudfront.net/64038952/1-with-cover-page.pdf?Expires=1621929742&Signature=DySBlI-DHonzdLJ4-fCcxxbKhOOjIwEU6XE~BNMzOhTJVgJ4einc1Z-ZAHaQFPXaTofZ6itdQRM6aaJTlTwIApmTgzOwoqqxmX8kYpwUrNUcn5NfvvN13B4wlkZAVzS9-buGypk1rW5yG96annqytQfg6YrVqEd2IWo~iBa2KsV0FqB9fXiFbjyN0aCrJHSGJE-c6qJ9Mb~2cDYgZ067J27oorXDZpFbvK21CmvexjWY7t7doZHf4-vWB~Peuy3MZLUxOfdps72zJ3dBUeeuRg8zvu-Sy~ha4JoqdQ9Ml--qsQpaRlGD8I~mHnmDOzSuRQGgXepebhY0qazy-xlGRQ__&Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA">A Computational Approach to Edge Detection</a> 中提出最优的边缘检测应该能够满足如下标准：</p>
<ol>
<li><strong>好的检测</strong> - 算法能够尽可能多地标识出图像中的实际边缘；</li>
<li><strong>好的定位</strong> - 标识出的边缘要与实际图像中的实际边缘尽可能接近；</li>
<li><strong>最小响应</strong> - 图像中的边缘只能标识一次，并且可能存在的图像杂讯不应标识为边缘。</li>
</ol>
<p>基于上面的三大标准，Canny 提出 5 步骤边缘检测算法，Canny 算子</p>
<ol>
<li>首先利用高斯（低通）滤波器平滑图像，去除噪声；</li>
<li>其次利用 Sobel 算子计算像素梯度；</li>
<li>然后利用非最大抑制（Non-Maximum Suppression）消除边缘虚假信息，即“瘦边”；</li>
<li>再然后利用双阈值确定潜在边缘；</li>
<li>最后利用滞后（Hysteresis）跟踪边缘，即抑制弱边缘和未连接到强边缘的边缘。</li>
</ol>
<p>Canny算子不容易受噪声干扰，得到的边缘精细且准确，缺点就是运算代价较高，运行于实时图像处理较困难，<strong>适用于高精度要求的应用</strong></p>
<h2 id="高斯低通滤波器-（Gaussian-filter）"><a href="#高斯低通滤波器-（Gaussian-filter）" class="headerlink" title="高斯低通滤波器 （Gaussian filter）"></a>高斯低通滤波器 （Gaussian filter）</h2><p><strong>解决噪声影响</strong></p>
<p>高斯滤波器也有称高斯模糊，是一种图像模糊滤波器，它用正态分布计算图像中每个像素的变换，二维空间中定义如下：<br>$$<br>G(x, y) = \frac{1}{2 \pi \sigma^2} e^{-(x^2 + y^2) / (2 \sigma^2)}<br>$$<br>离散化得到 $(2r + 1) \times (2r + 1)$ 的高斯核公式如下<br>$$<br>H_{ij} = \frac{1}{2 \pi \sigma^2} \exp(- \frac{(i - (r + 1))^2 + (j - (r + 1))^2}{2 \sigma^2}); 1\leq i, j \leq (2r + 1)<br>$$<br>常用的高斯核有，当$\sigma = 1, r = 2$ 时<br>$$<br>H_5 = \frac{1}{159}<br>\left[<br>\begin{matrix}<br>2 &amp; 4 &amp; 5 &amp; 4 &amp; 2 \\<br>4 &amp; 9 &amp; 12 &amp; 9 &amp; 4 \\<br>5 &amp; 12 &amp; 15 &amp; 12 &amp; 5 \\<br>4 &amp; 9 &amp; 12 &amp; 9 &amp; 4 \\<br>2 &amp; 4 &amp; 5 &amp; 4 &amp; 2<br>\end{matrix}<br>\right]<br>$$</p>
<h2 id="图像梯度-（Finding-the-intensity-gradient-of-the-image）"><a href="#图像梯度-（Finding-the-intensity-gradient-of-the-image）" class="headerlink" title="图像梯度 （Finding the intensity gradient of the image）"></a>图像梯度 （Finding the intensity gradient of the image）</h2><p><strong>找到边界点</strong></p>
<p>经过高斯平滑后，能够消除噪声影响，再进行边缘检测将会容易些。通过 Sobel 算子计算图像上每个像素的梯度值和梯度方向。</p>
<h2 id="非最大抑制-（Gradient-magnitude-thresholding-or-lower-bound-cut-off-suppression）"><a href="#非最大抑制-（Gradient-magnitude-thresholding-or-lower-bound-cut-off-suppression）" class="headerlink" title="非最大抑制 （Gradient magnitude thresholding or lower bound cut-off suppression）"></a>非最大抑制 （Gradient magnitude thresholding or lower bound cut-off suppression）</h2><p><strong>解决边缘粗、宽</strong></p>
<p>由上面可以，梯度方向是与 $x$ 轴的夹角，取值在 $[0, 360]$，Canny 将梯度方向依据 8 邻域分成 4 类，对角组成一类，因此每一类是 $360 / 4 = 90$ 度，每个角 45 度，如下图所示（图片引自知乎@程事在人）</p>
<p><img src="https://pic2.zhimg.com/80/v2-d0712c8a0b6aaea4d84fe45f454d0109_720w.jpg"></p>
<p>中心红点为当前像素位置 $(i, j)$，四面八方的黄点为 8 邻域像素位置，$x$ 轴上面划分为 1, 2, 3, 4 区域，下面也是，对角区域相同标识。假设当前像素点的梯度值是 $(g_x(i, j), g_y(i, j))$，梯度模或大小是 $g_{xy}(i, j)$，梯度方向指向上区域 1，负梯度方向指向下区域 1，对于上区域 1，计算上参照点 $g_{up}(i, j)$，比例因子是 $t = \frac{|g_y(i, j)|}{|g_x(i, j)|}$ ，如下计算<br>$$<br>g_{up}(i, j) = (1 - t) g_{xy}(i, j + 1) + t g_{xy}(i - 1, j + 1)<br>$$<br>类似的，计算下参照点 $g_{down}(i, j)$ 如下<br>$$<br>g_{down}(i, j) = (1 - t) g_{xy}(i, j - 1) + tg_{xy}(i + 1, j -1)<br>$$<br>然后，比较 $g_{xy}(i, j)$ 与 $g_{up}(i, j), g_{down}(i, j)$ 之间的大小，规则如下：</p>
<p>如果 $g_{xy}(i, j) \geq \max{g_{up}(i, j), g_{down}(i, j)}$ ，那么 $g_{xy}(i, j)$ 可能是边，否则，应该被抑制，令 $g_{xy}(i, j) = 0$. 注意，当 $g_x(i, j) = g_y(i, j) = 0$ 时，说明像素点不是边缘点。</p>
<h2 id="双阈值-（Double-threshold）"><a href="#双阈值-（Double-threshold）" class="headerlink" title="双阈值 （Double threshold）"></a>双阈值 （Double threshold）</h2><p><strong>解决定位不准</strong></p>
<p>上面三步已经能够大体给出边缘轮廓，但是，仍然存在一些伪边缘，当使用单一阈值截断时，容易导致边缘不连续。</p>
<p>当梯度值大于等于高阈值时，认为是强边缘；当梯度值小于低阈值时，认为是伪边缘，直接丢弃；对于大于等于低阈值，小于高阈值的边缘点，认为是弱边缘点，进行下一步处理。</p>
<h2 id="滞后跟踪边缘-（Edge-tracking-by-hysteresis）"><a href="#滞后跟踪边缘-（Edge-tracking-by-hysteresis）" class="headerlink" title="滞后跟踪边缘 （Edge tracking by hysteresis）"></a>滞后跟踪边缘 （Edge tracking by hysteresis）</h2><p><strong>解决间断点多</strong></p>
<p>经过双阈值判定后，强阈值边缘作为真正的边缘，对于弱边缘还需要进一步的判断是否保留和丢弃。依据的规则是：</p>
<p>对于弱边缘像素，如果其 8 邻域像素中包含强边缘像素，则其为边缘点，否则不是，将赋值为 0，抑制。</p>
<p>强边缘像素肯定应该包含在最终边缘图像中，因为它们是从图像的真实边缘中提取的。但是，关于弱边缘像素会有一些争论，因为这些像素可以从真实边缘提取，也可以从噪声/颜色变化中提取。为了获得准确的结果，应消除由后一种原因引起的薄弱边缘。通常，在未连接噪声响应的情况下，由真实边缘引起的弱边缘像素将连接到强边缘像素。为了跟踪边缘连接，通过查看弱边缘像素及其 8 个连接的邻域像素来进行斑点分析。只要斑点中包含一个强边缘像素，该弱边缘点就可以被识别为应该保留的边缘点。</p>
<h1 id="OpenCV-边缘检测"><a href="#OpenCV-边缘检测" class="headerlink" title="OpenCV 边缘检测"></a>OpenCV 边缘检测</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&quot;./data/beautiful.jpeg&quot;</span>)  <span class="comment"># BGR 格式 </span></span><br><span class="line">img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)  <span class="comment"># 转化为灰度图像</span></span><br><span class="line">img_edge = cv2.Canny(img_gray, <span class="number">30</span>, <span class="number">100</span>, apertureSize=<span class="number">3</span>, L2gradient=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># img_gray 表示输入图像，注意应该是灰度图像</span></span><br><span class="line"><span class="comment"># 30 是低阈值，取值在 [0, 255]</span></span><br><span class="line"><span class="comment"># 100 是高阈值，取值在 [0, 255]</span></span><br><span class="line"><span class="comment"># apertureSize 表示高斯核大小</span></span><br><span class="line"><span class="comment"># L2gradient 表示计算梯度模时是否采用 L2，如果不是，则采用 L1</span></span><br><span class="line">plt.imshow(img_edge, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><p><a href="https://www.cnblogs.com/silence-cho/p/11070766.html">(五)OpenCV-Python学习—边缘检测1</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/0a256f6909a2">基于python的边缘检测的几种方法的效果对比及分析</a></p>
</li>
<li><p><a href="https://blog.csdn.net/jnulzl/article/details/47755071">openCV—Python(11)—— 图像边缘检测</a></p>
</li>
<li><p><a href="https://zj-image-processing.readthedocs.io/zh_CN/stable/opencv/[Canny]%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B.html">[Canny]边缘检测</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_29462849/article/details/81050212">Canny边缘检测算法解析</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/99959996">Canny边缘检测算法</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/42122107">Canny边缘检测算法</a></p>
</li>
<li><p><a href="https://lizonghang.github.io/2016/07/22/Canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/">Canny边缘检测</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/59640437">数字图像处理:边缘检测(Edge detection)</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2017/12/image-and-wave-filters.html">图像与滤波</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>research</category>
        <category>image segmentation</category>
      </categories>
      <tags>
        <tag>edge-detection</tag>
        <tag>Canny</tag>
        <tag>image-segmentation</tag>
      </tags>
  </entry>
  <entry>
    <title>把 EXCEL 表格转换为 LATEX 代码</title>
    <url>/2021/09/30/excel2latex/</url>
    <content><![CDATA[<p>使用 $\LaTeX$ 书写论文被越来越多的人采用，其主要的优势是让写作者不用在格式上花费太多的时间，把主要时间用在文章的内容写作上。我们平常处理的数据大多会以 EXCEL 表格的形式保存，那么如何将 EXCEL 表格中的数据快速复制到 $\LaTeX$ 源文件中呢，下面介绍一种工具，它能够非常快捷准确的将表格数据转化为  $\LaTeX$ 格式，并利用  $\LaTeX$ 中的包快速编译出表格信息。本篇默认 EXCEL 和 $\LaTeX$ 编译器已经安装且可使用。</p>
<a id="more"></a>

<h1 id="下载-Excel2LATEX"><a href="#下载-Excel2LATEX" class="headerlink" title="下载 Excel2LATEX"></a>下载 Excel2LATEX</h1><p>在 CTAN 官网上可以下载最新版的 Excel2LATEX: <a href="https://ctan.org/pkg/excel2latex">https://ctan.org/pkg/excel2latex</a>.</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>解压缩后，将文件夹放在一个自己喜欢的目录下，放好后该文件夹不应该移动或删除，点击文件：Excel2LaTeX.xla 并启用即可使用它。</p>
<p>如果想让 EXCEL 默认加载该程序，可以在 EXCEL 程序中点击文件—选项—加载项—转到—浏览（选择文件 Excel2LaTeX.xla）—方框内打勾—确定。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>利用 EXCEL 打开一个表格，选择表格内容，点击加载项，选择 convert table to latex，点击 copy to clipboard，将其粘贴到  $\LaTeX$ 源文件中。</p>
<p>在  $\LaTeX$ 源文件中头部添加包：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;booktabs&#125;</span></span></span><br><span class="line"># 处理对齐问题：<span class="tag">\<span class="name">toprule</span></span>， <span class="tag">\<span class="name">midrule</span></span></span><br></pre></td></tr></table></figure>

<p>编译即可。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://ctan.org/pkg/excel2latex">Excel2LATEX – Convert Excel spreadsheets to LATEX tables</a></li>
</ol>
]]></content>
      <categories>
        <category>research</category>
        <category>article</category>
      </categories>
      <tags>
        <tag>latex</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>换元积分和分部积分</title>
    <url>/2020/03/24/exchange-and-partial-integral/</url>
    <content><![CDATA[<p>这节讲求不定积分的方法，包括换元积分法和分部积分法。其中换元积分法是利用复合函数求导法得到，分部积分法是利用乘积求导法得到。</p>
<a id="more"></a>

<h1 id="换元积分"><a href="#换元积分" class="headerlink" title="换元积分"></a>换元积分</h1><p><strong>定理 8.4</strong> &ensp; （换元积分法）&ensp; 设函数$f(x)$在区间$I$上有定义，$\varphi(t)$在区间$J$上可导，且$\varphi(J) \subset I$.</p>
<ol>
<li><p>如果不定积分$\int f(x) \mathrm{d}x = F(x) + C$在$I$上存在，则不定积分$\int f(\varphi(t)) \varphi^{\prime}(t) \mathrm{d}t$在$J$上也存在，且<br>$$<br>\int f(\varphi(t)) \varphi^{\prime}(t) \mathrm{d}t = F(\varphi(t)) + C.<br>$$</p>
</li>
<li><p>如果$x = \varphi(t)$在$J$上存在反函数$t = \varphi^{-1}(x), \ x \in I$，且不定积分$\int f(x) \mathrm{d}x$在$I$上存在，则当不定积分$\int f(\varphi(t)) \varphi^{\prime}(t) \mathrm{d}t = G(t) + C$在$J$上存在时，在$I$上有<br>$$<br>\int f(x) \mathrm{d}x = G(\varphi^{-1}(x)) + C.<br>$$</p>
</li>
</ol>
<p>上述两个条分别反映了正、负两种换元方式，习惯上分别称为第一换元积分法和第二换元积分法，相应的换元公式称为第一换元公式和第二换元公式。</p>
<h1 id="分部积分"><a href="#分部积分" class="headerlink" title="分部积分"></a>分部积分</h1><p><strong>定理 8.5</strong> &ensp; （分部积分法）&ensp; 若$u(x)$与$v(x)$可导，不定积分$\int u^{\prime}(x) v(x) \mathrm{d}x$在，则$\int u(x) v^{\prime}(x) \mathrm{d}x$也存在，并有<br>$$<br>\int u(x) v^{\prime}(x) \mathrm{d}x = u(x) v(x) - \int u^{\prime}(x) v(x) \mathrm{d}x.<br>$$<br>该公式称为分部积分公式，可以简写为$\int u dv = uv - \int v du$.</p>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>integral</tag>
      </tags>
  </entry>
  <entry>
    <title>函数的极值和最值</title>
    <url>/2020/03/17/extreme-and-maximum-values-of-function/</url>
    <content><![CDATA[<h1 id="极值"><a href="#极值" class="headerlink" title="极值"></a><strong>极值</strong></h1><p><strong>定理 6.11</strong> （极值的第一充分条件）</p>
<p>设$f$在点$x_0$连续，在某领域$U^o(x_0;\delta)$上可导。</p>
<ol>
<li><p>若当$x\in (x_0 -\delta, x_0)$时$f^{\prime}(x)\leq 0$，当$x\in(x_0, x_0+\delta)$时$f^{\prime}(x)\geq 0$，则$f$在点$x_0$取得极小值。</p>
</li>
<li><p>若当$x\in(x_0 - \delta, x_0)$时$f^{\prime}\geq 0$，当$x\in(x_0, x_0+\delta)$时$f^{\prime}(x)\leq 0$，则$f$在点$x_0$取得极大值。</p>
<a id="more"></a>



</li>
</ol>
<p><strong>定理 6.12</strong>（极值的第二充分条件）</p>
<p>设$f$在$x_0$的某领域$U(x_0; \delta)$$ 上一阶可导，在$$x=x_0$$处二阶可导，且$$f^{\prime}(x_0) = 0, f^{(2)}(x_0)\neq 0$.</p>
<ol>
<li>若$f^{(2)}(x_0)&lt;0$$，则$$f$$在$$x_0$取得极大值。</li>
<li>若$f^{(2)}(x_0)&gt;0$，则$f$在$x_0$取得极小值。 </li>
</ol>
<p><strong>最重要的表达技巧</strong>:<br>$$<br>f(x) - f(x_0) \<br>= \frac{f^{(2)}(x_0)}{2!}(x-x_0)^2 + o((x-x_0)^2)<br>= (\frac{f^{(2)}(x_0)}{2!}+o(1))(x-x_0)^2<br>$$</p>
<p><strong>此时，$f(x)-f(x_0)$的符号与$\frac{f^{(2)}(x_0)}{2!}$相同，因为$o(1)$为高阶无穷小</strong> </p>
<p><strong>定理 6.13</strong> （极值的第三充分条件）</p>
<p>设$f$在$x_0$的某领域内存在直到$n-1$阶导函数，在$x_0$处$n$阶可导，且$f^{(k)}(x_0)=0\quad (k=1,2,\cdots, n-1), f^{(n)}(x_0)\neq 0$，则</p>
<ol>
<li>当$n$为偶数时，$f$在$x_0$取得极值，且当$f^{(n)}(x_0)&lt; 0$时取得极大值，$f^{(n)}(x_0)&gt;0$时取极小值。</li>
<li>当$n$为奇数时，$f$在$x_0$处不取极值。</li>
</ol>
<p><strong>注意：</strong>不满足充分条件的函数在某点也可能去极值，如下函数在$x=0$处无限次可求导且导数值为0，不满足极值的三个充分条件的任意一个，但是，在$x=0$处该函数取极小值，也是最小值。<br>$$<br>f(x)=<br>\begin{cases}<br>e^{-\frac{1}{x^2}},\quad x\neq 0 \\<br>0,\quad\quad x=0<br>\end{cases}<br>$$</p>
<h1 id="最值"><a href="#最值" class="headerlink" title="最值"></a><strong>最值</strong></h1><p>寻找最值只需在<strong>稳定点</strong>（可导且$f^{\prime}(x)=0$的点）、<strong>不可导点</strong>、<strong>区间端点</strong>处寻找。</p>
<p>函数<br>$$<br>f(x)=<br>\begin{cases}<br>x^{\frac{3}{2}}\sin(\frac{1}{x}),\quad x\neq 0 \\<br>0,\quad\quad\quad\quad x=0<br>\end{cases}<br>$$<br>的导函数$f^{\prime}(x)$在$x=0$处不连续，因此只能是第二类间断点。因为，导函数只能是第二类间断点，不能是第一类间断点（可取间断点和跳跃间断点）。因此，如果导函数有界，则导函数连续。</p>
<p><strong>定理</strong> 设$f(x)$在区间$I$上连续，并且在$I$上仅有唯一的极值点$x_0$，则若$x_0$是$f$的极大值点（极小值点），则$x_0$必是$f(x)$在$I$上的最大值点（最小值点）</p>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>extremum</tag>
      </tags>
  </entry>
  <entry>
    <title>Failed to connect to changelogs.ubuntu.com.meta.release.lts</title>
    <url>/2019/12/20/fail-ssh-server/</url>
    <content><![CDATA[<p>当出现 Failed to connect to <a href="https://changelogs.ubuntu.com/meta-release-lts">https://changelogs.ubuntu.com/meta-release-lts</a>. 可以在终端中运行如下两行代码来解决。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rm /var/lib/ubuntu-release-upgrader/release-upgrade-available</span><br><span class="line">sudo /etc/update-motd.d/91-release-upgrade</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>debian</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 防火墙</title>
    <url>/2022/01/08/fire-wall-linux/</url>
    <content><![CDATA[<p>无论是 Windows 系统还是 Linux 系统都有防火墙，防火墙能够防护电脑免受外界攻击，保护电脑安全。本篇介绍如何在 Ubuntu/Debian/CentOS 上安装和使用防火墙。</p>
<a id="more"></a>

<h1 id="Ubuntu-Debian-上防火墙"><a href="#Ubuntu-Debian-上防火墙" class="headerlink" title="Ubuntu/Debian 上防火墙"></a>Ubuntu/Debian 上防火墙</h1><p>安装防火墙</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install ufw</span><br></pre></td></tr></table></figure>

<p>防火墙使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启防火墙</span></span><br><span class="line">sudo ufw <span class="built_in">enable</span></span><br><span class="line"><span class="comment"># 查看防火墙状态</span></span><br><span class="line">sudo ufw status</span><br><span class="line"><span class="comment"># 开启指定端口</span></span><br><span class="line">sudo ufw allow 22</span><br><span class="line"><span class="comment"># 开启指定端口的tcp</span></span><br><span class="line">sudo ufw allow 22/tcp</span><br><span class="line"><span class="comment"># 打开端口范围</span></span><br><span class="line">sudo ufw allow 7000:7070</span><br><span class="line"><span class="comment"># 允许指定IP地址</span></span><br><span class="line">sudo ufw allow from xxx.xxx.xxx.xxx</span><br><span class="line"><span class="comment"># 允许指定IP地址访问指定端口</span></span><br><span class="line">sudo ufw allow from xxx.xxx.xxx.xxx to any port 22</span><br><span class="line"><span class="comment"># 运行子网</span></span><br><span class="line">sudo ufw allow from 192.168.1.0/24 to any port 3306</span><br><span class="line"><span class="comment"># 运行指定网络接口的连接</span></span><br><span class="line">sudo ufw allow <span class="keyword">in</span> on eth0 to any port 3306</span><br><span class="line"><span class="comment"># 删除指定端口</span></span><br><span class="line">sudo ufw delete allow 8888</span><br><span class="line"><span class="comment"># 禁止连接</span></span><br><span class="line">sudo ufw deny from 192.168.1.0/24</span><br><span class="line"><span class="comment"># 指定端口禁止连接</span></span><br><span class="line">sudo ufw deny from 192.168.1.0/24 to any port 80</span><br><span class="line"><span class="comment"># 按序号查看</span></span><br><span class="line">sudo ufw status numbered</span><br><span class="line"><span class="comment"># 删除对应序号10的规则</span></span><br><span class="line">sudo ufw delete 10</span><br><span class="line"><span class="comment"># 禁止防火墙</span></span><br><span class="line">sudo ufw <span class="built_in">disable</span></span><br><span class="line"><span class="comment"># 重置防火墙</span></span><br><span class="line">sudo ufw reset</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，开启防火墙后，注意打开指定的SSH连接端口，不然重启后将无法使用SSH连接</p>
<h1 id="CentOS-上防火墙"><a href="#CentOS-上防火墙" class="headerlink" title="CentOS 上防火墙"></a>CentOS 上防火墙</h1><p>安装防火墙</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install firewalld</span><br></pre></td></tr></table></figure>

<p>使用防火墙</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">sudo firewall-cmd --state</span><br><span class="line"><span class="comment"># 开启防火墙</span></span><br><span class="line">sudo systemctl start firewalld.service</span><br><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">sudo systemctl stop firewald.service</span><br><span class="line"><span class="comment"># 设置开机启动防火墙</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> firewald.service</span><br><span class="line"><span class="comment"># 禁止开机启动防火墙</span></span><br><span class="line">sudo systemctl <span class="built_in">disable</span> firewald.service</span><br><span class="line"><span class="comment"># 查看防火墙是否会开机自启</span></span><br><span class="line">sudo systemctl list-unit-file | grep firewald</span><br><span class="line"><span class="comment"># 开放指定端口</span></span><br><span class="line">sudo firewall-cmd --zone=public --add-port=22/tcp --permanent</span><br><span class="line"><span class="comment"># 关闭指定端口</span></span><br><span class="line">sudo firewall-cmd --zone=public --remove-port=80/tcp --permanent</span><br></pre></td></tr></table></figure>



<h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><ol>
<li><a href="https://cloud.tencent.com/developer/article/1626614">如何在 Debian 10 上使用 UFW 来设置防火墙</a></li>
<li><a href="https://blog.csdn.net/xc_zhou/article/details/103758308">[745]Debian打开关闭防火墙</a></li>
<li><a href="https://blog.csdn.net/ytangdigl/article/details/79796961">CentOS7查看和关闭防火墙</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-using-firewalld-on-centos-7">How To Set Up a Firewall Using FirewallD on CentOS 7</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>flink 分布式集群部署笔记</title>
    <url>/2019/12/25/flink-cluster-deployment/</url>
    <content><![CDATA[<p>本笔记是依据 Apache Flink 官网关于<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/zh/ops/deployment/cluster_setup.html">独立集群部署</a>的步骤，进行 Flink 分布式集群部署的具体过程。虽然按照官网步骤能够完成，但是实际部署中还是会遇到一些坑，这里根据个人真实的部署过程做一个详细的记录，以备后续查阅和帮助有需要的人参考。除此之外，Flink 还可以部署在 Yarn, K8s等。</p>
<a id="more"></a>

<p>部署环境是Ubuntu 18.04.3 LTS，Java 1.8.0_231，Flink 1.9.0；三台机器，分别是master: 1.1.1.0, worker1: 1.1.1.1, worker2: 1.1.1.2，其中节点机器master作为 Jobmanager, 其他两个节点机器worker1, worker2作为TaskManager.  下面一步一步从零开始 Flink 分布式集群部署（不包括 <a href="https://help.ubuntu.com/lts/installation-guide/">Ubuntu 18.04.03 LTS 的安装</a>），其中 Java 在 master, worker1, worker2 中的安装是一样，这里以master为例。Flink 部署首先在 master 配置，然后拷贝到worker1, worker2. 注意，Flink集群的运行不需要 Zookeeper 的支持。</p>
<h1 id="Java-1-8-0-231-和-Flink-1-9-0-下载"><a href="#Java-1-8-0-231-和-Flink-1-9-0-下载" class="headerlink" title="Java 1.8.0_231 和 Flink 1.9.0 下载"></a>Java 1.8.0_231 和 Flink 1.9.0 下载</h1><h2 id="Java-1-8-0-231-下载"><a href="#Java-1-8-0-231-下载" class="headerlink" title="Java 1.8.0_231 下载"></a>Java 1.8.0_231 下载</h2><p>打开浏览器，输入网址：<a href="https://www.oracle.com/java/technologies/javase-jdk8-downloads.html%EF%BC%8C%E9%80%89%E6%8B%A9%E7%9B%B8%E5%BA%94%E7%9A%84%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%E5%8D%B3%E5%8F%AF%E3%80%82">https://www.oracle.com/java/technologies/javase-jdk8-downloads.html，选择相应的版本下载即可。</a></p>
<h2 id="Flink-1-9-0-下载"><a href="#Flink-1-9-0-下载" class="headerlink" title="Flink 1.9.0 下载"></a>Flink 1.9.0 下载</h2><p>把网址<a href="https://flink.apache.org/downloads.html">https://flink.apache.org/downloads.html</a> 输入浏览器地址栏，进入Flink下载界面，找到<strong>Apache Flink 1.9.1</strong>下面的<a href="https://www.apache.org/dyn/closer.lua/flink/flink-1.9.1/flink-1.9.1-bin-scala_2.11.tgz">Apache Flink 1.9.1 for Scala 2.11</a> (<a href="https://www.apache.org/dist/flink/flink-1.9.1/flink-1.9.1-bin-scala_2.11.tgz.asc">asc</a>, <a href="https://www.apache.org/dist/flink/flink-1.9.1/flink-1.9.1-bin-scala_2.11.tgz.sha512">sha512</a>) ，点击下载即可。这里不选择<a href="https://www.apache.org/dyn/closer.lua/flink/flink-1.9.1/flink-1.9.1-bin-scala_2.12.tgz">Apache Flink 1.9.1 for Scala 2.12</a> (<a href="https://www.apache.org/dist/flink/flink-1.9.1/flink-1.9.1-bin-scala_2.12.tgz.asc">asc</a>, <a href="https://www.apache.org/dist/flink/flink-1.9.1/flink-1.9.1-bin-scala_2.12.tgz.sha512">sha512</a>)是因为该版本不能够运行scala local shell，对此没有要求的也可以选择使用此版本。</p>
<p>两者都下载后，在终端查看如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ ls -lh *gz</span><br><span class="line">-rwxrwxr-x 1 jinzhongxu jinzhongxu 244M 12月 24 21:50 flink-1.9.1-bin-scala_2.11.tgz</span><br><span class="line">-rwxrwxr-x 1 jinzhongxu jinzhongxu 186M 12月 17 18:08 jdk-8u231-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>

<h1 id="安装-Java-和-Flink-以及配置环境"><a href="#安装-Java-和-Flink-以及配置环境" class="headerlink" title="安装 Java 和 Flink 以及配置环境"></a>安装 Java 和 Flink 以及配置环境</h1><h2 id="安装-Java"><a href="#安装-Java" class="headerlink" title="安装 Java"></a>安装 Java</h2><p>在终端输入以下命令，解压 jdk-8u231-linux-x64.tar.gz，如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ tar -xzf jdk-8u231-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>

<p>查看解压结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ ls -lhd jdk1.8.0*</span><br><span class="line">drwxr-xr-x 7 jinzhongxu jinzhongxu 4.0K 10月  5 18:13 jdk1.8.0_231</span><br></pre></td></tr></table></figure>

<p>一般为了简洁，我会重新命名该文件夹，当然这步不是必须的，以个人喜好</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ mv jdk1.8.0_231/ jdk8</span><br></pre></td></tr></table></figure>

<h2 id="配置Java-环境"><a href="#配置Java-环境" class="headerlink" title="配置Java 环境"></a>配置Java 环境</h2><p>将 Java 路径写入 .bashrc 文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ vim .bashrc</span><br></pre></td></tr></table></figure>

<p>添加如下代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/home/jinzhongxu/jdk8</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure>

<p>此时，在终端中输入以下命令，看到如下返回结果，说明已经安装好 Java</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_231&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_231-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.231-b11, mixed mode)</span><br><span class="line">jinzhongxu@master:~$ javac -version</span><br><span class="line">javac 1.8.0_231</span><br></pre></td></tr></table></figure>

<p><strong><span style="color:red">注意 ：把 JAVA_HOME 写入 /etc/profile 文件中，如果不这样做，实际经验告诉我，Flink 单机启动时会报 JAVA_HOME 问题；Flink 集群启动时，不能启动没有配置该项的 worker 的 Taskmanger</span></strong></p>
<p>命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ vim /etc/profile</span><br></pre></td></tr></table></figure>

<p>添加如下代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/home/jinzhongxu/jdk8</span><br></pre></td></tr></table></figure>

<p>按照这个步骤，分别在master, worker1, worker2上部署 Java.</p>
<h2 id="安装-Flink"><a href="#安装-Flink" class="headerlink" title="安装 Flink"></a>安装 Flink</h2><p>在终端中运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ tar -xzf flink-1.9.1-bin-scala_2.11.tgz</span><br><span class="line">jinzhongxu@master:~$ ls -lhd flink-1.9.1*</span><br><span class="line">drwxr-xr-x 10 jinzhongxu jinzhongxu 4.0K 9月  30 15:10 flink-1.9.1</span><br><span class="line">-rwxrwxr-x  1 jinzhongxu jinzhongxu 244M 12月 24 21:50 flink-1.9.1-bin-scala_2.11.tgz</span><br></pre></td></tr></table></figure>

<p>一般为了简洁，我会重新命名该文件夹，当然这步不是必须的，同样也是以个人喜好</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ mv flink-1.9.1 flink</span><br></pre></td></tr></table></figure>

<h2 id="配置-Flink-环境"><a href="#配置-Flink-环境" class="headerlink" title="配置 Flink 环境"></a>配置 Flink 环境</h2><p>配置 flink， 在命令行中输入如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ vim flink/conf/flink-conf.yaml</span><br></pre></td></tr></table></figure>

<p>修改如下代码<br>    <span style='color:red'>注意这里假设在 /etc/hosts 中配置了IP地址解析</span></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jobmanager.rpc.address: master</span><br></pre></td></tr></table></figure>

<p>配置 slaves, 在命令行中输入如下命令</p>
<p><span style='color:red'>注意在flink1.11.0版本中已经将salves替换为worker，这很可能是最近计算机界对反对种族歧视的调整</span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ vim flink/conf/slaves</span><br></pre></td></tr></table></figure>

<p>修改代码：删除 localhost，增加如下两个机器节点，也可以输入ip 地址，这里输入的是 hostname</p>
<p><span style='color:red'>如果想让master主机同时也作为一个taskmanger，可以增加master</span></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">worker1</span><br><span class="line">worker2</span><br></pre></td></tr></table></figure>

<p><span style='color:blue'>根据需要，一般需要调整每个taskmanager上的插槽slots的数量和默认并行运行代码的能力，配置方法如下，注意，slots的会平分内存，但设定slots个数时一般是安装cpu核心数</span></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每个taskmanger的能力，我这里CPU是5核心的</span></span><br><span class="line">taskmanager.numberOfTaskSlots: 5</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认代码运行的并行数</span></span><br><span class="line">parallelism.default: 3</span><br></pre></td></tr></table></figure>

<p>并行数设定的优先级是：代码中设置最高、提交代码时指定的次之、配置文件中默认的最低</p>
<p>至此，master 节点已经配置完成</p>
<h2 id="安装-worker1-和-worker2-的-Flink"><a href="#安装-worker1-和-worker2-的-Flink" class="headerlink" title="安装 worker1 和 worker2 的 Flink"></a>安装 worker1 和 worker2 的 Flink</h2><p>通过 scp 来拷贝 master 的 flink 到 worker1  和 worker2 节点上，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ scp -r flink worker1:/home/jinzhongxu/.</span><br><span class="line">jinzhongxu@master:~$ scp -r flink worker2:/home/jinzhongxu/.</span><br></pre></td></tr></table></figure>

<p>**注意：master 和 worker1, worker2 不仅具有相同的 Java 环境，Flink 环境，还具有相同的用户名，三者之间通过ssh 连接和传送信息。如何配置 ssh 下面将会补充该部分。如何修改机器的hostname 请参考下面部分 **</p>
<p>此时，就可以运行 Flink 集群了。在 master 命令行中输入如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ ./flink/bin/start-cluster.sh</span><br><span class="line">Starting cluster.</span><br><span class="line">Starting standalonesession daemon on host master.</span><br><span class="line">Starting taskexecutor daemon on host worker1.</span><br><span class="line">Starting taskexecutor daemon on host worker2.</span><br></pre></td></tr></table></figure>

<p>可以看到已经启动了 Flink Cluster，其中 standalonesession daemon 在 master 节点上，taskexecutor 分别在 worker1 和 worker2 上启动。</p>
<p>启动过程如下：在master节点先启动本机的jobmanager，然后SSH连接到worker1, worker2，启动taskmanager.</p>
<p>关闭命令如下：</p>
<p>在master节点上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;flink&#x2F;bin&#x2F;stop-cluster.sh</span><br></pre></td></tr></table></figure>

<p>关闭过程如下：在master运行关闭脚本，首先通过SSH连接到worker1, worker2，关闭taskmanager，然后再关闭master本机的jobmanager。</p>
<p>如果想关闭某个节点，可以直接在该节点机器上运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./flink/bin/jobmanager.sh start</span><br><span class="line"></span><br><span class="line">./flink/bin/jobmanager.sh stop</span><br><span class="line"></span><br><span class="line">./flink/bin/taskmanager.sh start</span><br><span class="line"></span><br><span class="line">./flink/bin/taskmanager.sh stop</span><br></pre></td></tr></table></figure>

<p>在 master 节点运行 jps 命令，可以发现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ jps</span><br><span class="line">10260 StandaloneSessionClusterEntrypoint</span><br><span class="line">10319 Jps</span><br></pre></td></tr></table></figure>

<p>在 worker1 节点运行 jps 命令，可以发现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@worker1:~$ jps</span><br><span class="line">7324 TaskManagerRunner</span><br><span class="line">7375 Jps</span><br></pre></td></tr></table></figure>

<p>在 worker2 节点运行 jps 命令，可以发现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@worker2:~$ jps</span><br><span class="line">5562 TaskManagerRunner</span><br><span class="line">5612 Jps</span><br></pre></td></tr></table></figure>

<p>同时，在浏览器上输入 <a href="http://1.1.1.0:8081/">http://1.1.1.0:8081/</a> 或 <a href="http://master:8081/">http://master:8081/</a> 可以发现 Apache Flink Dashboard 已经正常启动，在 Task Managers 中可以看到如下页面</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/flink/apache-flink-dashboard.png"></p>
<p>在 master 终端中输入 ，运行批处理模板里的wordcount程序，指定并行数2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ ./flink/bin/flink run -p 2 ./flink/examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure>

<p>可以看到</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/flink/flink-completed-jobs.png"></p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/flink/flink-completed-jobs-2.png"></p>
<p>看到这些说明，分布式部署的 Flink 已经成功。也可以在web页面通过最下面选项的 submit new job来提交，里面同样可以设置并行数和其他参数等。</p>
<h1 id="Flink-结构及开发"><a href="#Flink-结构及开发" class="headerlink" title="Flink 结构及开发"></a>Flink 结构及开发</h1><p>Flink 代码编程时，一般分为 <strong>创建环境</strong> -&gt; <strong>定义source</strong> -&gt; <strong>定义transformation</strong> -&gt; <strong>定义sink</strong>. Flink 中把所有的数据都作为流进行处理，其中批数据就是有界流，其他是无界流。</p>
<p>Flink 的其他特点如下：</p>
<ol>
<li>支持事件时间（event-time）和处理时间（processing-time）语义</li>
<li>精确一次（exactly-once）的状态一致性保证</li>
<li>低延迟，每秒处理数百万个事件，毫秒级延迟</li>
<li>与众多常用存储系统可以连接</li>
<li>高可用，可动态扩展，7*24小时全天候运行</li>
</ol>
<p>与spark streaming的区别，spark 是天生批处理，使用微小的分块实现类似功能的流处理，但内部还是使用批处理引擎。</p>
<p>Flink 提交jar后，在client上会进行优化，生成 StreamGraph -&gt; JobGraph，之后在Jobmanger上生成 ExecutionGraph，真正执行时又会生成物理图。</p>
<p>在写代码之前，一般需要配置pom</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>FlinkKafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-scala_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-scala_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-clients_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.alchim31.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>testCompile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置完后，就可以写代码了，根据 Flink 的结构，首先，创建环境，这里以scala代码为例，一般使用</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br></pre></td></tr></table></figure>

<p>而不是使用</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"># 创建本地运行环境</span><br><span class="line"><span class="keyword">val</span> env =  <span class="type">StreamExecutionEnvironment</span>.createLocalEnvironment</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"># 创建集群执行运行环境</span><br><span class="line"><span class="keyword">val</span> env =  <span class="type">ExecutionEnvironment</span>.createRemoteEnvironment(<span class="string">&quot;jobmanage-hostnamne&quot;</span>, <span class="number">6123</span>, <span class="string">&quot;YOURPATH//wordcout.jar&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里给出一个简单的 wordcount 程序</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.wc</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="comment">//import org.apache.flink.api.scala.ExecutionEnvironment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc:</span></span><br><span class="line"><span class="comment"> * Author: xujin</span></span><br><span class="line"><span class="comment"> * CreateTime: 2020/7/10 16:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 批处理word count 程序</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 创建执行环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">ExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中读取数据，这里需要在 &quot;src\\main\\resources&quot; 中创建 &quot;hello.txt&quot; 文件并写入内容，以空格分隔单词</span></span><br><span class="line">    <span class="keyword">val</span> inputPath = <span class="string">&quot;src\\main\\resources\\hello.txt&quot;</span></span><br><span class="line">    <span class="keyword">val</span> inputDataSet = env.readTextFile(inputPath)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切分数据得到word，然后再按word做分组聚合</span></span><br><span class="line">    <span class="keyword">val</span> wordCountDataSet = inputDataSet.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      .map((_, <span class="number">1</span>)).setParallelism(<span class="number">3</span>)</span><br><span class="line">      .groupBy(<span class="number">0</span>)</span><br><span class="line">      .sum(<span class="number">1</span>).setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    wordCountDataSet.print()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为 Flink 天生是处理流数据的，那么流数据的wordcount代码如下</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.wc</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc </span></span><br><span class="line"><span class="comment"> * Author: xujin</span></span><br><span class="line"><span class="comment"> * CreateTime: 2020/7/10 16:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 流处理word count</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StreamWordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建流处理的执行环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收一个socket文本流</span></span><br><span class="line">    <span class="keyword">val</span> dataStream = env.socketTextStream(<span class="string">&quot;8.6.8.6&quot;</span>, <span class="number">7777</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每条数据进行处理</span></span><br><span class="line">    <span class="keyword">val</span> wordCountDataStream = dataStream.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      .filter(_.nonEmpty).setParallelism(<span class="number">4</span>)</span><br><span class="line">      .map((_, <span class="number">1</span>)).setParallelism(<span class="number">4</span>)</span><br><span class="line">      .keyBy(<span class="number">0</span>)</span><br><span class="line">      .sum(<span class="number">1</span>).setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    wordCountDataStream.print().setParallelism(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动executor</span></span><br><span class="line">    env.execute(<span class="string">&quot;stream word count job&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行代码后，在主机 8.6.8.6 终端运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -l 表示打开一个listen，-k 表示keeplive，7777 表示端口</span></span><br><span class="line">nc -lk 7777</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> hello world</span></span><br></pre></td></tr></table></figure>

<p>其次，对于source</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.apitest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.&#123;<span class="type">Properties</span>, <span class="type">Random</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.<span class="type">SourceFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.<span class="type">FlinkKafkaConsumer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Desc </span></span><br><span class="line"><span class="comment"> * Author: xujin</span></span><br><span class="line"><span class="comment"> * CreateTime: 2020/7/10 18:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 温度传感器读数样例类</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SensorReading</span>(<span class="params">id: <span class="type">String</span>, timestamp: <span class="type">Long</span>, temperature: <span class="type">Double</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">SourceTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 从自定义的集合中读取数据</span></span><br><span class="line">    <span class="keyword">val</span> stream1 = env.fromCollection(<span class="type">List</span>(</span><br><span class="line">      <span class="type">SensorReading</span>(<span class="string">&quot;sensor_1&quot;</span>, <span class="number">1548822923</span>, <span class="number">35.283928372938</span>),</span><br><span class="line">      <span class="type">SensorReading</span>(<span class="string">&quot;sensor_2&quot;</span>, <span class="number">1782939192</span>, <span class="number">35.828372928373</span>),</span><br><span class="line">      <span class="type">SensorReading</span>(<span class="string">&quot;sensor_3&quot;</span>, <span class="number">1759283827</span>, <span class="number">36.928381738283</span>),</span><br><span class="line">      <span class="type">SensorReading</span>(<span class="string">&quot;sensor_4&quot;</span>, <span class="number">1872928372</span>, <span class="number">26.293828372839</span>)</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从文件中读取数据</span></span><br><span class="line">    <span class="keyword">val</span> stream2 = env.readTextFile(<span class="string">&quot;src\\main\\resources\\sensor.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 非结构化数据读取</span></span><br><span class="line">    <span class="keyword">val</span> stream3 = env.fromElements(<span class="number">1</span>, <span class="number">2.0</span>, <span class="string">&quot;string&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 从Kafka中读取数据</span></span><br><span class="line">    <span class="keyword">val</span> properties = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">    properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;1.1.1.255:9092&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;consumer-group&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;latest&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> stream4 = env.addSource(<span class="keyword">new</span> <span class="type">FlinkKafkaConsumer</span>[<span class="type">String</span>](<span class="string">&quot;sensor&quot;</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), properties))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 自定义source</span></span><br><span class="line">    <span class="keyword">val</span> stream5 = env.addSource(<span class="keyword">new</span> <span class="type">SensorSource</span>())</span><br><span class="line"></span><br><span class="line">    stream5.print(<span class="string">&quot;stream&quot;</span>).setParallelism(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    env.execute(<span class="string">&quot;source test&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensorSource</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">SourceFunction</span>[<span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个flag， 表示数据源是否正常运行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> running: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正常生成数据</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(sourceContext: <span class="type">SourceFunction</span>.<span class="type">SourceContext</span>[<span class="type">SensorReading</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 初始化一个随机数生成器</span></span><br><span class="line">    <span class="keyword">val</span> rand = <span class="keyword">new</span> <span class="type">Random</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化定义一组传感器温度数据</span></span><br><span class="line">    <span class="keyword">var</span> curTemp = <span class="number">1.</span>to(<span class="number">10</span>).map(</span><br><span class="line">      i =&gt; (<span class="string">&quot;sensor_&quot;</span> + i, <span class="number">60</span> + rand.nextGaussian() * <span class="number">20</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 产生数据流，使用无限循环</span></span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">      <span class="comment">// 在前一次温度的基础上更新温度值</span></span><br><span class="line">      curTemp = curTemp.map(</span><br><span class="line">        t =&gt; (t._1, t._2 + rand.nextGaussian())</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取当前时间戳</span></span><br><span class="line">      <span class="keyword">val</span> curTime = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line">      curTemp.foreach(</span><br><span class="line">        t =&gt; sourceContext.collect(<span class="type">SensorReading</span>(t._1, curTime, t._2))</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置时间间隔，观察数据输出</span></span><br><span class="line">      <span class="type">Thread</span>.sleep(<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    running = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="补充1：配置-SSH"><a href="#补充1：配置-SSH" class="headerlink" title="补充1：配置 SSH"></a>补充1：配置 SSH</h2><h3 id="首先，分别在各集群机器（这里是-Ubuntu-系统）上运行如下命令，安装-SSHD-服务"><a href="#首先，分别在各集群机器（这里是-Ubuntu-系统）上运行如下命令，安装-SSHD-服务" class="headerlink" title="首先，分别在各集群机器（这里是 Ubuntu 系统）上运行如下命令，安装  SSHD 服务"></a>首先，分别在各集群机器（这里是 Ubuntu 系统）上运行如下命令，安装  SSHD 服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ sudo apt update &amp;&amp; sudo apt install openssh-server</span><br></pre></td></tr></table></figure>

<h3 id="其次，创建-SSH-公钥和私钥"><a href="#其次，创建-SSH-公钥和私钥" class="headerlink" title="其次，创建  SSH 公钥和私钥"></a>其次，创建  SSH 公钥和私钥</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<h3 id="然后，在-master-节点创建-authorized-keys-文件，用于认证-SSH-连接"><a href="#然后，在-master-节点创建-authorized-keys-文件，用于认证-SSH-连接" class="headerlink" title="然后，在 master 节点创建 authorized_keys 文件，用于认证  SSH 连接"></a>然后，在 master 节点创建 authorized_keys 文件，用于认证  SSH 连接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ touch ./.ssh/authorized_keys</span><br><span class="line">jinzhongxu@master:~$ chmod 600 ./.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<h3 id="再然后，将所有机器的公钥写入-master-节点上的-authorized-keys-文件"><a href="#再然后，将所有机器的公钥写入-master-节点上的-authorized-keys-文件" class="headerlink" title="再然后，将所有机器的公钥写入 master 节点上的 authorized_keys 文件"></a>再然后，将所有机器的公钥写入 master 节点上的 authorized_keys 文件</h3><ul>
<li>将 master 的公钥写入</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ cat ./.ssh/id_rsa.pub &gt;&gt; ./.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<ul>
<li>将 worker1 的公钥写入，需要输入密码一次</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ scp worker1:/home/jinzhongxu/.ssh/id_rsa.pub worker1.pub</span><br><span class="line">jinzhongxu@master:~$ cat worker1.pub &gt;&gt; ./.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者直接</span></span><br><span class="line">jinzhongxu@worker1:~$ ssh-copy-id .ssh/id_rsa.pub master</span><br></pre></td></tr></table></figure>

<ul>
<li>将 worker2 的公钥写入，需要输入密码一次</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ scp worker2:/home/jinzhongxu/.ssh/id_rsa.pub worker2.pub</span><br><span class="line">jinzhongxu@master:~$ cat worker2.pub &gt;&gt; ./.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者直接</span></span><br><span class="line">jinzhongxu@worker2:~$ ssh-copy-id .ssh/id_rsa.pub master</span><br></pre></td></tr></table></figure>

<h3 id="最后，将-master-中的-authorized-keys-传给-worker1-worker2"><a href="#最后，将-master-中的-authorized-keys-传给-worker1-worker2" class="headerlink" title="最后，将 master 中的 authorized_keys 传给 worker1, worker2"></a>最后，将 master 中的 authorized_keys 传给 worker1, worker2</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ scp ./.ssh/authorized_keys worker1:/home/jinzhongxu/.ssh/.</span><br><span class="line">jinzhongxu@master:~$ scp ./.ssh/authorized_keys worker1:/home/jinzhongxu/.ssh/.</span><br></pre></td></tr></table></figure>



<h2 id="补充2：修改主机名"><a href="#补充2：修改主机名" class="headerlink" title="补充2：修改主机名"></a>补充2：修改主机名</h2><p>下面以 master 为例，修改服务器主机名</p>
<h3 id="首先，查看目前主机名"><a href="#首先，查看目前主机名" class="headerlink" title="首先，查看目前主机名"></a>首先，查看目前主机名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@DESKTOP-5397GNE:~$ hostname</span><br><span class="line">DESKTOP-5397GNE</span><br></pre></td></tr></table></figure>

<h3 id="其次，修改主机名"><a href="#其次，修改主机名" class="headerlink" title="其次，修改主机名"></a>其次，修改主机名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@DESKTOP-5397GNE:~$ sudo vim /etc/hostname</span><br></pre></td></tr></table></figure>

<p>删除 DESKTOP-5397GNE 修改为 master</p>
<h3 id="然后，修改-hosts"><a href="#然后，修改-hosts" class="headerlink" title="然后，修改 hosts"></a>然后，修改 hosts</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@DESKTOP-5397GNE:~$ sudo vim /etc/hosts</span><br></pre></td></tr></table></figure>

<p>修改内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1       localhost</span><br><span class="line">127.0.1.1       master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The following lines are desirable <span class="keyword">for</span> IPv6 capable hosts</span></span><br><span class="line"></span><br><span class="line">::1     ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br><span class="line"></span><br><span class="line">10.2.28.74      master</span><br><span class="line">10.2.28.75      worker1</span><br><span class="line">10.2.28.76      worker2</span><br></pre></td></tr></table></figure>

<p>需要重启电脑，才能在命令行正确显示主机名，查看主机名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@master:~$ hostname</span><br><span class="line">master</span><br></pre></td></tr></table></figure>

<p>类似于 master，对于其他 worker1 和 worker2 同样方法进行修改。</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>big data</tag>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>反向代理工具 frp</title>
    <url>/2020/02/17/frp-proxy/</url>
    <content><![CDATA[<p>当想在家或手机端使用局域网内的高性能服务器时，因为网络的限制而不能直接连接局域网内的服务器，所以可以使用一个具有公网IP的远程服务器来作为中间连接服务器，进行反向代理来达到目的。</p>
<a id="more"></a>

<p>首先，假设局域网服务器是 Ubuntu 系统的 PowerEdge，远程服务器是一个 Debian 系统的 AWS 服务器 JX，其次，需要从 Github 下载反向代理软件 <a href="https://github.com/fatedier/frp">frp</a> </p>
<h2 id="在-JX-上，下载-frp，并解压，修改配置文件，最后运行服务"><a href="#在-JX-上，下载-frp，并解压，修改配置文件，最后运行服务" class="headerlink" title="在 JX 上，下载 frp，并解压，修改配置文件，最后运行服务"></a>在 JX 上，下载 frp，并解压，修改配置文件，最后运行服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.31.2/frp_0.31.2_linux_amd64.tar.gz</span><br><span class="line">tar -xzf frp*</span><br><span class="line">rm frp*gz</span><br><span class="line">mv frp* frp</span><br><span class="line"><span class="built_in">cd</span> frp</span><br><span class="line">vim frps.ini</span><br></pre></td></tr></table></figure>

<p>添加如下内容，并运行如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line">vhost_http_port = 8080</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup ./frps -c frps.ini &gt; <span class="built_in">log</span> &amp;</span><br></pre></td></tr></table></figure>

<p>或者配置开机自启，方法如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -i</span><br><span class="line">vim /etc/systemd/system/frps.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加如下代码；使用 local-fs.target 似乎可预防掉线</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=frps daemon</span><br><span class="line">After=<span class="built_in">local</span>-fs.target</span><br><span class="line"><span class="comment">#After=network.target</span></span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/home/jinzhongxu/.frp/frps -c /home/jinzhongxu/.frp/frps.ini</span><br><span class="line">User=jinzhongxu</span><br><span class="line">Group=jinzhongxu</span><br><span class="line">WorkingDirectory=/home/jinzhongxu/</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看状态并开启、设置开机自启</span></span><br><span class="line">systemctl status frps.service</span><br><span class="line">systemctl start frps.service</span><br><span class="line">systemctl status frps.service</span><br><span class="line">systemctl <span class="built_in">enable</span> frps.service</span><br></pre></td></tr></table></figure>



<h2 id="在-PowerEdge-上，同样下载-frp，并解压，修改配置文件，最后启动局域网服务"><a href="#在-PowerEdge-上，同样下载-frp，并解压，修改配置文件，最后启动局域网服务" class="headerlink" title="在 PowerEdge 上，同样下载 frp，并解压，修改配置文件，最后启动局域网服务"></a>在 PowerEdge 上，同样下载 frp，并解压，修改配置文件，最后启动局域网服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.31.2/frp_0.31.2_linux_amd64.tar.gz</span><br><span class="line">tar -xzf frp*</span><br><span class="line">rm frp*gz</span><br><span class="line">mv frp* frp</span><br><span class="line"><span class="built_in">cd</span> frp</span><br><span class="line">vim frpc.ini</span><br></pre></td></tr></table></figure>

<p>添加如下代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = www.jx.com</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000</span><br><span class="line"></span><br><span class="line">[web]</span><br><span class="line">type = http</span><br><span class="line">local_port = 8080</span><br><span class="line">custom_domains = www.jx.com</span><br></pre></td></tr></table></figure>

<p><font color=red>注意：</font></p>
<ol>
<li>这里的域名可以换成外网IP；</li>
<li>[ssh] 和 [web] 可以随便书写，只要不重复且能够表示意思即可；</li>
<li>注意防火墙是否关闭或开启指定的端口；</li>
<li>确保端口未被其他程序占用；</li>
</ol>
<p>运行如下代码，开启局域网服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup ./frpc -c frpc.ini &gt; <span class="built_in">log</span> &amp;</span><br></pre></td></tr></table></figure>

<h2 id="在-WSL-上，同样下载-frp，并解压，修改配置文件，最后启动局域网服务"><a href="#在-WSL-上，同样下载-frp，并解压，修改配置文件，最后启动局域网服务" class="headerlink" title="在 WSL 上，同样下载 frp，并解压，修改配置文件，最后启动局域网服务"></a>在 WSL 上，同样下载 frp，并解压，修改配置文件，最后启动局域网服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.31.2/frp_0.31.2_linux_amd64.tar.gz</span><br><span class="line">tar -xzf frp*</span><br><span class="line">rm frp*gz</span><br><span class="line">mv frp* frp</span><br><span class="line"><span class="built_in">cd</span> frp</span><br><span class="line">vim frpc.ini</span><br></pre></td></tr></table></figure>

<p>添加如下代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = www.jx.com</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[ssh2]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6001</span><br></pre></td></tr></table></figure>

<p>至此，就可以在家，通过命令以 JX 为中继远程连接局域网的服务器 PowerEdge/WSL 了，需要注意的是，远程服务器端一定要打开端口：7000， 6000， 6001， 8080等</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh www.jx.com -p 6000</span><br><span class="line">ssh www.jx.com -p 6001</span><br></pre></td></tr></table></figure>

<p>也可以打开网址，</p>
<p><a href="http://www.jx.com:8080/">www.jx.com:8080</a></p>
<p>来访问局域网 8080 端口的服务</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title>git 知识汇总补充</title>
    <url>/2020/01/13/git-advance/</url>
    <content><![CDATA[<p>Git的分支功能可以支持同时进行多个功能的开发和版本管理。</p>
<a id="more"></a>

<h2 id="查看分支情况"><a href="#查看分支情况" class="headerlink" title="查看分支情况"></a>查看分支情况</h2><ul>
<li>查看当前分支和本地分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<ul>
<li>查看远程分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure>

<ul>
<li>查看所有分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -a </span><br></pre></td></tr></table></figure>

<h2 id="创建本地分支"><a href="#创建本地分支" class="headerlink" title="创建本地分支"></a>创建本地分支</h2><ul>
<li>直接创建本地分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch issue3</span><br></pre></td></tr></table></figure>

<ul>
<li>切换分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout issue3</span><br></pre></td></tr></table></figure>

<ul>
<li>创建并切换本地分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b issue3</span><br></pre></td></tr></table></figure>

<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>使用如下命令合并分支，如果目前是在issue3分支，首先需要切换到master分支，然后再合并issue3分支到master分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge issue3</span><br></pre></td></tr></table></figure>

<p>除了merge命令外，还有一种命令可以合并分支，那就是rebase，更多内容可以查看：<a href="https://backlog.com/git-tutorial/cn/stepup/stepup1_4.html">分支的合并</a></p>
<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d issue3</span><br></pre></td></tr></table></figure>

<h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin --delete add-license-1</span><br></pre></td></tr></table></figure>

<p><font color='dd0000'>注意：删除远程分支不使用git branch -d，而是使用git push origin –delete命令</font></p>
<p>但是，当远程仓库没有该分支时，或者在本地使用git branch -r能够看到远程仓库名，但远程仓库却已经不存在时，使用上面删除远程分支，会出现如下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: unable to delete &#x27;xxx&#x27;: remote ref does not exist </span><br></pre></td></tr></table></figure>

<p>这时候需要我们更新本地仓库的远程仓库列表信息，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch --prune</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新后，会列出远程仓库origin已经不存在的分支</span></span><br><span class="line">// From github.com:xujinzh/JBlog</span><br><span class="line">//  - [deleted]         (none)     -&gt; origin/add-license-1</span><br><span class="line">//  - [deleted]         (none)     -&gt; origin/dependabot/npm_and_yarn/acorn-7.1.1</span><br></pre></td></tr></table></figure>

<p>之后，再使用命令 git branch -r 查看，就会发现最新的远程仓库列表信息</p>
<h2 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h2><p>首先运行如下命令，查看commit id，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> </span><br></pre></td></tr></table></figure>

<p>运行如下命令添加标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag 1.0.0 c584a15bd2</span><br></pre></td></tr></table></figure>

<p>其中，1.0.0为标签，版本号，c584a15bd2为commit id，只要唯一即可。</p>
<h2 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -n</span><br></pre></td></tr></table></figure>

<h2 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -d &lt;tagname&gt;</span><br></pre></td></tr></table></figure>

<h2 id="提交本地分支issue3到远程分支dis"><a href="#提交本地分支issue3到远程分支dis" class="headerlink" title="提交本地分支issue3到远程分支dis"></a>提交本地分支issue3到远程分支dis</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin issue3:dis</span><br></pre></td></tr></table></figure>

<p>如果远程分支不存在，则自动创建一个分支</p>
<h2 id="删除远程分支dis"><a href="#删除远程分支dis" class="headerlink" title="删除远程分支dis"></a>删除远程分支dis</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin :dis</span><br></pre></td></tr></table></figure>

<h2 id="自建git托管服务器"><a href="#自建git托管服务器" class="headerlink" title="自建git托管服务器"></a>自建git托管服务器</h2><p>这里以Ubuntu为例</p>
<p>首先，需要有一个vps服务器，假设IP地址是1.14.1.14</p>
<p>其次，在服务器上增加用户和组，比如添加 jinzhongxu 用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adduser jinzhongxu</span><br></pre></td></tr></table></figure>

<p>然后，安装git命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install git</span><br></pre></td></tr></table></figure>

<p>最后，建立远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init --bare monkey.git</span><br></pre></td></tr></table></figure>

<p>把远程仓库克隆到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> jinzhongxu@1.14.1.14:/home/jinzhongxu/monkey.git</span><br></pre></td></tr></table></figure>

<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>当从远程仓库克隆后，git默认远程仓库名为origin，并将远程的master分支与本地的master分支对应。查看远程仓库名称使用如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<p>将显示更多信息，不仅有远程仓库名称，还有fetch和push的远程仓库地址。当没有push权限时，将不显示push地址。</p>
<h2 id="多人协作开发提交"><a href="#多人协作开发提交" class="headerlink" title="多人协作开发提交"></a>多人协作开发提交</h2><p>当克隆远程仓库到本地，一般是master分支，产品版本分支，该分支是主分支，时刻与远程仓库同步；除此之外，开发人员在本地还会创建dev分支、bug分支和feature分支。其中dev分支是开发分支，团队开发人员开发分支，重大版本迭代时merge到主分支，一般也需要时刻与远程dev分支同步；bug分支是本地修复bug的分支，一般不进行远程同步；feature分支同步取决于团队需要。该小节可参考：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/900375748016320">多人协作</a></p>
<ol>
<li><p>leader或首位开发者在本地master分支外使用如下命令创建了dev分支，并提交到远程origin仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在本地创建dev分支，并切换到dev分支，进行开发</span></span><br><span class="line">git checkout -b dev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送本地dev分支到远程仓库origin，并同时在远程仓库origin创建dev分支</span></span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二位开发人员首先克隆远程开发仓库到本地，然后在本地增加远程origin/dev分支到本地dev分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 克隆远程origin仓库到本地机器</span></span><br><span class="line">git clone jinzhongxu@1.14.1.14:/home/jinzhongxu/monkey.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看分支情况，特别是远程，发现远程仓库origin除了有master分支，还有分支origin/dev</span></span><br><span class="line">git branch -a</span><br><span class="line">//* master</span><br><span class="line">//  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">//  remotes/origin/dev</span><br><span class="line">//  remotes/origin/master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将远程仓库origin的dev分支增加到本地，并切换到本地dev分支</span></span><br><span class="line">git checkout -b dev origin/dev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看本地分支信息</span></span><br><span class="line">git branch</span><br><span class="line">//* dev</span><br><span class="line">//  master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 该开发人员进行了本地开发，并在dev分支增加部分代码，然后提交到远程仓库origin的dev分支</span></span><br><span class="line">git status</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;repair bug&quot;</span><br><span class="line">git status</span><br><span class="line">git push origin dev:dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三位开发人员也同样和第二位开发人员一样，下载了远程仓库origin的master分支和dev分支，并同时进行开发</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 克隆远程origin仓库到本地机器</span></span><br><span class="line">git clone jinzhongxu@1.14.1.14:/home/jinzhongxu/monkey.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看分支情况，特别是远程，发现远程仓库origin除了有master分支，还有分支origin/dev</span></span><br><span class="line">git branch -a</span><br><span class="line">//* master</span><br><span class="line">//  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">//  remotes/origin/dev</span><br><span class="line">//  remotes/origin/master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将远程仓库origin的dev分支增加到本地，并切换到本地dev分支</span></span><br><span class="line">git checkout -b dev origin/dev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看本地分支信息</span></span><br><span class="line">git branch</span><br><span class="line">//* dev</span><br><span class="line">//  master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 该开发人员进行了本地开发，并在dev分支增加部分代码，然后提交到远程仓库origin的dev分支</span></span><br><span class="line">git status</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;repair bug&quot;</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 但是，使用如下命令在提交时出现问题</span></span><br><span class="line">git push origin dev:dev</span><br><span class="line">// To 1.14.1.14:/home/jinzhongxu/monkey.git</span><br><span class="line">//  ! [rejected]        dev -&gt; dev (fetch first)</span><br><span class="line">// error: failed to push some refs to &#x27;jinzhongxu@1.14.1.14:/home/jinzhongxu/monkey.git&#x27;</span><br><span class="line">// hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">// hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">// hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">// hint: (e.g., &#x27;git pull ...&#x27;) before pushing again.</span><br><span class="line">// hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面的错误提示很明白，那就是团队中已经有人提交的最新更新到远程dev分支，需要先git pull，然后再git push，使用如下命令解决</span></span><br><span class="line">git pull # 如果失败，可能的原因是没有指定本地dev分支与远程origin/dev分支的链接，可使用右边命令设置dev和origin/dev的链接：git branch --set-upstream-to=origin/dev dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 成功后，出现如下提示，就是需要手动修改冲突，然后，再git push</span></span><br><span class="line">// remote: Counting objects: 5, done.</span><br><span class="line">// remote: Compressing objects: 100% (3/3), done.</span><br><span class="line">// remote: Total 3 (delta 1), reused 0 (delta 0)</span><br><span class="line">// Unpacking objects: 100% (3/3), done.</span><br><span class="line">// From 1.14.1.14:/home/jinzhongxu/monkey</span><br><span class="line">//    4461cc8..7056c16  dev        -&gt; origin/dev</span><br><span class="line">// Auto-merging main.py</span><br><span class="line">// CONFLICT (content): Merge conflict in main.py</span><br><span class="line">// Automatic merge failed; fix conflicts and then commit the result.</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line">git add main.py</span><br><span class="line">git commit -m &quot;repair bugs for xlabel and ylabel&quot;</span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>前面三个过程，特别是2和3，是公司开发时常遇到，并且经常这样的迭代进行。特别是3，我们要经常使用，要熟练掌握。</p>
</li>
</ol>
<h2 id="更改远程仓库的-URL"><a href="#更改远程仓库的-URL" class="headerlink" title="更改远程仓库的 URL"></a>更改远程仓库的 URL</h2><p>当远程仓库 IP 地址更改、SSH 和 HTTPS 切换等其他导致远程仓库的 URL 地址发生改变时，需要切换地址，才能够正确提交本地修改的代码等内容上传到远程仓库。</p>
<p>更改远程仓库的 URL 需要使用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">set</span>-url</span><br></pre></td></tr></table></figure>

<p><code>git remote set-url</code> 命令使用两个参数：</p>
<ul>
<li><p>现有远程仓库的名称。 例如，<code>源仓库</code>或<code>上游仓库</code>是两种常见选择。</p>
</li>
<li><p>远程仓库的新 URL。 例如：</p>
<ul>
<li><p>如果您要更新为使用 HTTPS，您的 URL 可能如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://github.com/USERNAME/REPOSITORY.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果您要更新为使用 SSH，您的 URL 可能如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git@github.com:USERNAME/REPOSITORY.git</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="将远程-URL-从-SSH-切换到-HTTPS"><a href="#将远程-URL-从-SSH-切换到-HTTPS" class="headerlink" title="将远程 URL 从 SSH 切换到 HTTPS"></a><a href="https://docs.github.com/cn/free-pro-team@latest/github/using-git/changing-a-remotes-url#%E5%B0%86%E8%BF%9C%E7%A8%8B-url-%E4%BB%8E-ssh-%E5%88%87%E6%8D%A2%E5%88%B0-https">将远程 URL 从 SSH 切换到 HTTPS</a></h3><ol>
<li><p>打开 Terminal（终端）。</p>
</li>
<li><p>将当前工作目录更改为您的本地仓库。</p>
</li>
<li><p>列出现有远程仓库以获取要更改的远程仓库的名称。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> origin  git@github.com:USERNAME/REPOSITORY.git (fetch)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> origin  git@github.com:USERNAME/REPOSITORY.git (push)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
</li>
</ol>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote set-url</span><br></pre></td></tr></table></figure>



<p>   命令将远程的 URL 从 SSH 更改为 HTTPS。</p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote <span class="built_in">set</span>-url origin https://github.com/USERNAME/REPOSITORY.git</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>验证远程 URL 是否已更改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Verify new remote URL</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> origin  https://github.com/USERNAME/REPOSITORY.git (fetch)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> origin  https://github.com/USERNAME/REPOSITORY.git (push)</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>下次对远程仓库执行 <code>git fetch</code>、<code>git pull</code> 或 <code>git push</code> 操作时，您需要提供 GitHub 用户名和密码。 When Git prompts you for your password, enter your personal access token (PAT) instead. Password-based authentication for Git is deprecated, and using a PAT is more secure. For more information, see “<a href="https://docs.github.com/cn/free-pro-team@latest/github/authenticating-to-github/creating-a-personal-access-token">Creating a personal access token</a>.”</p>
<p>You can <a href="https://docs.github.com/cn/free-pro-team@latest/github/using-git/caching-your-github-credentials-in-git">use a credential helper</a> so Git will remember your GitHub username and personal access token every time it talks to GitHub.</p>
<h3 id="将远程-URL-从-HTTPS-切换到-SSH"><a href="#将远程-URL-从-HTTPS-切换到-SSH" class="headerlink" title="将远程 URL 从 HTTPS 切换到 SSH"></a><a href="https://docs.github.com/cn/free-pro-team@latest/github/using-git/changing-a-remotes-url#%E5%B0%86%E8%BF%9C%E7%A8%8B-url-%E4%BB%8E-https-%E5%88%87%E6%8D%A2%E5%88%B0-ssh">将远程 URL 从 HTTPS 切换到 SSH</a></h3><ol>
<li><p>打开 Terminal（终端）。</p>
</li>
<li><p>将当前工作目录更改为您的本地仓库。</p>
</li>
<li><p>列出现有远程仓库以获取要更改的远程仓库的名称。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> origin  https://github.com/USERNAME/REPOSITORY.git (fetch)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> origin  https://github.com/USERNAME/REPOSITORY.git (push)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
</li>
</ol>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote set-url</span><br></pre></td></tr></table></figure>



<p>   命令将远程的 URL 从 HTTPS 更改为 SSH。</p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote <span class="built_in">set</span>-url origin git@github.com:USERNAME/REPOSITORY.git</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>验证远程 URL 是否已更改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Verify new remote URL</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> origin  git@github.com:USERNAME/REPOSITORY.git (fetch)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> origin  git@github.com:USERNAME/REPOSITORY.git (push)</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://docs.github.com/cn/free-pro-team@latest/github/using-git/changing-a-remotes-url">更改远程仓库的 URL</a></p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>修复GitHub提示acorn和minimist因版本低而易受攻击警告</title>
    <url>/2020/03/18/git-alert-hexo-npm-acorn-minimist/</url>
    <content><![CDATA[<p>Hexo + Github 搭建博客，在需要两地（单位与家）同时写博文时，选择将blog源码上传到GitHub，但是，某时当使用 <strong>git push</strong> 上传源码到GitHub，出现 <em>acorn &amp; minimist 容易受攻击</em>。</p>
<p>下面是自己摸索的解决办法：</p>
<a id="more"></a>

<h1 id="Mac端"><a href="#Mac端" class="headerlink" title="Mac端"></a>Mac端</h1><p>在家里Mac终端执行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/github/JBlog</span><br><span class="line">npm install acorn@latest</span><br><span class="line">npm install minimist@latest</span><br></pre></td></tr></table></figure>

<p>如果版本较低，也可以使用如下命令更新npm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g npm</span><br></pre></td></tr></table></figure>

<p>如下命令可以修复问题，但是我这里好像没什么用处，不过作为笔记还是记录下来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm audit fix</span><br></pre></td></tr></table></figure>

<h1 id="Windows-sublinux-Ubuntu-端"><a href="#Windows-sublinux-Ubuntu-端" class="headerlink" title="Windows sublinux - Ubuntu 端"></a>Windows sublinux - Ubuntu 端</h1><p>在Ubuntu终端执行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> github/JBlog</span><br><span class="line">npm install acorn@latest</span><br><span class="line">npm install minimist@latest</span><br></pre></td></tr></table></figure>

<h1 id="提交到GitHub"><a href="#提交到GitHub" class="headerlink" title="提交到GitHub"></a>提交到GitHub</h1><p>在Mac端更新低版本的插件后，就可以使用如下命令上传到GitHub了</p>
<p>首先，先生成和部署博文</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>其次，上传GitHub上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;correct bugs for alerts&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>发现已经没有了警告信息</p>
<p>最后，在Ubuntu端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>acorn</tag>
        <tag>minimist</tag>
        <tag>hexo</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>git 基础知识</title>
    <url>/2020/01/13/git-basic/</url>
    <content><![CDATA[<p>git 是一种分布式版本控制软件，最初由林纳斯·托瓦兹于2005年为了更好的管理Linux内核开发而设计。可以保存文件的更新记录，可以恢复以前的状态，显示编辑前后的差异。当同时上传新文件覆盖旧文件时，如果发生冲突会发出警告。</p>
<a id="more"></a>

<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>git数据库分为远程数据库和本地数据库，如果想要公开本地数据库中的内容，可以上传到远程数据库。GitHub就是远程数据库的代码托管软件，可以免费公开也可以付费私享，团队协作开发。</p>
<p>本地数据库可以通过在本地创建全新的数据库，也可以从远程数据库克隆拉取。</p>
<p>当提交本地代码或文件修改时，应认真填写修改内容的提交信息，一般可以用”提交修改内容的摘要+修改理由“问模板提交信息。</p>
<p>git版本控制软件下，实际的工作目录称为工作树，数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域。Git在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库。因此，要提交文件，首先需要把文件加入到索引区域中。</p>
<h1 id="git-安装"><a href="#git-安装" class="headerlink" title="git 安装"></a>git 安装</h1><p>从官网下载相应版本进行安装。官网地址：<a href="https://git-scm.com/downloads">git-scm.com</a>，安装完成后，使用如下命令测试git是否安装成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<h1 id="git-配置"><a href="#git-配置" class="headerlink" title="git 配置"></a>git 配置</h1><p>在安装完git后，一般需要先对git进行配置，才能后续正常使用，配置文件在家目录下面的 <strong>.gitconfig</strong> 隐藏文件里。在命令行中配置git，会自动将git配置信息写入该文件中。</p>
<ul>
<li><p>配置用户名和邮箱</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;jinzhongxu&quot;</span></span><br><span class="line"></span><br><span class="line">git config --global user.email <span class="string">&quot;xujinzhong027@outlook.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>也可以将 <strong>–global</strong> 去掉，这样就只是针对当前数据库配置，而不是本机配置。</p>
</li>
<li><p>git命令彩色显示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global color.ui auto</span><br></pre></td></tr></table></figure>
</li>
<li><p>git命令起别名，如给命令<strong>checkout</strong>起别名<strong>co</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="git-创建本地数据库"><a href="#git-创建本地数据库" class="headerlink" title="git 创建本地数据库"></a>git 创建本地数据库</h1><h2 id="创建本地数据库"><a href="#创建本地数据库" class="headerlink" title="创建本地数据库"></a>创建本地数据库</h2><p>使用如下命令创建名为bottle的数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir bottle</span><br><span class="line"><span class="built_in">cd</span> bottle/</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<h2 id="提交文件到仓库"><a href="#提交文件到仓库" class="headerlink" title="提交文件到仓库"></a>提交文件到仓库</h2><p>在本地bottle数据库目录下编辑文件hello.java，然后提交到本地数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status <span class="comment"># 查看状态</span></span><br><span class="line">git add hello.java <span class="comment"># 添加文件到索引</span></span><br><span class="line">git commit -m <span class="string">&quot;add hello.java for test&quot;</span> <span class="comment"># 提交文件</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment"># 查看</span></span><br></pre></td></tr></table></figure>

<p>如果有多个文件，可以利用如下命令把所有文件添加到索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add hello.java ck.java</span><br></pre></td></tr></table></figure>

<h2 id="查看提交的文件"><a href="#查看提交的文件" class="headerlink" title="查看提交的文件"></a>查看提交的文件</h2><p>使用如下命令查看提交的文件信息详情</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --decorate</span><br></pre></td></tr></table></figure>

<h1 id="git-连接本地数据库与远程数据库"><a href="#git-连接本地数据库与远程数据库" class="headerlink" title="git 连接本地数据库与远程数据库"></a>git 连接本地数据库与远程数据库</h1><p>在GitHub上注册个人账户，创建新的数据库，名字可以自定义。</p>
<p>在GitHub官网上创建的仓库一般都是裸仓库，即使用如下命令创建的仓库，一般都会以.git结尾，这也是为什么GitHub官网上创建的仓库是.git结尾。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init --bare monkey.git</span><br></pre></td></tr></table></figure>

<p>这种方式创建的仓库与缺少–bare方式创建的仓库区别有</p>
<ol>
<li>没有.git目录，但是正常的所有.git目录下面的文件都在monkey目录下；</li>
<li>不能进行git命令操作；</li>
<li>一般作为远端服务器代码仓库；</li>
<li>可以克隆下来后使用push提交代码，而不使用–bare创建的仓库不能接收push来的代码；</li>
</ol>
<p>更多相关内容可参考：<a href="%5Bhttps://moelove.info/2016/12/04/Git-%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8C%E8%A3%B8%E4%BB%93%E5%BA%93/%5D(https://moelove.info/2016/12/04/Git-%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8C%E8%A3%B8%E4%BB%93%E5%BA%93/)">Git 本地仓库和裸仓库</a></p>
<p>这里，我们首先创建本地仓库，然后添加GitHub远程仓库到本地仓库，其次pull远程仓库到本地仓库，最后将本地仓库的增加的代码push到远程仓库</p>
<h2 id="实例化本地仓库"><a href="#实例化本地仓库" class="headerlink" title="实例化本地仓库"></a>实例化本地仓库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init bottle</span><br></pre></td></tr></table></figure>

<p>查看配置信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<p>配置git用户信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config user.name <span class="string">&quot;jinzhongxu&quot;</span></span><br><span class="line">git config user.email <span class="string">&quot;xujinzhong027@outlook.com&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/xujinzh/monkey.git</span><br></pre></td></tr></table></figure>

<h2 id="拉取远程仓库或者更新本地库"><a href="#拉取远程仓库或者更新本地库" class="headerlink" title="拉取远程仓库或者更新本地库"></a>拉取远程仓库或者更新本地库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin master:master</span><br></pre></td></tr></table></figure>

<p>上面代码中，origin表示远程仓库，第一个master表示远程仓库的master分支，第二个master表示本地分支，可以写成其他分支，如果分支不存在会自动创建。<strong>另外，该命令也是从远程数据库把最新变更内容拉取到本地的方法，以更新别的开发者提交的最新代码。</strong> 省略数据库名称的话，会在名为origin的数据库进行pull。使用log指令来确认历史记录是否已更新。</p>
<p>该步也可以使用fetch命令代替</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch origin master</span><br><span class="line">git merge FETCH_HEAD</span><br></pre></td></tr></table></figure>

<h2 id="提交本地仓库到远程仓库"><a href="#提交本地仓库到远程仓库" class="headerlink" title="提交本地仓库到远程仓库"></a>提交本地仓库到远程仓库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim test.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;write in local&quot;</span> | cat &gt;&gt; test.txt</span><br><span class="line">git status</span><br><span class="line">git add test.txt</span><br><span class="line">git commit -m <span class="string">&quot;add test.txt for test&quot;</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：也可以直接使用clone来完成上面的步骤，代码如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/xujinzh/monkey.git neck</span><br></pre></td></tr></table></figure>

<p>然后再进入 neck 目录配置 git 用户信息，之后就可以添加代码，push 代码了。该方法是最简单的创建数据库的方法。并且，在克隆的数据库推送时，可以省略远程数据库和分支的名称，如下简单命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>在执行pull之后，进行下一次push之前，如果其他人进行了推送内容到远程数据库的话，那么你的push将被拒绝。这是因为，如果远程数据库和本地数据库的同一个地方都发生了修改的情况下，因为无法自动判断要选用哪一个修改，所以就会发生冲突。Git会在发生冲突的地方修改文件的内容，需要我们手动修正冲突。如下命令以文本形式显示更新记录的流程图。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --oneline</span><br></pre></td></tr></table></figure>

<h2 id="修改提交时密码连接为SSH直接提交"><a href="#修改提交时密码连接为SSH直接提交" class="headerlink" title="修改提交时密码连接为SSH直接提交"></a>修改提交时密码连接为SSH直接提交</h2><p>使用如下命令查看远程克隆方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">origin  https://github.com/xujinzh/ph-novelty-detection.git (fetch)</span><br><span class="line">origin  https://github.com/xujinzh/ph-novelty-detection.git (push)</span><br></pre></td></tr></table></figure>

<p>如果已经添加本地机器的SSH公钥到GitHub了，那么直接，修改为SSH远程连接方式、</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">set</span>-url origin git@github.com:xujinzh/ph-novelty-detection.git</span><br></pre></td></tr></table></figure>

<p>再次使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remove -v</span><br></pre></td></tr></table></figure>

<p> 查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">origin  git@github.com:xujinzh/ph-novelty-detection.git (fetch)</span><br><span class="line">origin  git@github.com:xujinzh/ph-novelty-detection.git (push)</span><br></pre></td></tr></table></figure>

<p>这样，再次push代码时，就不需要输入用户名和密码了。</p>
<p>更多git相关知识请参考：</p>
<ul>
<li><p><a href="https://www.bootcss.com/p/git-guide/">git - 简易指南</a></p>
</li>
<li><p><a href="https://backlog.com/git-tutorial/cn/">猴子都能懂的GIT入门</a></p>
</li>
<li><p><a href="https://www.runoob.com/manual/github-git-cheat-sheet.pdf">GIT CHEAT SHEET</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 git 把本地代码保存到远程仓库</title>
    <url>/2021/10/21/git-new-local-codes-to-new-repo/</url>
    <content><![CDATA[<p>现如今大多数开发者都会将本地开发的代码托管到远程仓库，那如何将本地新创建的工程代码保存到远程服务器的新仓库呢？下面给出实现过程。</p>
<a id="more"></a>

<h1 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h1><p>以 github 为例。</p>
<p>登录账户，在界面右上交点击加号，选择 New repository，输入仓库名称，如 test，其他都不选。点击 Create repository</p>
<h1 id="本地代码托管"><a href="#本地代码托管" class="headerlink" title="本地代码托管"></a>本地代码托管</h1><p>在本地，将代码首先初始化 git，然后添加远程仓库地址，上传即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hello-test</span><br><span class="line">git init</span><br><span class="line">git remote add origin git@github.com:xujinzh/hello-test.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;release 1.0.0&quot;</span></span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
        <tag>gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>git 简单使用命令</title>
    <url>/2020/01/08/git-usage/</url>
    <content><![CDATA[<p>使用GitHub来保存本地代码，既能够防止代码丢失，又能够与Coders交流互动，那么如何使用git命令提交本地代码呢，下面介绍一下流程.</p>
<a id="more"></a>

<h1 id="远程GitHub已经建有一个仓库"><a href="#远程GitHub已经建有一个仓库" class="headerlink" title="远程GitHub已经建有一个仓库"></a>远程GitHub已经建有一个仓库</h1><p>如果远程GitHub上已经建有一个仓库，或者通过网页建成一个仓库，使用如下步骤进行</p>
<h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><p>网页上打开仓库首页，找到右上角的Clone or download</p>
<h3 id="使用SSH克隆仓库"><a href="#使用SSH克隆仓库" class="headerlink" title="使用SSH克隆仓库"></a>使用SSH克隆仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:user-name/your-repo-name.git</span><br></pre></td></tr></table></figure>

<p>该方法需要事先将本地用户目录下的公钥拷贝到本人GitHub网站的设置中的SSH keys中，具体方法如下：</p>
<p>拷贝所有内容到GitHub主页—右上角Settings—左侧SSH and GPG keys—SSH keys—New SSH key—随便写个名字在title栏，并粘贴刚刚拷贝的内容到key栏中—Add SSH key</p>
<p>测试SSH连接情况：</p>
<p>在终端中输入一下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>如果出现 Hi your-user-name! You’ve successfully authenticated, but GitHub does not provide shell access. 证明正确通过SSH连接GitHub</p>
<h3 id="使用https克隆仓库"><a href="#使用https克隆仓库" class="headerlink" title="使用https克隆仓库"></a>使用https克隆仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/user-name/your-repo-name.git</span><br></pre></td></tr></table></figure>

<h2 id="设置本地代码仓库提交者的用户名和用户邮箱"><a href="#设置本地代码仓库提交者的用户名和用户邮箱" class="headerlink" title="设置本地代码仓库提交者的用户名和用户邮箱"></a>设置本地代码仓库提交者的用户名和用户邮箱</h2><p>该节参考GitHub官网：<a href="https://help.github.com/cn/github/using-git/setting-your-username-in-git">在 Git 中设置用户名</a></p>
<h3 id="为计算机上的每个仓库设置-Git-用户名"><a href="#为计算机上的每个仓库设置-Git-用户名" class="headerlink" title="为计算机上的每个仓库设置 Git 用户名"></a><a href="https://help.github.com/cn/github/using-git/setting-your-username-in-git#">为计算机上的<em>每个</em>仓库设置 Git 用户名</a></h3><ol>
<li><p>打开 Git Bash。</p>
</li>
<li><p>设置 Git 用户名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;Mona Lisa&quot;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>确认您正确设置了 Git 用户名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Mona Lisa</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="为一个仓库设置-Git-用户名"><a href="#为一个仓库设置-Git-用户名" class="headerlink" title="为一个仓库设置 Git 用户名"></a><a href="https://help.github.com/cn/github/using-git/setting-your-username-in-git#setting-your-git-username-for-a-single-repository">为一个仓库设置 Git 用户名</a></h3><ol>
<li><p>打开 Git Bash。</p>
</li>
<li><p>将当前工作目录更改为您想要在其中配置与 Git 提交关联的名称的本地仓库。</p>
</li>
<li><p>设置 Git 用户名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config user.name <span class="string">&quot;Mona Lisa&quot;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>确认您正确设置了 Git 用户名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config user.name</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Mona Lisa</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="push本地代码到远程GitHub仓库"><a href="#push本地代码到远程GitHub仓库" class="headerlink" title="push本地代码到远程GitHub仓库"></a>push本地代码到远程GitHub仓库</h2><p> 进入本地代码库文件夹目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;test push&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>git push<a href="https://www.yiibai.com/git/git_push.html">命令</a> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> git push 使用方法</span></span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line">git push [--all | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=&lt;git-receive-pack&gt;]</span><br><span class="line">       [--repo=&lt;repository&gt;] [-f | --force] [-d | --delete] [--prune] [-v | --verbose]</span><br><span class="line">       [-u | --set-upstream] [--push-option=&lt;string&gt;]</span><br><span class="line">       [--[no-]signed|--sign=(true|false|if-asked)]</span><br><span class="line">       [--force-with-lease[=&lt;refname&gt;[:&lt;expect&gt;]]]</span><br><span class="line">       [--no-verify] [&lt;repository&gt; [&lt;refspec&gt;…]]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将本地master主分支推送到远程仓库origin的master主分支。当master不存在时，新建远程master主分支</span></span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程仓库origin的master主分支</span></span><br><span class="line">git push origin :master</span><br><span class="line">git push origin --delete master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地分支和远程分支存在链接/追踪关系，可省略本地分支和远程分支名</span></span><br><span class="line">git push origin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地分支只有一个链接/追踪分支，可省略远程仓库名</span></span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地仓库与多个远程仓库存在链接/追踪关系，可使用-u（--<span class="built_in">set</span>-upstream）指定默认远程仓库名，这样后面可以不加参数使用git push</span></span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令</span></span><br><span class="line"></span><br><span class="line">git config --global push.default matching</span><br><span class="line">git config --global push.default simple</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不管是否存在对应的远程分支，将本地的所有分支都推送到远程仓库，这时需要使用–all选项</span></span><br><span class="line">git push --all origin </span><br></pre></td></tr></table></figure>



<h2 id="pull远程仓库"><a href="#pull远程仓库" class="headerlink" title="pull远程仓库"></a>pull远程仓库</h2><p>当远程仓库更新比本地仓库快时，需要从远程仓库更新本地仓库到最新，命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h1 id="远程GitHub没有仓库"><a href="#远程GitHub没有仓库" class="headerlink" title="远程GitHub没有仓库"></a>远程GitHub没有仓库</h1><p>当远程GitHub个人网站下没有需要的仓库时，需要首先在网页下创建远程仓库，如仓库名为cvRepo</p>
<p>在本地创建同名仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir cvRepo</span><br></pre></td></tr></table></figure>

<p>进入仓库目录，并初始化本地仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> cvRepo</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>git 本地代码到远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;cv codes&quot;</span></span><br><span class="line">git remote add origin git@github.com:user-name/your-repo-name.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h1 id="修改git默认编辑器为vim"><a href="#修改git默认编辑器为vim" class="headerlink" title="修改git默认编辑器为vim"></a>修改git默认编辑器为vim</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.edit vim</span><br></pre></td></tr></table></figure>

<p>查看是否成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list | grep vim</span><br></pre></td></tr></table></figure>

<p>更多git使用技巧请参考GitHub官网的<a href="https://help.github.com/cn/github/using-git">使用 Git</a></p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 生成错误问题</title>
    <url>/2020/08/28/hexo-error-maths-cardinality/</url>
    <content><![CDATA[<p>Hexo 写完博文后，使用如下命令生成静态页面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>

<p>出现如下错误</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Error: expected end of comment, got end of file</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<a id="more"></a>

<ol>
<li><p>使用命令找到出错的文档是哪一个</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo generate --debug</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>检查文档中是否出现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;#</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li>尝试去除上面的 ‘{‘ 和 ‘#’</li>
</ol>
<p>参考文献</p>
<p><a href="https://www.dyxmq.cn/cloud/hexo/the-hexo-error-expected-end-of-comment.html">起风了</a></p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 GitHub 和 HEXO 随时随地书写博客</title>
    <url>/2020/03/03/hexo-home-work/</url>
    <content><![CDATA[<p>当使用 GitHub + HEXO + Markdown 部署个人博客时，总是希望能够在家和在单位都能够随时随地写博客，记录当时的工作或灵感。本篇文章介绍如何完成家庭和单位无缝衔接的去自由书写博客。如何搭建博客请参考我的另一篇文章： <a href="https://xujinzh.github.io/2019/12/20/%E4%BD%BF%E7%94%A8GitHub%20%E4%B8%8E%20Hexo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/">利用 Hexo and Github 搭建个人博客</a> .</p>
<a id="more"></a>

<h1 id="在-GitHub-上新建一个仓库"><a href="#在-GitHub-上新建一个仓库" class="headerlink" title="在 GitHub 上新建一个仓库"></a>在 GitHub 上新建一个仓库</h1><p>在 GitHub 上创建一个仓库，用以保持和同步博客源文件（包括博客文章、主题等内容）</p>
<p>比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git@github.com:xujinzh/JBlog.git</span><br></pre></td></tr></table></figure>



<h1 id="将本地博客同步到-GitHub"><a href="#将本地博客同步到-GitHub" class="headerlink" title="将本地博客同步到 GitHub"></a>将本地博客同步到 GitHub</h1><p>如果你当前的博客源文件是在单位，那么，我们将该文件夹同步上传到 GitHub 上。步骤如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> JBlog</span><br><span class="line">git init</span><br><span class="line">git remote add origin git@github.com:xujinzh/JBlog.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;release 1.0.0&quot;</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>



<h1 id="将-GitHub-仓库克隆到本地"><a href="#将-GitHub-仓库克隆到本地" class="headerlink" title="将 GitHub 仓库克隆到本地"></a>将 GitHub 仓库克隆到本地</h1><p>回到家，将 GitHub 上的仓库克隆到家里 Mac 上。注意，该Mac上首先需要安装 hexo，步骤如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install node</span><br><span class="line">sudo npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>克隆仓库到本地Mac上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:xujinzh/JBlog.git /Users/jinzhongxu/github/JBlog</span><br></pre></td></tr></table></figure>

<p>此时，运行 hexo -v 会发生如下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ERROR Local hexo not found <span class="keyword">in</span> ....</span><br><span class="line">ERROR Try running: <span class="string">&#x27;npm install hexo --save&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这是由于.gitignore 中缺少 node_modules 文件夹，没有更新上去。解决方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> JBlog</span><br><span class="line">npm cache clean --force</span><br><span class="line">npm install -g npm</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看博客显示，本地模式 http://localhost:4000</span></span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --force</span><br></pre></td></tr></table></figure>

<p>到此，就可以正常使用了。</p>
<h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p>在家写文章</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new mac-test</span><br></pre></td></tr></table></figure>

<p>然后打开 mac-test.md 写文章，然后，部署文章到网址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>

<p>之后，将更新推送到 GitHub 仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;new article&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>如果是第一次 push，请使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>它会记住你的提交分支情况，这样以后就可以直接 git push 了。</p>
<p>回到办公室，首先从 GitHub 仓库拉去最新</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>然后，开始写文章，记住发布完文章后，记得 push 到 GitHub 仓库。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://docs.github.com/cn/get-started/getting-started-with-git/managing-remote-repositories">管理远程仓库</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客评论系统gitalk</title>
    <url>/2020/03/14/hexo-gitalk/</url>
    <content><![CDATA[<p>Hexo结合GitHub进行博客系统搭建，能够免费的畅享GitHub给我们带来的无限量服务。下面假设</p>
<ol>
<li>hexo博客已经搭建好了</li>
<li>主页地址是：<a href="https://xujinzh.github.io/">https://xujinzh.github.io/</a></li>
<li>并且在GitHub上创建了gitalk仓库：<a href="https://github.com/xujinzh/gitalk-comments.git">https://github.com/xujinzh/gitalk-comments.git</a> </li>
</ol>
<a id="more"></a>

<h1 id="注册新应用"><a href="#注册新应用" class="headerlink" title="注册新应用"></a>注册新应用</h1><p>打开网址：<a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a></p>
<ul>
<li>在<strong>Application name</strong>一栏填写应用名称，可随意填写，但必须填写</li>
<li><strong>Homepage URL</strong>一栏填写博客主页，必填，我这里是：<a href="https://xujinzh.github.io/">https://xujinzh.github.io/</a></li>
<li>Application description一栏是对该应用的描述信息，可以选填</li>
<li><strong>Authorization callback URL</strong>一栏是应用程序的回调URL，也是博客主页，必填，我这里是：<a href="https://xujinzh.github.io/">https://xujinzh.github.io/</a></li>
</ul>
<p>点击注册后，会跳转到应用信息页，显示有该应用的用户<strong>Client ID</strong>和<strong>Client Secret</strong>，这两个参数在下面配置项中将用到，请保持打开该页面，方便进行一下的配置。</p>
<h1 id="配置gitalk"><a href="#配置gitalk" class="headerlink" title="配置gitalk"></a>配置gitalk</h1><h2 id="新方法"><a href="#新方法" class="headerlink" title="新方法"></a>新方法</h2><p>推荐使用最新配置的方法，只需要配置主题里面的 <code>_config.xml</code> 或 主目录下的  <code>_config.next.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Gitalk</span></span><br><span class="line"><span class="comment"># For more information: https://gitalk.github.io</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_id:</span> <span class="string">xujinzh</span> <span class="comment"># GitHub repo owner</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">xujinzh.github.io</span> <span class="comment"># Repository name to store issues</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="number">6</span><span class="string">**5</span> <span class="comment"># GitHub Application Client ID</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="number">9</span><span class="string">**5</span> <span class="comment"># GitHub Application Client Secret</span></span><br><span class="line">  <span class="attr">admin_user:</span> <span class="string">xujinzh</span> <span class="comment"># GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span></span><br><span class="line">  <span class="attr">distraction_free_mode:</span> <span class="literal">true</span> <span class="comment"># Facebook-like distraction free mode</span></span><br><span class="line">  <span class="comment"># When the official proxy is not available, you can change it to your own proxy address</span></span><br><span class="line">  <span class="attr">proxy:</span> <span class="string">https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token</span> <span class="comment"># This is official proxy address</span></span><br><span class="line">  <span class="comment"># Gitalk&#x27;s display language depends on user&#x27;s browser or system environment</span></span><br><span class="line">  <span class="comment"># If you want everyone visiting your site to see a uniform language, you can set a force language value</span></span><br><span class="line">  <span class="comment"># Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">en</span></span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ol>
<li><a href="https://www.jianshu.com/p/02fc71f3633f">Hexo 集成 Gitalk 评论系统</a></li>
</ol>
<h2 id="旧方法"><a href="#旧方法" class="headerlink" title="旧方法"></a>旧方法</h2><p>这里<strong>“~”</strong>表示博客主目录</p>
<ol>
<li><p>在目录**~\themes\next\layout_third-party\comments**下创建<code>gitalk.swig</code> 文件，并插入如下内容</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">  &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script src=<span class="string">&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> gitalk = new <span class="type">Gitalk</span>(&#123;</span><br><span class="line">          clientID: &#x27;&#123;&#123; theme.gitalk.<span class="type">ClientID</span> &#125;&#125;&#x27;,</span><br><span class="line">          clientSecret: &#x27;&#123;&#123; theme.gitalk.<span class="type">ClientSecret</span> &#125;&#125;&#x27;,</span><br><span class="line">          repo: &#x27;&#123;&#123; theme.gitalk.repo &#125;&#125;&#x27;,</span><br><span class="line">          owner: &#x27;&#123;&#123; theme.gitalk.githubID &#125;&#125;&#x27;,</span><br><span class="line">          admin: [&#x27;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&#x27;],</span><br><span class="line">          id: location.pathname,</span><br><span class="line">          distractionFreeMode: &#x27;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&#x27;</span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(&#x27;gitalk-container&#x27;)           </span><br><span class="line">       &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改**~\themes\next\layout_partials<strong>下的<code>comments.swig</code> 文件，添加如下内容的</strong>第5、6行**。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  &#123;% elseif theme.valine.appid and theme.valine.appkey %&#125;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span>=&quot;<span class="title">comments</span>&quot; <span class="title">id</span>=&quot;<span class="title">comments</span>&quot;&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  </span>&#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line">	&lt;div id=<span class="string">&quot;gitalk-container&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>修改**~\themes\next\layout_third-party\comments**下的<code>index.swig</code>文件，在最后一行添加如下内容</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123;% include &#x27;gitalk.swig&#x27; %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在目录**~\themes\next\source\css_common\components\third-party**下新建文件<code>gitalk.styl</code>，添加如下内容</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.gt-header a, .gt-comments a, .gt-popup a</span><br><span class="line">  border-bottom: <span class="keyword">none</span>;</span><br><span class="line">.gt-container .gt-popup .gt-action.<span class="keyword">is</span>--active:before</span><br><span class="line">  top: <span class="number">0</span>.7em;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改目录**~\themes\next\source\css_common\components\third-party**下的<code>third-party.styl</code>，再最后一行添加如下内容</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">import</span> &quot;gitalk&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改目录**~\themes\next**下的<code>_config.yml</code>文件，添加如下内容</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  githubID: xujinzh</span><br><span class="line">  repo: gitalk-comments</span><br><span class="line">  <span class="type">ClientID</span>: <span class="type">Client</span> <span class="type">ID</span></span><br><span class="line">  <span class="type">ClientSecret</span>: <span class="type">Client</span> <span class="type">Secret</span></span><br><span class="line">  adminUser: xujinzh  #此项为初始化评论账号，每一篇文章都需要该用户初始化评论后其他人才可以评论</span><br><span class="line">  distractionFreeMode: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>该部分可参考：<a href="https://cjjkkk.github.io/gitalk/">使用gittalk实现hexo博客评论功能</a>.</p>
<h1 id="busuanzi网站统计"><a href="#busuanzi网站统计" class="headerlink" title="busuanzi网站统计"></a>busuanzi网站统计</h1><p>不蒜子的官网：<a href="http://busuanzi.ibruce.info/">http://busuanzi.ibruce.info/</a></p>
<p>按照官网教程，需要把以下代码添加到文件**~\themes\next\layout_partials\footer.swig**最后一行，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&lt;script async src=<span class="string">&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;span id=<span class="string">&quot;busuanzi_container_site_pv&quot;</span>&gt;本站总访问量&lt;span id=<span class="string">&quot;busuanzi_value_site_pv&quot;</span>&gt;&lt;/span&gt;次&lt;/span&gt;</span><br><span class="line">&lt;span id=<span class="string">&quot;busuanzi_container_site_uv&quot;</span>&gt;本站访客数&lt;span id=<span class="string">&quot;busuanzi_value_site_uv&quot;</span>&gt;&lt;/span&gt;人次</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>修改文件：**~\themes\next_config.yml**的如下内容</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  # <span class="built_in">count</span> values only <span class="keyword">if</span> the other configs are <span class="literal">false</span></span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  # custom uv span <span class="keyword">for</span> the whole site</span><br><span class="line">  site_uv: <span class="literal">true</span></span><br><span class="line">  site_uv_header: &lt;i <span class="class"><span class="keyword">class</span>=&quot;<span class="title">fa</span> <span class="title">fa</span>-<span class="title">user</span>&quot;&gt;&lt;/<span class="title">i</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">site_uv_footer</span>:</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  # <span class="title">custom</span> <span class="title">pv</span> <span class="title">span</span> <span class="title">for</span> <span class="title">the</span> <span class="title">whole</span> <span class="title">site</span></span></span><br><span class="line"><span class="class">  <span class="title">site_pv</span>: <span class="title">true</span></span></span><br><span class="line"><span class="class">  <span class="title">site_pv_header</span>: &lt;<span class="title">i</span> <span class="title">class</span>=&quot;<span class="title">fa</span> <span class="title">fa</span>-<span class="title">eye</span>&quot;&gt;&lt;/<span class="title">i</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">site_pv_footer</span>:</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  # <span class="title">custom</span> <span class="title">pv</span> <span class="title">span</span> <span class="title">for</span> <span class="title">one</span> <span class="title">page</span> <span class="title">only</span></span></span><br><span class="line"><span class="class">  <span class="title">page_pv</span>: <span class="title">true</span></span></span><br><span class="line"><span class="class">  <span class="title">page_pv_header</span>: &lt;<span class="title">i</span> <span class="title">class</span>=&quot;<span class="title">fa</span> <span class="title">fa</span>-<span class="title">file</span>-<span class="title">o</span>&quot;&gt;&lt;/<span class="title">i</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">page_pv_footer</span>:</span></span><br></pre></td></tr></table></figure>

<p>注意，这里<strong>site_pv</strong>和<strong>site_uv</strong> 设置为true时和上面的<strong>本站总访问量</strong>和<strong>本站访客数</strong> 重复，只需设置一处即可。我使用下着，所以，文件**~\themes\next\layout_partials\footer.swig**最后一行，我只添加了如下内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&lt;script async src=<span class="string">&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>gitalk</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题菜单栏链接显示乱码问题</title>
    <url>/2020/03/15/hexo-next-menu-sidebar/</url>
    <content><![CDATA[<p>Hexo + Next + Github搭配使用搭建博客是非常流行和方便的，不需要购买服务器和域名，充分发挥GitHub的作用。但是，当我搭建博客时也遇到过关于Next主题的Menu菜单和边框栏设置的问题。不过最后总算解决了，这里记录下来提供给有需要的小伙伴也为自己留个记忆，以备后用。</p>
<a id="more"></a>

<h1 id="Next的菜单图标显示"><a href="#Next的菜单图标显示" class="headerlink" title="Next的菜单图标显示"></a>Next的菜单图标显示</h1><ol>
<li>打开主题配置文件，<strong>～/themes/next/_config.yml</strong> , 把相应注释去掉，这里选择你要展示的页面。如下：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line"> home: /|| home</span><br><span class="line"> about: /about/|| user</span><br><span class="line"> tags: /tags/|| tags</span><br><span class="line"> categories: /categories/|| th</span><br><span class="line"> archives: /archives/|| archive</span><br><span class="line"> \#schedule: /schedule/ || calendar</span><br><span class="line"> \#sitemap: /sitemap.xml || sitemap</span><br><span class="line"> \#commonweal: /<span class="number">404</span>/ || heartbeat</span><br></pre></td></tr></table></figure>

<p>注意，<strong>about, tags, categories</strong>三个页面需要通过<strong>hexo new page “about”、hexo new page “tags”、hexo new page “categories”</strong> 等命令新建，在<strong>～/sources/**下面会出现相应的文件夹，打开文件夹里面的index命名的markdown文件，添加相应的类型，如</strong>type: “about”<strong>，</strong>tags** 文件夹下的markdown文件添加<strong>type: “tags”**，</strong>categories** 文件夹下的markdown文件添加<strong>type: “categories”**。</strong>archives** 页面不需要新建，注视掉上面相应行就好。</p>
<p>另外，注意将原来的 <strong>/ | |</strong> 之间的空格去掉，不然会出现点击页面标签在url地址后多出**%20** .类似于，<a href="https://xujinzh.github.io/%20">https://xujinzh.github.io/%20</a>. </p>
<ol start="2">
<li>修改如下内容，打开菜单图标功能</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"># <span class="type">Enable</span>/<span class="type">Disable</span> menu icons.</span><br><span class="line">menu_icons:</span><br><span class="line"> enable: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h1 id="Next的侧边栏图标链接显示"><a href="#Next的侧边栏图标链接显示" class="headerlink" title="Next的侧边栏图标链接显示"></a>Next的侧边栏图标链接显示</h1><p>当设置完上面的内容后，菜单图标和链接都可以使用了，但是，在侧边栏地方会出现一些小问题，就是<strong>posts</strong>，点击该链接会打不开网址，出现乱码，这里需要修改<strong>～/themes/next/layout/_macro/sidebar.swig</strong> 里面如下内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;&#123;&#123; url_for(theme.menu.archives.split(&#x27;||&#x27;)[0]) | trim &#125;&#125;&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>即，将<strong>archives</strong>后面的小括号 <strong>‘)’</strong>，往后面提到 **[0]**后面。</p>
<p>吃水不忘挖井人，参考链接：<a href="https://blog.csdn.net/fullbug/article/details/103844424">解决Hexo博客导航栏链接URL乱码问题</a></p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>menu</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 大括号渲染</title>
    <url>/2021/11/19/hexo-markdown-big-brace/</url>
    <content><![CDATA[<p>Hexo 生成 markdown 撰写的博文中含有公式大括号 $\lbrace$ 和 $\rbrace$ 时，发布网站上大括号消失。本篇给出可能的原因，和解决方法。</p>
<a id="more"></a>

<h1 id="可能原因"><a href="#可能原因" class="headerlink" title="可能原因"></a>可能原因</h1><p>在使用公式编辑大括号时，采用了如下的形式</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$ E = \min<span class="emphasis">_&#123;v \in V&#125; \&#123;u \in V | w(u,v) &gt; 0\&#125; $</span></span><br></pre></td></tr></table></figure>

<p>$$<br>E = \min_{v \in V} {u \in V | w(u,v) &gt; 0}<br>$$</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>把</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\&#123; \&#125;</span><br></pre></td></tr></table></figure>

<p>替换为</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\lbrace \rbrace</span><br></pre></td></tr></table></figure>

<p>结果示例</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$ E = \min<span class="emphasis">_&#123;v \in V&#125; \lbrace u \in V | w(u,v) &gt; 0\rbrace $</span></span><br></pre></td></tr></table></figure>

<p>$$<br>E = \min_{v \in V} \lbrace u \in V | w(u,v) &gt; 0\rbrace<br>$$</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://lanlan2017.github.io/blog/14ee6880/">Hexo Next主题Mathjax 大括号渲染错误</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 HEXO 博客搜索功能不稳定问题</title>
    <url>/2021/11/10/hexo-search-disorder/</url>
    <content><![CDATA[<p>Hexo + GitHub (or VPS) + Markdown 搭配完成博文撰写与发布，记录个人每天学习到的知识以及产生的灵感，是非常方便的。但是，最近发现我的博客出现搜索功能紊乱的问题，有些博文明明存在却搜索不到。因此，经过长时间的探索发现一种解决方法。特此记录下来。</p>
<a id="more"></a>

<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在登录到博客网站后，想要通过关键字搜索某篇博文，搜索不到，但是确信博文是存在的。经过一页一页翻找，确实找到了博文。断定搜索功能失效。</p>
<p>尝试，在本地重新生成和部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">hexo clean</span><br><span class="line">hexo generate </span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>再重新打开博文进行搜索，发现可以使用。但是，写完博文后再次生成部署，发现搜索功能又失效。</p>
<h1 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h1><p>通过网站直接访问搜索网页： <a href="https://xujinzh.github.io/search.xml">https://xujinzh.github.io/search.xml</a></p>
<p>发现在顶部有红色错误提示，第$i$行和第$j$列，字符编码错误。</p>
<p>在本地打开 <code>public/search.xml</code> 的第 $i$ 行和第 $j$ 列，看看它属于哪篇博文。</p>
<p>在博文中检查是否有不合法的字符出现。清除掉它们。</p>
<h1 id="重新生成和部署"><a href="#重新生成和部署" class="headerlink" title="重新生成和部署"></a>重新生成和部署</h1><p>清理完所有非法字符后，建议先清除，然后再重新生成和部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line"><span class="comment"># 先清除</span></span><br><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p>之后，在博客上发现搜索功能恢复。重试多次清除、生成和部署后，都能够准确搜索。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://blog.csdn.net/Strong997/article/details/104887353">Hexo本地搜索失效</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title>如何进行目标跟踪</title>
    <url>/2020/08/24/how-to-object-tracking/</url>
    <content><![CDATA[<p>前一篇我们介绍了目标跟踪的基本原理是定义目标、生成候选框、提取特征、匹配最优候选框。根据这一原理，本篇介绍如何具体进行目标跟踪。</p>
<p>从具体的流程上来说，一次实现过程如下</p>
<p>输入图像（前一帧）—&gt; <strong>候选框生成模型</strong> —&gt; <strong>特征提取模型</strong> —&gt; <strong>最优候选框模型</strong> —&gt; 输出带有预测候选框的图像（后续帧）</p>
<a id="more"></a>

<h1 id="候选框生成模型"><a href="#候选框生成模型" class="headerlink" title="候选框生成模型"></a>候选框生成模型</h1><p>从前一帧到后续帧，目标可能出现位置变化、尺寸变化、旋转、光照变化等，因此需要对这些变化进行建模表示，常用的方法有概率采样方法、滑窗方法、循环移位方法等</p>
<h2 id="概率采样方法"><a href="#概率采样方法" class="headerlink" title="概率采样方法"></a>概率采样方法</h2><p>通过放射变换得到候选框。假设前一帧的矩形框的为$x$，仿射变换的系数矩阵为$A$，后续帧的候选框为$y$，则<br>$$<br>y=Ax<br>$$<br>其中，仿射变换矩阵$A$描述了目标的位置变换、尺寸变换、旋转变换、长宽比变换等信息。</p>
<p>概率采样表示放射变换矩阵$A$中的各个参数符合某种概率分别（如高斯分布）的随机变量，并生成不同数量的候选框。</p>
<h2 id="滑窗方法"><a href="#滑窗方法" class="headerlink" title="滑窗方法"></a>滑窗方法</h2><p>滑窗方法模拟目标在视频中的移动过程。以某个形状和大小的结构元素（称为窗）在前一帧中按一定的空间间隔移动，每次移动后覆盖的图像中的相应像素即为后续帧的候选框。该方法只能表示位置变换，其他如尺寸变换、旋转变换还需进一步处理。</p>
<h2 id="循环移位方法"><a href="#循环移位方法" class="headerlink" title="循环移位方法"></a>循环移位方法</h2><p>本质上来说，循环移位方法是滑窗方法的一种。但其使用较广，所以单独列出。将前一帧矩形框中的像素按照某种排列组成一个向量$a$，以向量$a$为基准向量生成循环矩阵。其中循环矩阵的每一行都对应一个候选框，求得该循环矩阵得最大特征值认为是最优的矩形框。该方法生成的候选框仅仅具有位置变换（如旋转变换），其他变换需要额外处理。因利用快速傅里叶变换求解循环矩阵的特征值比较快速，因此利用该生成模型的相关滤波算法速度较快，即具有较高的FPS.</p>
<h1 id="特征提取模型"><a href="#特征提取模型" class="headerlink" title="特征提取模型"></a>特征提取模型</h1><p>得到候选框后，还需要进一步的从候选框中提取图像特征。常用的特征包括颜色特征、空间特征、形状特征、纹理特征、深度卷积特征等。特征越“深”（抽象但不直观，深度特征），对目标判别能力好，特征越“浅”（具体且直观，如颜色特征），对目标的空间位置信息保留越好。想好了需要哪些图像特征后，就需要把这些特征表示成计算机能够理解和计算的数值量，常用的方法包括朴素方法（naive，像素值）、统计方法（statistics，直方图）、数学变换（transform，像素值梯度等）</p>
<p>特征提取模型就是特征和提取方法的结合。概括起来就是</p>
<p>特征包括颜色、形状、纹理等，颜色包括灰度、彩色等</p>
<p>提取方法包括朴素方法、统计方法、变换方法等，朴素方法如像素值，统计方法如直方图，变换方法如梯度等</p>
<h2 id="特征模型的分类"><a href="#特征模型的分类" class="headerlink" title="特征模型的分类"></a>特征模型的分类</h2><p>特征模型按大类别分为手工提取特征（Hand-Crafted）和深度学习提取的深度特征（Deep-Learning，如CNN）。</p>
<p>其中，手工提取特征方法包括Naive、Histogram series、Haar-lik等，Naive包括Gray-scale、Color，Histogram series包括Histogram of colors (HoC)、Histogram of gradients（HoG)，Color包括RGB、HSV、Color Names(CN)、LAB等。</p>
<h1 id="最优候选框模型"><a href="#最优候选框模型" class="headerlink" title="最优候选框模型"></a>最优候选框模型</h1><p>在目标跟踪中，如何从候选框中选择最优的矩形框作为后续帧的目标预测是非常重要的和主要问题，直观上，就是从后续帧中找到与前一帧最“像”的目标，但这个“像”可以有多种定义方法。</p>
<p>在计算机视觉中，该问题就是一个匹配问题，是目标跟踪的核心问题，它直接影响着算法的性能。及时前两部差强人意，但是优秀的匹配算法能够在一定程度上弥补它们的不足。</p>
<p>匹配就是一个相似性度量的问题。比较的对象是前一帧的目标矩形框（常称为ground truth）和后续帧的各候选框（bounding-box）。可以将它们之间的相似度用距离来衡量，这里的距离是抽象距离，如空间距离（两个矩形框之间像素的距离，如 Minkowski distance $l^p$、Manhattan distance $l^1$、Euclidean distance $l^2$、Chebyshev distance $l^{\infty}$），可以是两个概率分布的距离（矩形框服从的概率分布），如Kullback–Leibler (KL) 散度，Bhattacharyya distance， 交叉熵，Wasserstein distance 等。</p>
<p>该模型主流的匹配方法有两种，分别是生成式方法（generative）和判别式方法（discriminative），主要区别就在于是否有背景信息的引入，生成式方法把跟踪问题建模成拟合或多分类问题，而判别式方法把跟踪问题定义为二分类问题。</p>
<p>一般在几帧匹配算法后会引入更新模块，这是因为，匹配算法得到了一系列的参数，应用这些参数即可对当前帧的目标位置进行预测。如果在后续所有帧的预测过程中都应用这些参数，可能会出现的结果是预测趋向不准确，最终导致跟踪的失败。其可能的原因包括累积误差、外因（如遮挡、光照变化）、以及内因（如目标外观变化、快速运动）等。如果引入更新模块，在每若干帧之后根据之前的预测结果更新匹配算法的参数，则可以减小误差，提高跟踪的准确性。</p>
<p>但是，并不是每一帧都要进行更新模块，因为这样会消耗更多时间，导致跟踪的FPS较低。研究者更多的是采用多步一更新的策略。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://developer.aliyun.com/article/766769">视觉目标跟踪漫谈：从原理到应用</a> </p>
]]></content>
      <categories>
        <category>research</category>
        <category>object tracking</category>
      </categories>
      <tags>
        <tag>vot</tag>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title>匈牙利匹配算法</title>
    <url>/2021/11/19/hungarian-matching-algorithm/</url>
    <content><![CDATA[<p>匈牙利匹配算法（<strong>Hungarian Matching Algorithm</strong>)，也称为 Kuhn-Munkres 算法，是一个 $O\big(|V|^3\big)$ （$V$ 表示二分图的顶点集）算法，可用于在二分图中找到最大权重匹配，有时称为分配问题。匈牙利算法在 文章 End-to-End Object Detection with Transformers 中提出 DETR 算法中被采用，用于匹配预测目标框与真实目标框。初次之外，该算法也在多目标跟踪、实例分割、多人3D位姿估计等领域中发挥作用。因此，本篇对匈牙利算法进行讲解。</p>
<a id="more"></a>

<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p><strong>匈牙利算法</strong>是一种在<strong>多项式时间</strong>内求解<strong>任务分配问题</strong>的<strong>组合优化算法</strong>，并推动了后来的<strong>原始对偶方法</strong>。美国数学家<strong>哈罗德·库恩</strong>于 1955 年提出该算法。此算法之所以被称作匈牙利算法，是因为算法很大一部分是基于以前<strong>匈牙利</strong>数学家 Dénes Kőnig 和 Jenő Egerváry 的工作之上创建起来的。</p>
<p><strong>詹姆士·芒克勒斯</strong>在 1957 年回顾了该算法，并发现<strong>（强）多项式时间</strong>的复杂度。此后该算法被称为 <strong>Kuhn–Munkres 算法</strong>或 <strong>Munkres 分配算法</strong>。原始算法的<strong>时间复杂度</strong>为 $O(|V|^4)$，但<strong>杰克·爱德蒙斯</strong>与<strong>卡普</strong>发现可以修改算法达到 $O(|V|^3)$运行时间，富泽也独立发现了这一点。<strong>L·R·福特</strong>和<strong>D·R·福尔克森</strong>将该方法推广到了一般运输问题。2006 年发现<strong>卡尔·雅可比</strong>在 19 世纪就解决了指派问题，该解法在他死后在 1890 年以拉丁文发表。</p>
<h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><p>图 $G = (V, E)$ 是二分的（bipartite），如果存在一个划分使得<br>$$<br>V = X \cup Y, X \cap Y = \emptyset, E \subseteq X \times Y.<br>$$<br>这里 $V$ 是顶点集，$E$ 是边集。换句话说，就是顶点集合分成两类，每类之间的顶点没有边相连接，只有不同顶点集合的点之间才可以有边相连接。</p>
<p>匹配（matching）$M \subseteq E$ 是一个边集合，使得 $\forall v \in V$ 至多只属于 $M$ 中的一个边。匹配 $M$ 中边的个数称为匹配的大小，记作 $|M|$. 最大匹配（maximum matching）是一个匹配，使得任何其他匹配 $M^{\prime}$ 满足 $|M^{\prime}| \leq |M|$.</p>
<p>顶点 $v$ 是匹配的，如果它是匹配 $M$ 的某个边的端点，否则，称为是自由的。</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ot/hungarian/alternating-paths.png"></p>
<p>如上图左图，$Y_2$, $Y_3$, $Y_4$, $Y_6$, $X_2$, $X_4$, $X_5$, $X_6$ 是匹配的，其他点是自由的。</p>
<p>一个边集合 $P \subseteq E$ 是道路，如果 $P$ 中的所有边都连接在一起。一个道路是交替的，如果它的边交替取自 $M$ 和 $E-M$. 如上图右图，$Y_1$, $X_2$, $Y_2$, $X_4$, $Y_4$, $X_5$, $Y_3$, $X_3$ 是交替的。</p>
<p>一个交替道路是增广交替道路，如果它的两个端点都是自由的。</p>
<p>一个匹配 $M$ 是完美匹配，如果任意的顶点都是 $M$ 中的某个边的端点。</p>
<p>对于加权二分图，就是每个边 $v=(i,j)$ 都分配权重值 $w(i,j)$. 匹配 $M$ 的权值是其中所有边的权值和，即<br>$$<br>w(M) = \sum_{e \in M} w(e).<br>$$<br>二分图匹配问题可以分为两种，一种是求解最大匹配，一种是求解最大权重匹配。第一种是不考虑边权重，只需要找到匹配 $M$ 使得匹配的大小 $|M|$ 最大。第二种是假设每条边的权重不是相同的，需要找到匹配 $M$ 使得匹配的权值 $w(M)$ 最大。其实，第一种可以看作是第二种的特殊情形，只需要把权重看作相同即可。因此，本篇以第二种为例进行介绍。</p>
<p><strong>最大权重匹配一定是完美匹配。</strong></p>
<p>一个二分图是完全的，如果两个顶点集合 $X$, $Y$ 中，任意的点 $x \in X (y \in Y)$ 都与 $y \in Y (x \in X)$ 中的点有边 $e \in E$ 相连。如果一个二分图不是完全的，可以考虑把它变成完全的，通过添加权重为 0 的边。当求解的是最大匹配问题时，添加权重为 inf 的边。</p>
<p>二分图可以很容易地用邻接矩阵表示，其中边的权重是矩阵元素。从邻接矩阵的角度考虑图形对于匈牙利算法很有用。</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ot/hungarian/matching-matrxi.png"></p>
<h1 id="使用邻接均值的匈牙利算法"><a href="#使用邻接均值的匈牙利算法" class="headerlink" title="使用邻接均值的匈牙利算法"></a>使用邻接均值的匈牙利算法</h1><p>假设您想举办一个派对，并且您想要一位音乐家(musician)进行表演，一位厨师(chef)准备食物，以及在派对结束后进行清洁服务的清洁工(cleaner)。有 3 家公司提供这三种服务中的每一种，但一家公司一次只能提供一种服务（即 B 公司不能同时提供清洁工和厨师）。您正在决定应该从哪家公司购买每项服务，以最大限度地减少聚会的成本。你意识到这是分配问题的一个例子，并着手根据以下信息制作一个图表：</p>
<table>
<thead>
<tr>
<th>公司</th>
<th>音乐家</th>
<th>厨师</th>
<th>清洁工</th>
</tr>
</thead>
<tbody><tr>
<td>公司 A</td>
<td>108</td>
<td>125</td>
<td>150</td>
</tr>
<tr>
<td>公司 B</td>
<td>150</td>
<td>135</td>
<td>175</td>
</tr>
<tr>
<td>公司 C</td>
<td>122</td>
<td>148</td>
<td>250</td>
</tr>
</tbody></table>
<p>用二分图表示如下</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ot/hungarian/matrix-bigraph-example.png"></p>
<p>如何解决上面的最大权重匹配问题，可以考虑蛮力法，列举所有的可能组合，但是，当二分部越来越大时，这将是非常低效的。</p>
<p>求二分图的最大权重匹配和最小权重匹配没有什么本质区别。对于二分图，只需要把权重系数用最大的减去所有边的权重，把二分图的最大权重匹配问题转化为求最小权重匹配。当考虑权重和最小时，我们称邻接矩阵是成本矩阵(cost matrix)；当考虑权重和最大时，我们称邻接矩阵是效益矩阵(profit matrix)。</p>
<p>考虑到上述示例中的成本矩阵，匈牙利算法基于这一关键思想进行操作：如果在成本矩阵的任何一行或一列的所有条目中添加或减去一个数字，则为由此产生的成本矩阵也是原始成本矩阵的最佳匹配。</p>
<p>如下算法将最小权重匹配问题转化为 0 匹配问题。即把寻找权重和最小的匹配转化为寻找权重和等于 0 的匹配。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">匈牙利方法，针对 n x n 成本矩阵。</span><br><span class="line">1. 对于每一行，把所有元素减去该行中的最小元素。这将使每行中的最小元素等于 0；</span><br><span class="line">2. 对于每一列，把所有元素减去该列中的最小元素（可能取到上一次行操作得到的 0）。这将使每列中的最小元素等于 0；</span><br><span class="line">3. 画最少的线（行或列），使得覆盖所有的 0； </span><br><span class="line">4. 如果绘制了 n 条线，则得到了最佳的零匹配，算法完成。如果条数小于 n，则尚未达到最佳的零匹配，进入下一步； </span><br><span class="line">5. 找到未被任何线覆盖的最小元素。从未划掉的每一行中减去该元素，并将最小元素添加到划掉的每一列中（使得列中的最小元素仍然是 0 ）。然后，返回到步骤 3。</span><br></pre></td></tr></table></figure>

<p>利用匈牙利算法求解上面的最小权重匹配问题。</p>
<p>初始邻接矩阵：</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ot/hungarian/ex-matrix-1.png"></p>
<p>每一行减去行最小元素：</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ot/hungarian/ex-matrix-2.png"></p>
<p>每一列减去列最小元素：</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ot/hungarian/ex-matrix-3.png"></p>
<p>画最少的线覆盖包含 0 的行和列：</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ot/hungarian/ex-matrix-4.png"></p>
<p>发现共有两条线，分别是第一列和第二行，而 $2 &lt; 3$，所以，还需要继续进行约简。对没有覆盖的两行减去两行中的最小元素：</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ot/hungarian/ex-matrix-5.png"></p>
<p>对覆盖的列加上刚刚减去的最小元素，使得列中的 0 恢复：</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ot/hungarian/ex-matrix-6.png"></p>
<p>继续画线，用最少的线覆盖所有的 0：</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ot/hungarian/ex-matrix-7.png"></p>
<p>画线个数 3 等于邻接矩阵的行数。所得的匹配是矩阵中的 0，它在每行和每列中只能取1个：</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ot/hungarian/ex-matrix-8.png"></p>
<p>替换 0 为原始权重值：</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/ot/hungarian/ex-matrix-9.png"></p>
<p>匈牙利算法告诉我们最小的花费（407 = 150 + 135 + 122）是请 A 公司的清洁工，B 公司的厨师，C 公司的音乐家。通过蛮力解法可以验证结果的正确性。</p>
<h1 id="使用图的匈牙利算法"><a href="#使用图的匈牙利算法" class="headerlink" title="使用图的匈牙利算法"></a>使用图的匈牙利算法</h1><p>不使用邻接矩阵，直接使用二分图寻找最大权重匹配，需要对每个顶点定义标签值，称为可行标签（feasible labeling）.</p>
<p>A <em>labeling</em> for graph $G = (V, E)$ is a function $l: V \to \mathbb{R}$, such that:<br>$$<br>\forall (u, v) \in E: l(u) + l(v) \geq w(u, v).<br>$$<br>An <em>Equality Subgraph</em> is a subgraph $G_l = (V, E_l)$ $ \subseteq$ $G = (V, E)$, fixed on a labeling $l$, such that<br>$$<br>E_l = \lbrace(u,v) \in E: l(u) + l(v) = w(u,v)\rbrace.<br>$$</p>
<h2 id="The-Kuhn-Munkres-Theorem"><a href="#The-Kuhn-Munkres-Theorem" class="headerlink" title="The Kuhn-Munkres Theorem"></a>The Kuhn-Munkres Theorem</h2><p>Given labeling $l$, if $M$ is a perfect matching on $G_l$, then $M$ is maximal-weight matching of $G$.</p>
<ol>
<li><p>Let $M^{\prime}$ be any perfect matching in $G$. By definition of a labeling function and since $M^{\prime}$ is perfect,<br>$$<br>w(M^{\prime}) = \sum_{(u,v)\in M^{\prime}} w(u,v) \leq \sum_{(u,v)\in M^{\prime}} l(u) + l(v) = \sum_{v\in V} l(v).<br>$$</p>
</li>
<li><p>This means: $\sum_{v\in V} l(v)$ is an upper bound for any perfect matching $M^{\prime}$ of $G$.</p>
</li>
<li><p>Now look at the weight of matching $M$:<br>$$<br>w(M) = \sum_{(u,v)\in M} w(u,v) = \sum_{(u,v)\in M} l(u) + l(v) = \sum_{v\in V} l(v).<br>$$</p>
</li>
<li><p>we have that for all perfect matchings $M^{\prime}$ of $G$:<br>$$<br>w(M) \geq w(M^{\prime}).<br>$$</p>
</li>
</ol>
<p>根据 Kuhn-Munkres 定理，找到最大权重分配的问题被简化为找到正确的标记函数和相应等价子图上的任何完美匹配。</p>
<h2 id="The-Hungarian-Algorithm"><a href="#The-Hungarian-Algorithm" class="headerlink" title="The Hungarian Algorithm"></a>The Hungarian Algorithm</h2><p>算法思想：维护一个匹配的 $M$ 和等价图 $G_l$，从 $M = \emptyset$ 和一个有效的 $l$ 开始。继续直到 $M$ 成为 $G_l$ 上的完美匹配。每一步：要么增加 $M$ 要么改进标签 $l \to l^{\prime}$.</p>
<h3 id="Augment-the-matching-M"><a href="#Augment-the-matching-M" class="headerlink" title="Augment the matching $M$"></a>Augment the matching $M$</h3><p>Given labeling $l$, $G_l = (V, E_l)$, some matching $M$ on $G_l$ , unmatched $u \in V, u \notin M$.</p>
<ol>
<li>A path is augmenting for $M$ on $G_l$ if it alternates between $E_l − M$ and $M$, and the first and last vertices of the path are un-matched in $M$. Keep track of an ”almost” augmenting path starting at $u$.</li>
<li>If we can find an unmatched vertex $v$, then we create augmenting path $\alpha$ from $u$ to $v$. </li>
<li>Flip the matching by replacing the edges in $M$ with the edges in the augmenting path that are in $E_l − M$. </li>
<li>Since we start and end unmatched, this increases the size of the matching, $|M^{\prime}| &gt; |M|$.</li>
</ol>
<h3 id="Improve-the-labeling-l"><a href="#Improve-the-labeling-l" class="headerlink" title="Improve the labeling $l$"></a>Improve the labeling $l$</h3><ol>
<li><p>$S\subseteq X$ and $T \subseteq Y$ s.t. $S,T$ represent the current “almost” augmenting alternating path between the matching $M$ and outside other edges in $E_l \to M$.</p>
</li>
<li><p>Let $N_l(S)$ be the neighbors to each node in $S$ along $E_l$. </p>
<p>$$<br>N_l(S) = \lbrace v | \forall u \in S: (u, v) \in E_l \rbrace.<br>$$</p>
</li>
</ol>
<ol start="3">
<li><p>if $N_l(S)=T$ we cannot increase the alternating path and augment, so we must improve the labeling.</p>
</li>
<li><p>compute:<br>$$<br>\delta_l = \min_{u\in S, v \notin T} \lbrace l(u) + l(v) - w(u,v) \rbrace.<br>$$</p>
</li>
</ol>
<ol start="5">
<li><p>improve $l \to l^{\prime}$:<br>$$<br>l^{\prime}(r) =<br>\begin{cases}<br>l(r) - \delta_l &amp; \text{if} \ r \in S \\<br>l(r) + \delta_l &amp; \text{if} \ r \in T \\<br>l(r) &amp; \text{otherwise}.<br>\end{cases}<br>$$</p>
</li>
<li><p>claim: $l^{\prime}$ is a valid labeling and $E_l \subseteq E_{l^{\prime}}$.</p>
</li>
<li><p>proof follows by examining cases for all possibilities of membership of $u\in S$, $u \notin S$, $v \in T$, $v \notin T$.</p>
</li>
</ol>
<h3 id="the-hungarian-algorithm"><a href="#the-hungarian-algorithm" class="headerlink" title="the hungarian algorithm"></a>the hungarian algorithm</h3><ol>
<li><p>start with some matching $M$, and a valid labeling</p>
<p>$$<br>l := \forall x \in X, y \in Y, l(y) = 0, l(x) = \max_{y^{\prime} \in Y }(w(x, y^{\prime})).<br>$$</p>
</li>
</ol>
<ol start="2">
<li><p>do the following until $M$ is a perfect matching:</p>
<p>(a). Look for augmenting path;</p>
<p>(b). If a augmenting path does not exist, improve $l \to l^{\prime}$ and go to step (a).</p>
</li>
</ol>
<h1 id="Python-执行匈牙利算法"><a href="#Python-执行匈牙利算法" class="headerlink" title="Python 执行匈牙利算法"></a>Python 执行匈牙利算法</h1><h2 id="scipy-optimize-linear-sum-assignment"><a href="#scipy-optimize-linear-sum-assignment" class="headerlink" title="scipy.optimize.linear_sum_assignment"></a>scipy.optimize.linear_sum_assignment</h2><p>scipy.optimize.linear_sum_assignment(cost_matrix, maximize=False)</p>
<p>cost_matrix 表示代价矩阵， maximize 表示求最小（False）还是最大（True）权重匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linear_sum_assignment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处的 0 不是表示边缺失。表示边缺失用 np.inf 来表示</span></span><br><span class="line">cost = np.array([[<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>]])</span><br><span class="line"><span class="comment"># row_ind 是排序好的，col_ind 相对应</span></span><br><span class="line">row_ind, col_ind = linear_sum_assignment(cost)</span><br><span class="line"><span class="comment"># 表示第1，0，2列</span></span><br><span class="line">col_ind</span><br><span class="line">array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># 最终得到完美匹配的权重和</span></span><br><span class="line">cost[row_ind, col_ind].sum()</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="scipy-sparse-csgraph-min-weight-full-bipartite-matching"><a href="#scipy-sparse-csgraph-min-weight-full-bipartite-matching" class="headerlink" title="scipy.sparse.csgraph.min_weight_full_bipartite_matching"></a>scipy.sparse.csgraph.min_weight_full_bipartite_matching</h2><p>scipy.sparse.csgraph.min_weight_full_bipartite_matching(biadjacency_matrix, maximize=False)</p>
<p>对于稀疏矩阵进行计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.sparse <span class="keyword">import</span> csr_matrix</span><br><span class="line"><span class="keyword">from</span> scipy.sparse.csgraph <span class="keyword">import</span> min_weight_full_bipartite_matching</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处的 0 表示边缺失，赋值 0 将其转化为完全图</span></span><br><span class="line"><span class="comment"># 所以，此处就是找最大匹配</span></span><br><span class="line">biadjacency_matrix = csr_matrix([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">row_ind, col_ind = min_weight_full_bipartite_matching(biadjacency_matrix)</span><br><span class="line">print(col_ind)</span><br><span class="line">[<span class="number">2</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line">biadjacency_matrix[row_ind, col_ind].sum()</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="scipy-sparse-csgraph-maximum-bipartite-matching"><a href="#scipy-sparse-csgraph-maximum-bipartite-matching" class="headerlink" title="scipy.sparse.csgraph.maximum_bipartite_matching"></a>scipy.sparse.csgraph.maximum_bipartite_matching</h2><p>scipy.sparse.csgraph.maximum_bipartite_matching(graph, perm_type=’row’)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.sparse <span class="keyword">import</span> csr_matrix</span><br><span class="line"><span class="keyword">from</span> scipy.sparse.csgraph <span class="keyword">import</span> maximum_bipartite_matching</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处的 0 表示边缺失，赋值 0 将其转化为完全图</span></span><br><span class="line"><span class="comment"># 所以，此处就是找最大匹配</span></span><br><span class="line">graph = csr_matrix([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">maximum_bipartite_matching(graph, perm_type=<span class="string">&#x27;column&#x27;</span>)</span><br><span class="line"><span class="comment"># 结果表示第0行的第2列，第1行的第0列</span></span><br><span class="line">array([<span class="number">2</span>, <span class="number">0</span>], dtype=int32)</span><br><span class="line"></span><br><span class="line">maximum_bipartite_matching(graph, perm_type=<span class="string">&#x27;row&#x27;</span>)</span><br><span class="line"><span class="comment"># 结果表示第0列的第1行，第1列没有，第2列的第0行</span></span><br><span class="line">array([ <span class="number">1</span>, <span class="number">-1</span>,  <span class="number">0</span>], dtype=int32)</span><br></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://www.cc.gatech.edu/~rpeng/18434_S15/hungarianAlgorithm.pdf">The Hungarian Algorithm for Weighted Bipartite Graphs</a></li>
<li><a href="https://brilliant.org/wiki/hungarian-matching/">Hungarian Maximum Matching Algorithm</a></li>
<li><a href="http://www.columbia.edu/~cs2035/courses/ieor6614.S16/GolinAssignmentNotes.pdf">Bipartite Matching &amp; the Hungarian Method</a></li>
<li><a href="https://senyang-ml.github.io/2020/06/01/Bipartite-Matching-and-Hungarian-Algorithm/">Bipartite Matching and Hungarian Algorithm</a></li>
<li><a href="https://senyang-ml.github.io/2020/06/04/detr/">Detr</a></li>
<li><a href="https://www.pythonf.cn/read/34325">超级细节！！！匈牙利算法流程和python程序实现！！！容易理解,详细,以及,Python,通俗易懂</a></li>
<li><a href="https://blog.csdn.net/your_answer/article/details/79160045">利用python解决指派问题（匈牙利算法）</a></li>
<li><a href="https://blog.csdn.net/u013384984/article/details/90718287">匈牙利算法-看这篇绝对就够了！</a></li>
<li><a href="https://www.cxyxiaowu.com/874.html">五分钟小知识：什么是匈牙利算法</a></li>
</ol>
]]></content>
      <categories>
        <category>research</category>
        <category>object tracking</category>
      </categories>
      <tags>
        <tag>hungarian</tag>
        <tag>bipartite</tag>
        <tag>graph</tag>
        <tag>matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>反常积分与柯西主值</title>
    <url>/2021/11/22/improper-integral-cauchy-principal-value/</url>
    <content><![CDATA[<p>在讨论定积分时有两个默认的限制条件：一是积分区间有穷，二是被积函数有界。在实际问题中往往需要突破这些限制，如需要在无穷区间上进行积分，或求无解函数的积分(函数在积分区间的某点上无界)。此时，研究的积分称为反常积分(improper integral，或称为非正常积分，广义积分。原有的定积分为Riemann积分，或常义积分，记作$f\in R[a,b]$，表示函数$f$ 在闭区间$[a,b]$上黎曼可积)。在研究反常积分时常常研究其收敛性或发散性，这一点与数项级数一致。更进一步，含参量反常积分和函数项级数研究一致收敛性和发散性。</p>
<a id="more"></a>

<h1 id="两类反常积分"><a href="#两类反常积分" class="headerlink" title="两类反常积分"></a>两类反常积分</h1><h2 id="无穷积分"><a href="#无穷积分" class="headerlink" title="无穷积分"></a>无穷积分</h2><p>无穷积分是第一类反常积分，指积分区间的上限或下限为无穷的积分。</p>
<p>设函数$f$定义在无穷区间$[a,+\infty]$上，且在任何有限区间$[a,u]$上可积。如果存在极限<br>$$<br>\lim_{u\to +\infty}\int^u_a f(x) \mathrm{d}x = J,<br>$$<br>则称此极限$J$为函数$f$在$[a,+\infty]$上的<strong>无穷限反常积分</strong>(简称<strong>无穷积分</strong>)，记作<br>$$<br>J = \int^{+\infty}_a f(x) \mathrm{d}x,<br>$$<br>并称$\int^{+\infty}_a f(x) \mathrm{d}x$收敛，如果极限不存在，则称$\int^{+\infty}_a f(x) \mathrm{d}x$发散。</p>
<p>类似地，可定义$f$在$(-\infty,b)$上的无穷积分：<br>$$<br>\int^b_{-\infty}f(x)\mathrm{d}x=\lim_{v\to -\infty}\int^b_v f(x)\mathrm{d}x.<br>$$<br>对于$f$在$(-\infty,+\infty)$上的无穷积分，定义如下：<br>$$<br>\int_{-\infty}^{+\infty} f(x) \mathrm{d}x = \int^a_{-\infty} f(x) \mathrm{d}x + \int^{+\infty}_a f(x) \mathrm{d}x.<br>$$</p>
<p>其中，$a$为任一实数，当且仅当右边两个无穷积分都收敛时它才收敛。收敛性与收敛时的值都和实数$a$的选取无关。$f$在任何有限区间$[v,u]\subset(-\infty,+\infty)$上必须可积。前面定积分的换元法、分部积分法仍然适用。</p>
<p>$\int^{+\infty}_a f(x)\mathrm{d}x$收敛的几何意义：若$f$在$[a,+\infty]$上为非负连续函数，则曲线$y=f(x)$，直线$x=a$以及$x$轴之间所围区域面积为$J$.</p>
<p>无穷积分$\int_1^{+\infty} \frac{1}{x^p} \mathrm{d}x$在$p&gt;1$时收敛到$\frac{1}{p-1}$；在$p\leq 1$时发散。</p>
<h2 id="瑕积分"><a href="#瑕积分" class="headerlink" title="瑕积分"></a>瑕积分</h2><p>瑕积分为第二类反常积分，指被积函数在积分区间中含有不连续点的积分。</p>
<p>设函数$f$定义在区间$(a,b]$上，在点$a$的任意右邻域内无界，但在任何内闭区间$[u,b]\subset(a,b]$上有界且可积。如果存在极限<br>$$<br>\lim_{u\to a^+} \int_u^b f(x) \mathrm{d}x = J,<br>$$<br>则称此极限为无界函数$f$在$(a,b]$上的反常积分，记作<br>$$<br>J = \int_a^b f(x) \mathrm{d}x,<br>$$<br>并称反常积分$\int_a^b f(x) \mathrm{d}x$收敛。如果极限不存在，说反常积分$\int_a^b f(x) \mathrm{d}x$发散。称点$a$为$f$的瑕点，无界函数反常积分$\int_a^b f(x)\mathrm{d}x$又称为<strong>瑕积分</strong>。</p>
<p>类似地，可定义瑕点为$b$时的瑕积分：<br>$$<br>\int_a^b f(x) \mathrm{d}x = \lim_{v \to b^-} \int_a^v f(x) \mathrm{d}x.<br>$$<br>其中$f$在$[a,b)$有定义，在点$b$的任一左邻域内无界，但在任何$[a,v] \subset [a,b)$上可积。</p>
<p>若$f$的瑕点$c\in(a,b)$，则定义瑕积分<br>$$<br>\int_a^b f(x) \mathrm{d}x = \int_a^c f(x) \mathrm{d}x + \int_c^b f(x) \mathrm{d}x \\<br>= \lim_{u\to c^-} \int_a^u f(x)\mathrm{d}x + \lim_{v\to c^+}\int_v^b f(x)\mathrm{d}x.<br>$$<br>其中$f$在$[a,c)\cup(c,b]$上有定义，在点$c$的任一邻域内无界，但任何$[a,u]\subset [a,c)$和$[v,b]\subset(c,b]$上都可积。当且仅当上式右边两个瑕积分都收敛时，左边的瑕积分才是收敛的。</p>
<p>又若$a,b$两点都是$f$的瑕点，而$f$在任何$[u,v]\subset(a,b)$上可积，这是定义瑕积分<br>$$<br>\int_a^b f(x)\mathrm{d}x = \int_a^c f(x)\mathrm{d}x + \int_c^b f(x)\mathrm{d}x \\<br>= \lim_{u\to a^+} \int_u^c f(x)\mathrm{d}x + \lim_{v \to b^-} f(x) \mathrm{d}x,<br>$$<br>其中$c$为$(a,b)$内任一实数。同样地，当且仅当上式右边两个瑕积分都收敛时，左边的瑕积分才是收敛的。</p>
<p>瑕积分$\int_0^1 \frac{1}{x^p} \mathrm{d}x \ (p &gt; 0)$，当$0&lt;p&lt;1$时收敛到$\frac{1}{1-p}$，当$p\geq 1$时发散.</p>
<p>反常积分$\int_0^{+\infty} \frac{1}{x^p}\mathrm{d}x \ (p&gt;0)$收敛还是发散？我们定义<br>$$<br>\int_0^{+\infty}\frac{1}{x^p}\mathrm{d}x = \int_0^1 \frac{1}{x^p}\mathrm{d}x + \int_1^{+\infty}\frac{1}{x^p}\mathrm{d}x,<br>$$<br>它当且仅当右边的瑕积分和无穷积分都收敛时才收敛。有上面可知，这两个反常积分不能同时收敛，故对于任何实数$p&gt;0$都是发散的。</p>
<h1 id="柯西主值"><a href="#柯西主值" class="headerlink" title="柯西主值"></a>柯西主值</h1><p>设函数$f$ 在$(-\infty, +\infty)$上内闭可积（即在任何闭子区间上都可积），定义<br>$$<br>\textbf{PV} \int_{-\infty}^{+\infty} f(x) \mathrm{d}x = \lim_{A \to +\infty} \int_{-A}^A f(x) \mathrm{d}x<br>$$<br>为反常积分（广义积分）$\int_{-\infty}^{+\infty} f(x) \mathrm{d}x$的柯西主值（Cauchy Principal Value），如果右边极限存在的话。</p>
<p>对于无界积分。设$f$在区间$[a,b]$中只有一个瑕点$c$，$a&lt;c&lt;b$，则定义<br>$$<br>\textbf{PV} \int_a^b f(x)\mathrm{d}x = \lim_{\delta \to 0^+}(\int_a^{c-\delta} + \int_{c+\delta}^b) f(x)\mathrm{d}x<br>$$<br>为广义积分$\int_a^b f(x)\mathrm{d}x$的柯西主值，如果右边极限存在的话。</p>
<p>容易看出，若广义积分收敛，则其主值与广义积分的值相同；但是当广义积分发散时，它的主值仍可能存在。</p>
<p>如$\int_{-\infty}^{+\infty}x \mathrm{d}x$发散，但是$\textbf{PV}\int_{-\infty}^{+\infty}x\mathrm{d}x=\lim_{R\to +\infty} \int_{-R}^R x \mathrm{d}x = 0$.</p>
<p>如$\int_{-1}^1 \frac{1}{x}\mathrm{d}x$发散，但是$\textbf{PV}\int_{-1}^1 \frac{1}{x}\mathrm{d}x=\lim_{\varepsilon \to 0^+}\int_{-1+\varepsilon}^{1-\varepsilon}\frac{1}{x}\mathrm{d}x=0$.</p>
<p>若已知广义积分收敛时，可利用其主值来积分积分值。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><ol>
<li>举例说明：瑕积分$\int_a^b f(x)\mathrm{d}x$收敛时，$\int_a^b f^2(x)\mathrm{d}x$不一定收敛。如$\int_0^1 \frac{1}{\sqrt{x}} \mathrm{d}x$</li>
<li>举例说明：$\int_a^{+\infty}f(x) \mathrm{d}x$收敛且$f$在$[a,+\infty)$上连续时，不一定有$\lim_{x\to +\infty}f(x)=0.$ 如$\int_1^{+\infty}\sin x^2 \mathrm{d}x$.</li>
<li>证明：若$\int_a^{+\infty}f(x)\mathrm{d}x$收敛，且存在极限$\lim_{n\to +\infty}f(x)=A$，则$A=0$.</li>
<li>若$\int_a^{+\infty}f(x)\mathrm{d}x$收敛，则$\lim_{x\to +\infty}f(x)$可以不存在或者存在且为0.</li>
<li>证明：若$f$在$[a,+\infty)$上可导，且$\int_a^{+\infty}f(x)\mathrm{d}x$与$\int_a^{+\infty}f^{\prime}(x)\mathrm{d}x$都收敛，则$\lim_{x\to +\infty} f(x) = 0$.</li>
</ol>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>integral</tag>
        <tag>cauchy</tag>
      </tags>
  </entry>
  <entry>
    <title>安装 Ubuntu 时出现 no boot file found</title>
    <url>/2020/01/02/install-ubuntu-no-boot-file/</url>
    <content><![CDATA[<p>今天一个师弟安装 Ubuntu 时重启发现无法正常进入刚安装好的 Ubuntu 系统，从系统盘启动时出现 no boot file found。他也很疑惑，明明已经正确把 ubuntu 系统安装到固态硬盘上了，为什么不能正常进入呢？他就来问我怎么解决。我第一想法就是 boot 启动设置引导项的问题，把之前的 UEFI 设置成 legacy ，仍然遇到同样的问题。我就在想，是不是系统盘的引导分区不正确。经过一系列的操作终于完成了Ubuntu系统的安装和正常启动。我的方法如下：</p>
<a id="more"></a>

<h2 id="使用Windows启动盘"><a href="#使用Windows启动盘" class="headerlink" title="使用Windows启动盘"></a>使用Windows启动盘</h2><p>首先将Windows10 启动盘插入光驱，进入安装Windows10程序，然后在安装系统之前，按住 SHIFT + F10 进入cmd</p>
<h2 id="转换硬盘的引导分区"><a href="#转换硬盘的引导分区" class="headerlink" title="转换硬盘的引导分区"></a>转换硬盘的引导分区</h2><p>在cmd中输入下列命令，把GPT（GUID Partition Table）引导分区转化为MBR（Master Boot Record）引导分区。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diskpart</span><br><span class="line">list disk</span><br><span class="line">select disk 0</span><br><span class="line">clean</span><br><span class="line">convert mbr</span><br></pre></td></tr></table></figure>

<h2 id="设置boot启动格式"><a href="#设置boot启动格式" class="headerlink" title="设置boot启动格式"></a>设置boot启动格式</h2><p>重启系统，拿出光盘，进入boot系统，设置光盘启动为第一启动项，设置成legacy格式</p>
<h2 id="重装Ubuntu系统"><a href="#重装Ubuntu系统" class="headerlink" title="重装Ubuntu系统"></a>重装Ubuntu系统</h2><p>插入Ubuntu系统盘到光驱，进行正常安装Ubuntu流程</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>定积分的可积条件</title>
    <url>/2020/08/29/integrable-condition-of-definite-integral/</url>
    <content><![CDATA[<p>定积分的可积条件就是研究函数满足什么条件下可进行积分（充分性），函数可积分会有什么性质（必要性），以及可积函数的充分必要条件等。</p>
<p><strong>关于函数$f(x)$在闭区间$[a,b]$上的积分总结一句话就是：连续必可积，可积必有界。</strong></p>
<a id="more"></a>

<h1 id="可积的必要条件"><a href="#可积的必要条件" class="headerlink" title="可积的必要条件"></a>可积的必要条件</h1><p>在介绍可积的必要条件之前，首先引入有界（无界）函数$f(x)$的定义。</p>
<h2 id="有界函数和无界函数"><a href="#有界函数和无界函数" class="headerlink" title="有界函数和无界函数"></a>有界函数和无界函数</h2><p>定义    设函数$f(x)$的定义域为$D$，如果存在一个常数$M(L)$，使得$\forall x \in D$，都有<br>$$<br>f(x)\leq M (f(x)\geq L).<br>$$<br>则称$f(x)$在$D$内有上（下）界的函数，数$M(L)$称为$f(x)$在$D$内的一个上（下）界。</p>
<p>定义    设函数$f(x), x\in D$，如果存在一个正数$K&gt;0$，使得$\forall x \in D$，都有<br>$$<br>\left \vert f(x) \right \vert \leq K,<br>$$<br>那么称$f(x)$在$D$内是有界函数；否则，称$f(x)$是无界函数。</p>
<p><em>如果 $f(x)$ 在 $D$ 内既有上界又有下界，则称$f(x)$在$D$内是有界函数</em></p>
<p><em>函数$f(x)$在$D$内有界当且仅当数集$f(D)$是有界集，即$\forall f(x) \in f(D), L \leq f(x) \leq M$, 其中$M,L$是常数，分别称为$f(D)$的一个上界和一个下界.</em></p>
<p>定义    函数$f(x), x \in D$是无界函数当且仅当$\forall M &gt; 0, \exists x \in D$，使得$\left \vert f(x) \right \vert &gt; M$. </p>
<p>有了有界和无界函数的定义，我们就可以来研究函数可积的必要条件了。</p>
<h2 id="可积的必要条件-1"><a href="#可积的必要条件-1" class="headerlink" title="可积的必要条件"></a>可积的必要条件</h2><p>定理 9.2    若函数$f(x)$在$[a,b]$上可积，则$f(x)$在$[a,b]$上必定有界。</p>
<p>证明    用反证法。若$f(x)$在$[a,b]$上无界，则对于$[a,b]$的任一分割$T$，必存在属于$T$的某个小区间$\Delta_k$，$f(x)$在$\Delta_k$上无界。在$i \neq k$的各个小区间$\Delta_i$上任意取定$\xi_i$，并记<br>$$<br>G = \left \vert \sum_{i \neq k} f(\xi_i) \Delta x_i \right \vert.<br>$$<br>现对任意大的正数$M$，由于$f(x)$在$\Delta_k$上无界，故存在$\xi_k \in \Delta_k$，使得<br>$$<br>\left \vert f(\xi_k) \right \vert &gt; \frac{M + G}{\Delta x_k}.<br>$$<br>于是有<br>$$<br>\left \vert \sum^n_{i=1} f(\xi_i) \Delta x_i \right \vert \geq \left \vert f(\xi_k) \Delta x_k \right \vert - \left \vert \sum_{i \neq k} f(\xi_i) \Delta x_i \right \vert &gt; \frac{M + G}{\Delta x_k} \cdot \Delta x_k - G = M.<br>$$<br>由此可见，对于无论多小的$|T|$，按上述方法选取点集${\xi_i}$时，总能使积分和的绝对值大于任何预先给出的正数，这与$f(x)$在$[a,b]$上可积相矛盾。</p>
<p><strong>该定理指出，任何可积函数一定是有界函数，但是，反过来不一定成立。</strong></p>
<p>例如，如下的狄利克雷函数<br>$$<br>D(x) =<br>\begin{cases}<br>  1, x \in Q \\<br>  0, x \in Q^C.<br>\end{cases}<br>$$<br>显然该函数是有界的，因为 $\left \vert D(x) \right \vert \leq 1, x \in [0, 1]$ . 但是，根据定积分的定义，无论分割多么细密，都可以只选取有理点进行积分或者只选取无理点进行积分，当选取有理点积分时，积分值等于1，当选取无理点积分时，积分值等于0.因此不可积。</p>
<p><strong>因此，有界是可积的必要条件。所以，当以后假设函数是可积函数时，默认指明函数是有界函数。</strong></p>
<h1 id="可积的充要条件"><a href="#可积的充要条件" class="headerlink" title="可积的充要条件"></a>可积的充要条件</h1><p>要判断一个函数是否可积不能依靠必要条件（有界），当然，仅仅使用充分条件（连续）又有些太强，毕竟不连续函数比连续函数多得多，就好比无理数比有理数多一样。但是，根据定积分的定义来判断，又相对比较麻烦，所以，需要找到一个新的方法来判断一个函数到底是可积还是不可积。现假设函数$f(x)$在$[a,b]$上可积（必有界），来找到其充分必要条件。</p>
<p>设$T={\Delta_i | i = 1, 2, \cdots, n}$ 为对$[a, b]$ 的任一分割。由于$f(x)$在$[a,b]$上有界，它在每个$\Delta_i$上存在上、下确界：<br>$$<br>M_i = \sup_{x \in \Delta_i} f(x), m_i = \inf_{x \in \Delta_i} f(x), i = 1, 2, \cdots, n.<br>$$<br>作和<br>$$<br>S(T) = \sum^n_{i=1} M_i \Delta x_i, s(T) = \sum^n_{i=1} m_i \Delta x_i,<br>$$<br>分别称为$f$ 关于分割$T$ 的上和与下和（或称为达布上和与达布下和，统称达布和）。</p>
<p>任给$\xi_i \in \Delta_i, i = 1, 2, \cdots, n$，显然有<br>$$<br>s(T) \leq \sum^n_{i=1}f(\xi_i) \Delta x_i \leq S(T).<br>$$<br>与积分和相比较，达布和只与分割$T$有关，而与点集${\xi_i}$ 无关，根据上面不等式，就能通过讨论上和与下和当 $| T | \to 0$时的极限来揭示$f$在$[a,b]$上是否可积。</p>
<p>定理9.3    （可积准则）    函数$f$在$[a,b]$上可积的充要条件是：任给$\varepsilon &gt; 0$，总存在相应的一个分割$T$，使得<br>$$<br>S(T) - s(T) &lt; \varepsilon.<br>$$<br>设 $\omega_i = M_i - m_i$，称为$f$在$\Delta_i$ 上的振幅，有必要时也记为 $\omega^f_i$，由于<br>$$<br>S(T) - s(T) = \sum^n_{i=1} \omega_i \Delta x_i=\sum_T \omega_i \Delta x_i.<br>$$<br>定理可重述为：</p>
<p>定理9.4    函数$f$在$[a,b]$上可积的充要条件是任给$\varepsilon &gt; 0$，总存在相应的某一分割$T$，使得<br>$$<br>\sum_T \omega_i \Delta x_i &lt; \varepsilon.<br>$$<br>几何意义：若$f$在$[a,b]$上可积，则达布上和与达布下和在图像上所围成的一系列小矩形面积之和可以达到任意小，只要分割充分地细；反之亦然。</p>
<h1 id="可积函数类（可积的充分条件）"><a href="#可积函数类（可积的充分条件）" class="headerlink" title="可积函数类（可积的充分条件）"></a>可积函数类（可积的充分条件）</h1><p>定理9.4    若$f$为$[a,b]$上的连续函数，则$f$在$[a,b]$上可积。</p>
<p>定理9.5    若$f$是区间$[a,b]$上只有有限个间断点的有界函数，则$f$在$[a,b]$上可积。</p>
<p>定理9.6    若$f$是区间$[a,b]$上的单调函数，则$f$在$[a,b]$上可积。</p>
<p>例题    黎曼函数<br>$$<br>f(x) =<br>\begin{cases}<br>\frac{1}{q}, x=\frac{p}{q}, p, q 互素, q &gt; p, \\<br>0, x = 0, 1 以及 (0, 1) 内的无理数<br>\end{cases}<br>$$<br>在区间$[0,1]$上可积，且<br>$$<br>\int^1_0 f(x) \mathrm{d}x = 0.<br>$$<br>例题    若$T^{\prime}$是$T$增加若干个分点后所得的分割，则<br>$$<br>\sum_{T^\prime} \omega^{\prime}_i \Delta x^{\prime}_i \leq \sum_T \omega_i \Delta x_i.<br>$$<br>例题    若$f$在$[a,b]$上可积，$[\alpha, \beta] \subset [a,b]$，则$f$在$[\alpha, \beta]$上也可积。</p>
<p>例题    设$f,g$均为定义在$[a,b]$上的有界函数，仅在有限个点处$f(x) \neq g(x)$，则 $f,g$ 均在$[a,b]$上可积，且$\int^b_a f(x) \mathrm{d}x = \int^b_a g(x) \mathrm{d}x.$</p>
<p>例题    设$f$在$[a,b]$上有界，${a_n} \subset [a,b], \lim_{n \to \infty} a_n = c$，若$f$ 在$[a,b]$上只有$a_n(n=1,2,\cdots)$为其间断点，则$f$在$[a,b]$上可积。</p>
<p>例题    设函数$f$在$[a,b]$上有定义，且对于任给的$\varepsilon &gt; 0$，存在$[a,b]$上的可积函数$g$，使得<br>$$<br>|f(x) - g(x)| &lt; \varepsilon, x \in [a, b].<br>$$<br>则$f$在$[a,b]$上可积。</p>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>integral</tag>
        <tag>definite integral</tag>
      </tags>
  </entry>
  <entry>
    <title>使用intellij idea 编译项目到jar包</title>
    <url>/2020/01/02/intellij-idea-build-jar/</url>
    <content><![CDATA[<p>当我使用 Java 开发 Flink 时，遇到了一个问题，那就是如何使用 Intellij Idea 编译项目成jar包。经过调研，发现有两种方法来编译项目：</p>
<a id="more"></a>

<h2 id="使用Intellij-Idea编译"><a href="#使用Intellij-Idea编译" class="headerlink" title="使用Intellij Idea编译"></a>使用Intellij Idea编译</h2><ol>
<li><p>点击 File</p>
</li>
<li><p>点击 Project Structure</p>
</li>
<li><p>点击 Artifacts</p>
</li>
<li><p>点击 “+” 号</p>
</li>
<li><p>点击 JAR</p>
</li>
<li><p>点击 From modules with dependencies</p>
</li>
<li><p>选择 Main Class </p>
</li>
<li><p>点击 Apply &amp;&amp; ok</p>
</li>
<li><p>点击 Build</p>
</li>
<li><p>点击 Build Artifacts</p>
</li>
<li><p>点击 Build</p>
<p>该方法可参考<a href="https://blog.csdn.net/xuemengrui12/article/details/74984731">使用Intellij Idea打包java为可执行jar包</a></p>
</li>
</ol>
<h2 id="使用Maven编译"><a href="#使用Maven编译" class="headerlink" title="使用Maven编译"></a>使用Maven编译</h2><p>在项目工作目录下，运行如下命令</p>
<p>mvn clean package</p>
<p>以上两种方法，都可以编译 Java 项目成jar包，然后就可以提交到 Flink 集群或web下运行。</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>program</tag>
      </tags>
  </entry>
  <entry>
    <title>ip、tcp、udp 首部校验和</title>
    <url>/2022/01/15/ip-tcp-udp-header-checksum/</url>
    <content><![CDATA[<p>ip 首部校验和、tcp/udp 首部校验和能够判断网络传输中是否出现丢包、错包等。下面分别介绍它们的计算方法和 python 实现。</p>
<a id="more"></a>

<h1 id="ip-首部校验和"><a href="#ip-首部校验和" class="headerlink" title="ip 首部校验和"></a>ip 首部校验和</h1><p>ip 首部校验和是针对 ip 数据包的包头20字节部分进行校验。假设我们有如下20字节的 ip 包头数据（16进制格式）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">45</span> <span class="number">00</span> <span class="number">00</span> <span class="number">30</span> <span class="number">80</span> <span class="string">4c</span> <span class="number">40</span> <span class="number">00</span> <span class="number">80</span> <span class="number">06</span> <span class="string">b5</span> <span class="string">2e</span> <span class="string">d3</span> <span class="number">43</span> <span class="number">11</span> <span class="string">7b</span> <span class="string">cb</span> <span class="number">51</span> <span class="number">15</span> <span class="string">3d</span></span><br></pre></td></tr></table></figure>

<ul>
<li>45：4表示 ip 版本号，这里是 ipv4，5表示首部数据长度，为5个32比特，即20字节；</li>
<li>00 30: 表示 ip 包总长度为 0x0030=48字节，减去头部20字节，数据部分为28字节；</li>
<li>80 4c：表示标识符；</li>
<li>40 00：3比特标志和13比特片偏移量；</li>
<li>80 06：80表示ttl值0x80=128，06表示 tcp 协议（0x11=17表示udp协议）；</li>
<li>b5 2e：表示 ip 首部校验和；</li>
<li>d3 43 11 7b：表示源地址0xd3, 0x43, 0x11, 0x7b = (211, 67, 17, 123)；</li>
<li>cb 51 15 3d：表示目的地址0xcb, 0x51, 0x15, 0x3d = (203, 81, 21, 61)；</li>
</ul>
<h2 id="ip-首部校验和算法"><a href="#ip-首部校验和算法" class="headerlink" title="ip 首部校验和算法"></a>ip 首部校验和算法</h2><p>计算 ip 首部校验和，</p>
<ol>
<li><p>将 ip 包头20字节的 ip 首部校验和2字节替换为 00 00，替换后如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">45</span> <span class="number">00</span> <span class="number">00</span> <span class="number">30</span> <span class="number">80</span> <span class="string">4c</span> <span class="number">40</span> <span class="number">00</span> <span class="number">80</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="string">d3</span> <span class="number">43</span> <span class="number">11</span> <span class="string">7b</span> <span class="string">cb</span> <span class="number">51</span> <span class="number">15</span> <span class="string">3d</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对20字节进行两字节以大端方式累加求和：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0x4500</span> + <span class="number">0x0030</span> + <span class="number">0x804c</span> + <span class="number">0x4000</span> + <span class="number">0x8006</span> + <span class="number">0x0000</span> + <span class="number">0xd343</span> + <span class="number">0x117b</span> + <span class="number">0xcb51</span> + <span class="number">0x153d</span> = <span class="number">0x34ace</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果和大于2字节时，则和值中高2字节加上低2字节的值作为最终的和值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0003</span> + <span class="number">0x4ace</span> = <span class="number">0x4ad1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对最终的和值求反，即关于2字节的补：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0xffff</span> - <span class="number">0x4ad1</span> = <span class="number">0xb52e</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>此时，得到的值 0xb52e 就是上面的 ip 首部校验和 b5 2e</p>
<h2 id="ip-首部校验和的-python-实现"><a href="#ip-首部校验和的-python-实现" class="headerlink" title="ip 首部校验和的 python 实现"></a>ip 首部校验和的 python 实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@jit(nopython=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ip_check_sum_int</span>(<span class="params">block</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对应算法里的步骤2、3</span></span><br><span class="line"><span class="string">    return: 整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    check_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(block), <span class="number">2</span>):</span><br><span class="line">        check_sum += (block[i] &lt;&lt; <span class="number">8</span>) + block[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> (check_sum &gt;&gt; <span class="number">16</span>) != <span class="number">0</span>:</span><br><span class="line">        check_sum = (check_sum &gt;&gt; <span class="number">16</span>) + (check_sum &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">    <span class="keyword">return</span> check_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ip_check_sum</span>(<span class="params">block</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对应算法里的步骤1、4</span></span><br><span class="line"><span class="string">    return: 2字节二进制整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> len(block) != <span class="number">20</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ip 首部必须为20字节&quot;</span></span><br><span class="line">    block = block[:<span class="number">10</span>] + bytearray([<span class="number">0x00</span>, <span class="number">0x00</span>]) + block[<span class="number">12</span>:]</span><br><span class="line">    check_sum = <span class="number">0xFFFF</span> - ip_check_sum_int(block)</span><br><span class="line">    <span class="keyword">return</span> bytearray([check_sum &gt;&gt; <span class="number">8</span>, check_sum &amp; <span class="number">0xFF</span>])</span><br></pre></td></tr></table></figure>

<h1 id="tcp-udp-首部校验和"><a href="#tcp-udp-首部校验和" class="headerlink" title="tcp/udp 首部校验和"></a>tcp/udp 首部校验和</h1><p>tcp 和 udp 的首部校验和算法是一致的，只是数据中的协议标识不同，tcp为0x06，udp为0x11。同时，除了需要对数据添加伪首部和校验和位置不同外，它们的计算算法和 ip 首部校验和是一致的。下面以 udp 为例。</p>
<p>数据格式如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">udp</span> <span class="string">伪首部</span> <span class="string">+</span> <span class="string">udp</span> <span class="string">首部</span> <span class="string">+</span> <span class="string">载荷数据</span></span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>udp 伪首部（12字节）：4字节源地址 + 4字节目的地址 + 0x00 + 0x11（udp 协议。<font color=red> tcp 协议取值0x06</font>）+ 2字节 udp 长度; </li>
<li>udp 首部（8字节）：2字节源端口 + 2字节目的端口 + 2字节 udp 长度 + 2字节校验和；</li>
</ul>
<p>注意：</p>
<ul>
<li>udp 数据报的总长度包括 udp 首部 + 载荷数据；</li>
<li>udp 伪首部加入校验的目的是为了再次核对数据报是否到达正确的目的地，并防止 ip 欺骗攻击 (spoofing);</li>
</ul>
<p>数据例子：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">45</span> <span class="number">00</span> <span class="number">00</span> <span class="number">30</span> <span class="number">80</span> <span class="string">4c</span> <span class="number">40</span> <span class="number">00</span> <span class="number">80</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="string">d3</span> <span class="number">43</span> <span class="number">11</span> <span class="string">7b</span> <span class="string">cb</span> <span class="number">51</span> <span class="number">15</span> <span class="string">3d</span> <span class="string">f8</span> <span class="string">3d</span> <span class="number">30</span> <span class="number">39</span> <span class="number">00</span> <span class="number">12</span> <span class="number">23</span> <span class="number">19</span> <span class="number">55</span> <span class="string">aa</span> <span class="number">68</span> <span class="number">65</span> <span class="string">6c</span> <span class="string">6c</span> <span class="string">6f</span> <span class="number">20</span> <span class="number">55</span> <span class="number">50</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>前面20字节为 ip 包头数据；</li>
<li>d3 43 11 7b：为 ip 源地址；</li>
<li>cb 51 15 3d：为 ip 目的地址；</li>
<li>f8 3d：为源端口；</li>
<li>30 30: 为目的端口；</li>
<li>00 12：为 udp 包长度，0x0012 = 18，表示 udp 首部 + 载荷数据，从源端口到数据包末尾；</li>
<li>b1 2d：为 udp 校验和;</li>
<li>55 aa 开始到末尾都是载荷数据。</li>
</ul>
<h2 id="udp-首部校验和算法"><a href="#udp-首部校验和算法" class="headerlink" title="udp 首部校验和算法"></a>udp 首部校验和算法</h2><p>udp 首部校验和的算法步骤如下（步骤<font color=cyan>3、4、5</font>&gt;同<font color=red>ip 首部校验和算法</font>）：</p>
<ol>
<li><p>根据 ip 数据包构造 udp 伪首部:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">d3</span> <span class="number">43</span> <span class="number">11</span> <span class="string">7b</span> <span class="string">cb</span> <span class="number">51</span> <span class="number">15</span> <span class="string">3d</span> <span class="number">00</span> <span class="number">11</span> <span class="number">00</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 “udp 伪首部 + udp 首部 + 载荷数据” 构造新数据:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">d3</span> <span class="number">43</span> <span class="number">11</span> <span class="string">7b</span> <span class="string">cb</span> <span class="number">51</span> <span class="number">15</span> <span class="string">3d</span> <span class="number">00</span> <span class="number">11</span> <span class="number">00</span> <span class="number">12</span> <span class="string">f8</span> <span class="string">3d</span> <span class="number">30</span> <span class="number">39</span> <span class="number">00</span> <span class="number">12</span> <span class="number">23</span> <span class="number">19</span> <span class="number">55</span> <span class="string">aa</span> <span class="number">68</span> <span class="number">65</span> <span class="string">6c</span> <span class="string">6c</span> <span class="string">6f</span> <span class="number">20</span> <span class="number">55</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>把 udp 校验和置为 00 00:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">d3</span> <span class="number">43</span> <span class="number">11</span> <span class="string">7b</span> <span class="string">cb</span> <span class="number">51</span> <span class="number">15</span> <span class="string">3d</span> <span class="number">00</span> <span class="number">11</span> <span class="number">00</span> <span class="number">12</span> <span class="string">f8</span> <span class="string">3d</span> <span class="number">30</span> <span class="number">39</span> <span class="number">00</span> <span class="number">12</span> <span class="number">00</span> <span class="number">00</span> <span class="number">55</span> <span class="string">aa</span> <span class="number">68</span> <span class="number">65</span> <span class="string">6c</span> <span class="string">6c</span> <span class="string">6f</span> <span class="number">20</span> <span class="number">55</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>进行两字节以大端方式累加求和，如果和大于2字节时，则和值中高2字节加上低2字节的值作为最终的和值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0004</span> + <span class="number">0xdce2</span> = <span class="number">0xdce6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对最终的和值求反，即关于2字节的补:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0xffff</span> - <span class="number">0xdce6</span> = <span class="number">0x2319</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="udp-首部校验和-python-实现"><a href="#udp-首部校验和-python-实现" class="headerlink" title="udp 首部校验和 python 实现"></a>udp 首部校验和 python 实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@jit(nopython=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ip_check_sum_int</span>(<span class="params">block</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对应算法里的步骤4</span></span><br><span class="line"><span class="string">    return: 整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    check_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(block), <span class="number">2</span>):</span><br><span class="line">        check_sum += (block[i] &lt;&lt; <span class="number">8</span>) + block[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> (check_sum &gt;&gt; <span class="number">16</span>) != <span class="number">0</span>:</span><br><span class="line">        check_sum = (check_sum &gt;&gt; <span class="number">16</span>) + (check_sum &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">    <span class="keyword">return</span> check_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">udp_check_sum</span>(<span class="params">block</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对应算法里的步骤1、2、3、5</span></span><br><span class="line"><span class="string">    tcp 时 ptcl = 0x06</span></span><br><span class="line"><span class="string">    return: 2字节二进制整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ptcl = <span class="number">0x11</span></span><br><span class="line">    fake_udp_header = block[<span class="number">12</span>:<span class="number">20</span>] + bytearray([<span class="number">0x00</span>, ptcl]) + block[<span class="number">24</span>:<span class="number">26</span>]</span><br><span class="line">    new_block = fake_udp_header + block[<span class="number">20</span>:<span class="number">26</span>] + bytearray([<span class="number">0x00</span>, <span class="number">0x00</span>]) + block[<span class="number">28</span>:]</span><br><span class="line">    check_sum = <span class="number">0xFFFF</span> - ip_check_sum_int(new_block)</span><br><span class="line">    <span class="keyword">return</span> bytearray([check_sum &gt;&gt; <span class="number">8</span>, check_sum &amp; <span class="number">0xFF</span>])</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><p><a href="https://blog.csdn.net/limanjihe/article/details/85270291">理解UDP协议的首部校验和校验和</a></p>
</li>
<li><p><a href="https://blog.csdn.net/zhangyang0402/article/details/3924108">IP数据报首部checksum的计算</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>computer science</category>
      </categories>
      <tags>
        <tag>ip</tag>
        <tag>tcp</tag>
        <tag>udp</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Windows10 上配置 Java JDK 14 开发环境</title>
    <url>/2021/03/30/java14-path-windows10/</url>
    <content><![CDATA[<p>Java 是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级 Web 应用开发和移动应用开发。任职于 Sun 微系统的詹姆斯·高斯林等人于1990年代初开发Java语言的雏形，最初被命名为 Oak，目标设置在家用电器等小型系统的编程语言，应用在电视机、电话、闹钟、烤面包机等家用电器的控制和通信。随着1990年代互联网的发展，Sun 公司看见 Oak 在互联网上应用的前景，于是改造了 Oak，于1995年5月以 Java 的名称正式发布。后来 Sun 公司被甲骨文公司并购，Java 也随之成为甲骨文公司的产品。Java 伴随着互联网的迅猛发展而发展，逐渐成为重要的网络编程语言。Java 编程语言的风格十分接近 C++ 语言。继承了 C++ 语言面向对象技术的核心，舍弃了容易引起错误的指针，以引用取代；移除了 C++ 中的运算符重载和多重继承特性，用接口取代；增加垃圾回收器功能。Java 不同于一般的编译语言或解释型语言。它首先将源代码编译成字节码，再依赖各种不同平台上的虚拟机来解释执行字节码，从而具有“一次编写，到处运行”的跨平台特性。现时，移动操作系统 Android 大部分的代码采用 Java 编程语言编程。</p>
<p>总之，Java 编程语言是个简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言。下面介绍如何在 Windows10 上配置 Java JDK 14 的环境变量。</p>
<a id="more"></a>

<h1 id="下载-Java-JDK-14"><a href="#下载-Java-JDK-14" class="headerlink" title="下载 Java JDK 14"></a>下载 Java JDK 14</h1><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>打开官网： <a href="https://www.oracle.com/java/technologies/javase/jdk14-archive-downloads.html">https://www.oracle.com/java/technologies/javase/jdk14-archive-downloads.html</a></p>
<p>下载需要的 Windows 版本。</p>
<h2 id="MAVEN"><a href="#MAVEN" class="headerlink" title="MAVEN"></a>MAVEN</h2><p>在使用 Java 编写程序时，最习惯使用 Maven 进行工程构建与管理，因此，这里给出下载 Maven 的地址：<a href="https://maven.apache.org/download.cgi#">https://maven.apache.org/download.cgi#</a></p>
<h1 id="安装-Java-JDK-14"><a href="#安装-Java-JDK-14" class="headerlink" title="安装 Java JDK 14"></a>安装 Java JDK 14</h1><h2 id="JDK-1"><a href="#JDK-1" class="headerlink" title="JDK"></a>JDK</h2><p>直接点击安装，默认安装即可。在安装后，只有 jdk 而没有 JRE，这是与 Java 8 不同的。并且，在 lib 里面也没有 tools.jar</p>
<h2 id="MAVEN-1"><a href="#MAVEN-1" class="headerlink" title="MAVEN"></a>MAVEN</h2><p>把 Maven 解压，复制到需要的目录下，如我这里是： C:\Program Files\apache-maven-3.6.3</p>
<h1 id="配置-Java-环境"><a href="#配置-Java-环境" class="headerlink" title="配置 Java 环境"></a>配置 Java 环境</h1><h2 id="JDK-2"><a href="#JDK-2" class="headerlink" title="JDK"></a>JDK</h2><p>右键点击此电脑—》属性—》高级系统设置—》环境变量—》系统变量—》新建—》变量名写 “JAVA_HOME”—》变量值写Java JDK 14安装目录，我这里是“C:\Program Files\jdk-14.0.2” —》确定</p>
<p>系统变量—》Path—》编辑—》新建—》%JAVA_HOME%\bin—》确定—》确定—》确定</p>
<h2 id="MAVEN-2"><a href="#MAVEN-2" class="headerlink" title="MAVEN"></a>MAVEN</h2><p>Maven 的配置同 Java JDK</p>
<h1 id="测试环境变量"><a href="#测试环境变量" class="headerlink" title="测试环境变量"></a>测试环境变量</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>win + r 打开运行，输入 <code>cmd</code>，打开命令行提示符，输入<code>java --version</code> 如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\jinzhongxu&gt;java --version</span><br><span class="line">java 14.0.2 2020-07-14</span><br><span class="line">Java(TM) SE Runtime Environment (build 14.0.2+12-46)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 14.0.2+12-46, mixed mode, sharing)</span><br></pre></td></tr></table></figure>

<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>win + r 打开运行，输入<code>cmd</code>，打开命令行提示符，输入 <code>mvn -v</code> 如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\jinzhongxu&gt;mvn -v</span><br><span class="line">Apache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)</span><br><span class="line">Maven home: C:\Program Files\apache-maven-3.6.3\bin\..</span><br><span class="line">Java version: 14.0.2, vendor: Oracle Corporation, runtime: C:\Program Files\jdk-14.0.2</span><br><span class="line">Default locale: zh_CN, platform encoding: GBK</span><br><span class="line">OS name: <span class="string">&quot;windows 10&quot;</span>, version: <span class="string">&quot;10.0&quot;</span>, arch: <span class="string">&quot;amd64&quot;</span>, family: <span class="string">&quot;windows&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="Maven-镜像配置"><a href="#Maven-镜像配置" class="headerlink" title="Maven 镜像配置"></a>Maven 镜像配置</h1><p>因 Maven 默认镜像在国内下载限制，因此，建议更改为阿里云的镜像，方法如下：（建议修改 <strong>settings.xml</strong> 前先复制保持一份）</p>
<p>打开文件 <strong>C:\Program Files\apache-maven-3.6.3\conf\settings.xml</strong>，编辑为如下：</p>
<p>需要说明的是：建议把修改好的 settings.xml 拷贝到 C:\Users\jinzhongxu.m2 目录下一份。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mirrors</span></span><br><span class="line"><span class="comment">   | This is a list of mirrors to be used in downloading artifacts from remote repositories.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | It works like this: a POM may declare a repository to use in resolving certain artifacts.</span></span><br><span class="line"><span class="comment">   | However, this repository may have problems with heavy traffic at times, so people have mirrored</span></span><br><span class="line"><span class="comment">   | it to several places.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | That repository definition will have a unique id, so we can create a mirror reference for that</span></span><br><span class="line"><span class="comment">   | repository, to be used as an alternate download site. The mirror site will be the preferred</span></span><br><span class="line"><span class="comment">   | server for that repository.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mirror</span></span><br><span class="line"><span class="comment">     | Specifies a repository mirror site to use instead of a given repository. The repository that</span></span><br><span class="line"><span class="comment">     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used</span></span><br><span class="line"><span class="comment">     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;mirror&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;nexus-osc&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span></span><br><span class="line"><span class="comment">      &lt;name&gt;Nexus osc&lt;/name&gt;</span></span><br><span class="line"><span class="comment">      &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central&lt;/url&gt;</span></span><br><span class="line"><span class="comment">    &lt;/mirror&gt;</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-osc<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus osc<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- profile</span></span><br><span class="line"><span class="comment">     | Specifies a set of introductions to the build process, to be activated using one or more of the</span></span><br><span class="line"><span class="comment">     | mechanisms described above. For inheritance purposes, and to activate profiles via &lt;activatedProfiles/&gt;</span></span><br><span class="line"><span class="comment">     | or the command line, profiles have to have an ID that is unique.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | An encouraged best practice for profile identification is to use a consistent naming convention</span></span><br><span class="line"><span class="comment">     | for profiles, such as &#x27;env-dev&#x27;, &#x27;env-test&#x27;, &#x27;env-production&#x27;, &#x27;user-jdcasey&#x27;, &#x27;user-brett&#x27;, etc.</span></span><br><span class="line"><span class="comment">     | This will make it more intuitive to understand what the set of introduced profiles is attempting</span></span><br><span class="line"><span class="comment">     | to accomplish, particularly when you only have a list of profile id&#x27;s for debug.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo.</span></span><br><span class="line"><span class="comment">    &lt;profile&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;jdk-1.4&lt;/id&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;activation&gt;</span></span><br><span class="line"><span class="comment">        &lt;jdk&gt;1.4&lt;/jdk&gt;</span></span><br><span class="line"><span class="comment">      &lt;/activation&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;repositories&gt;</span></span><br><span class="line"><span class="comment">        &lt;repository&gt;</span></span><br><span class="line"><span class="comment">          &lt;id&gt;jdk14&lt;/id&gt;</span></span><br><span class="line"><span class="comment">          &lt;name&gt;Repository for JDK 1.4 builds&lt;/name&gt;</span></span><br><span class="line"><span class="comment">          &lt;url&gt;http://www.myhost.com/maven/jdk14&lt;/url&gt;</span></span><br><span class="line"><span class="comment">          &lt;layout&gt;default&lt;/layout&gt;</span></span><br><span class="line"><span class="comment">          &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt;</span></span><br><span class="line"><span class="comment">        &lt;/repository&gt;</span></span><br><span class="line"><span class="comment">      &lt;/repositories&gt;</span></span><br><span class="line"><span class="comment">    &lt;/profile&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     | Here is another profile, activated by the system property &#x27;target-env&#x27; with a value of &#x27;dev&#x27;,</span></span><br><span class="line"><span class="comment">     | which provides a specific path to the Tomcat instance. To use this, your plugin configuration</span></span><br><span class="line"><span class="comment">     | might hypothetically look like:</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | ...</span></span><br><span class="line"><span class="comment">     | &lt;plugin&gt;</span></span><br><span class="line"><span class="comment">     |   &lt;groupId&gt;org.myco.myplugins&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">     |   &lt;artifactId&gt;myplugin&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     |   &lt;configuration&gt;</span></span><br><span class="line"><span class="comment">     |     &lt;tomcatLocation&gt;$&#123;tomcatPath&#125;&lt;/tomcatLocation&gt;</span></span><br><span class="line"><span class="comment">     |   &lt;/configuration&gt;</span></span><br><span class="line"><span class="comment">     | &lt;/plugin&gt;</span></span><br><span class="line"><span class="comment">     | ...</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | <span class="doctag">NOTE:</span> If you just wanted to inject this configuration whenever someone set &#x27;target-env&#x27; to</span></span><br><span class="line"><span class="comment">     |       anything, you could just leave off the &lt;value/&gt; inside the activation-property.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;profile&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;env-dev&lt;/id&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;activation&gt;</span></span><br><span class="line"><span class="comment">        &lt;property&gt;</span></span><br><span class="line"><span class="comment">          &lt;name&gt;target-env&lt;/name&gt;</span></span><br><span class="line"><span class="comment">          &lt;value&gt;dev&lt;/value&gt;</span></span><br><span class="line"><span class="comment">        &lt;/property&gt;</span></span><br><span class="line"><span class="comment">      &lt;/activation&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;properties&gt;</span></span><br><span class="line"><span class="comment">        &lt;tomcatPath&gt;/path/to/tomcat/instance&lt;/tomcatPath&gt;</span></span><br><span class="line"><span class="comment">      &lt;/properties&gt;</span></span><br><span class="line"><span class="comment">    &lt;/profile&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>development<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>14<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>14<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>14<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>14<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://blog.csdn.net/qq_42583206/article/details/108375173">永久解决 Intellij idea 报错：Error : java 不支持发行版本5</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>windows10</tag>
      </tags>
  </entry>
  <entry>
    <title>各类期刊的区别</title>
    <url>/2020/10/09/journal-or-transactions/</url>
    <content><![CDATA[<p>在学术界各类期刊纷繁复杂，眼花缭乱，选择合适的期刊，对投稿将是有利无弊的。下面分别给出 journal, transactions, magazine, proceedings, acta, bulletin, letter, communication, annals, archives, review, current opinion, advance, trends, progress, frontiers 等的区别介绍，方便选择合适的类型投稿。</p>
<a id="more"></a>

<h1 id="journal-期刊"><a href="#journal-期刊" class="headerlink" title="journal 期刊"></a>journal 期刊</h1><p>Journal 本意为日记，个人经验和反思的记录，引申为 A periodical presenting articles on a particular subject. 学报最典型的叫法， 刊登关于某特殊主题的文章的期刊。</p>
<p>要求有很大的创新点，比较详细的公式推导。因 Journal 面向的读者较广泛，因此发表在其上的文章需要对背景知识有更加全面的介绍。</p>
<p>如：<a href="https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=8016796">IMA Journal of Applied Mathematics</a></p>
<h1 id="transactions-汇刊"><a href="#transactions-汇刊" class="headerlink" title="transactions 汇刊"></a>transactions 汇刊</h1><p>Transactions 本意为商业交易和谈判，引申为公开发表的大会记录。后来有汇刊的意思。</p>
<p>其具体到一个相对较细的专业方向上，发表在 transactions 上的文章需要有很大的创新和详细的公式推导。</p>
<p>如：<a href="https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=34">IEEE Transactions on Pattern Analysis and Machine Intelligence</a></p>
<h1 id="magazine-杂志"><a href="#magazine-杂志" class="headerlink" title="magazine 杂志"></a>magazine 杂志</h1><p>Magazine 本意为储藏室，后引申为 A periodical containing a collection of articles, stories, pictures, or other features. 中文表示杂志，是一种综合性内容的期刊。</p>
<p>其是行业期刊，一般采用约稿的形式，由杂志社定主题，然后邀请该领域有关人写稿，一般不接受自由投稿。一般要求用文字和图表来表述些最新研究成果，不允许有过多的公式推导。</p>
<p>如：<a href="https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=57">IEEE Electrical Insulation Magazine</a></p>
<h1 id="proceedings-会刊"><a href="#proceedings-会刊" class="headerlink" title="proceedings 会刊"></a>proceedings 会刊</h1><p>Proceedings 表示某行动，或行动过程或方式，引申意之一是学术团体或其他正规团体会议所讨论问题的记录，进一步有会议论文集的意思。有会刊、记录、会议录的意思。</p>
<p>但是 IEEE 的 Proceedings 也变成了期刊 (出版周期相对长)，并没有会议支撑。</p>
<p>如：<a href="https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=5">Proceedings of the IEEE</a></p>
<h1 id="acta-学报"><a href="#acta-学报" class="headerlink" title="acta 学报"></a>acta 学报</h1><p>Acta是拉丁文的“学报”。</p>
<p>如：<a href="https://link.springer.com/journal/11511/">Acta Mathematica</a></p>
<h1 id="bulletin-通报"><a href="#bulletin-通报" class="headerlink" title="bulletin 通报"></a>bulletin 通报</h1><p>通报在中国很常见，如科学通报，数学通报，物理通报等等。</p>
<p>如：<a href="https://engine.scichina.com/publisher/scp/journal/CSB?slug=abstracts">Chinese Science Bulletin</a>, <a href="https://www.journals.elsevier.com/science-bulletin">Science Bulletin</a></p>
<h1 id="letter-短讯"><a href="#letter-短讯" class="headerlink" title="letter 短讯"></a>letter 短讯</h1><p>Letters 类期刊的文章都比较短，通常为短信或短讯。但在如今眼球文化，急功近利的年代，letter 的受众比较大，因此影响因子往往蛮高的。</p>
<p>如：<a href="https://iopscience.iop.org/journal/0256-307X">Chinese Physics Letters</a></p>
<h1 id="communication-通讯"><a href="#communication-通讯" class="headerlink" title="communication 通讯"></a>communication 通讯</h1><p>通讯上期刊文章也比较短，但是一般比 letter 长。</p>
<p>如： <a href="https://www.journals.elsevier.com/mechanics-research-communications">Mechanics Research Communications</a></p>
<h1 id="annals-年鉴，年刊-纪事"><a href="#annals-年鉴，年刊-纪事" class="headerlink" title="annals 年鉴，年刊, 纪事"></a>annals 年鉴，年刊, 纪事</h1><p>这类期刊一般一年一期，影响常常是很大的，影响因子较高。</p>
<p>如：<a href="https://annals.math.princeton.edu/">Annals of Mathematics</a></p>
<h1 id="archives-档案"><a href="#archives-档案" class="headerlink" title="archives 档案"></a>archives 档案</h1><p>Archives 是存档的意思。有的期刊以此为名。</p>
<p>如： <a href="https://acoustics.ippt.pan.pl/index.php/aa">Archives of Acoustics</a></p>
<h1 id="review-评论"><a href="#review-评论" class="headerlink" title="review 评论"></a>review 评论</h1><p>这类期刊为综述性，影响很大，但年发文量比较少，影响因子很高。</p>
<p>如： <a href="https://www.annualreviews.org/journal/fluid">Annual Review of Fluid Mechanics</a></p>
<h1 id="current-opinion-当前观点"><a href="#current-opinion-当前观点" class="headerlink" title="current opinion 当前观点"></a>current opinion 当前观点</h1><p>这是Elsevier出版的CurrentOpinion系列，目前有17种。综述期刊，影响因子很高。每篇文章的opinion确实是非常到位的。</p>
<p>如：<a href="https://www.journals.elsevier.com/current-opinion-in-cell-biology">Current Opinion in Cell Biology</a></p>
<h1 id="advance-进展"><a href="#advance-进展" class="headerlink" title="advance 进展"></a>advance 进展</h1><p>如：<a href="https://www.journals.elsevier.com/advances-in-mathematics">Advances in Mathematics</a></p>
<h1 id="trends-趋势"><a href="#trends-趋势" class="headerlink" title="trends 趋势"></a>trends 趋势</h1><p>Trends in…是 Cell 出版社的系列综述性刊物，影响因子很高。</p>
<p>如：<a href="https://www.cell.com/trends/cell-biology/home">Trends in Cell Biology</a></p>
<h1 id="progress-进展"><a href="#progress-进展" class="headerlink" title="progress 进展"></a>progress 进展</h1><p>如：<a href="https://www.journals.elsevier.com/progress-in-natural-science-materials-international">Progress in Natural Science: Materials International</a></p>
<h1 id="frontiers-前沿"><a href="#frontiers-前沿" class="headerlink" title="frontiers 前沿"></a>frontiers 前沿</h1><p>是 <a href="https://www.frontiersin.org/">frontiers</a> 办的电子期刊，应该历史比较短，影响力有发展空间。</p>
<h1 id="Science-Nature-Cell-顶级期刊出版社"><a href="#Science-Nature-Cell-顶级期刊出版社" class="headerlink" title="Science, Nature, Cell 顶级期刊出版社"></a>Science, Nature, Cell 顶级期刊出版社</h1><p><a href="https://science.sciencemag.org/">science</a></p>
<p><a href="https://www.nature.com/">nature</a></p>
<p><a href="https://www.cell.com/">cell</a></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="https://blog.csdn.net/zklth/article/details/6281079">journal,magazine,transaction,proceeding 的区别</a></li>
<li><a href="http://blog.sciencenet.cn/blog-510768-1108650.html">“刊物”恁多叫法迷人眼</a></li>
</ol>
]]></content>
      <categories>
        <category>research</category>
        <category>article</category>
      </categories>
      <tags>
        <tag>research</tag>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>设置 Jupyter Cell Proxy</title>
    <url>/2021/08/31/jupyter-cell-proxy/</url>
    <content><![CDATA[<p>Jupyter Notebook/Lab 提供了交互式的 Python 等编程范式，下面介绍一种设置 Proxy 的方法，方便 Python 代码的运行。</p>
<a id="more"></a>

<p>只需要在 Jupyter Notebook/Lab 第一个 Cell 上添加如下代码即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 设置代理</span></span><br><span class="line">proxy = <span class="string">&#x27;http://127.0.0.1:1080&#x27;</span></span><br><span class="line">os.environ[<span class="string">&#x27;http_proxy&#x27;</span>] = proxy</span><br><span class="line">os.environ[<span class="string">&#x27;HTTP_PROXY&#x27;</span>] = proxy</span><br><span class="line">os.environ[<span class="string">&#x27;https_proxy&#x27;</span>] = proxy</span><br><span class="line">os.environ[<span class="string">&#x27;HTTPS_PROXY&#x27;</span>] = proxy</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>jupyter</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>java 一条语句打印多个变量</title>
    <url>/2022/01/03/java-print-multi-variables/</url>
    <content><![CDATA[<p>在 java 程序中，想要通过一条语句打印输出多个变量的值，就像在 python 中那样，将变量以逗号分隔罗列到 print 函数中是不行的，在 java 中可以使用如下方法。</p>
<a id="more"></a>

<h1 id="字符串拼接和占位符"><a href="#字符串拼接和占位符" class="headerlink" title="字符串拼接和占位符"></a>字符串拼接和占位符</h1><ol>
<li>通过字符串拼接在函数 System.out.println() 中；</li>
<li>通过占位符在函数 System.out.printf() 中；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2147483647</span>;</span><br><span class="line">        <span class="keyword">int</span> i2 = -<span class="number">2147483648</span>;</span><br><span class="line">        <span class="keyword">int</span> i3 = <span class="number">2_000_000</span>;</span><br><span class="line">        <span class="keyword">int</span> i4 = <span class="number">0xff0000</span>;</span><br><span class="line">        <span class="keyword">int</span> i5 = <span class="number">0b1000000000</span>;</span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">9000000000000000000L</span>;</span><br><span class="line">        <span class="comment">// 通过 &quot;+&quot; 对字符串进行拼接</span></span><br><span class="line">        System.out.println(i + <span class="string">&quot;, &quot;</span> + i2 + <span class="string">&quot;, &quot;</span> + i3 + <span class="string">&quot;, &quot;</span> + i4 + <span class="string">&quot;, &quot;</span> + i5 + <span class="string">&quot;, &quot;</span> + l);</span><br><span class="line">        <span class="comment">// 注意 printf 最后面没有换行符，想要换行需要手动添加</span></span><br><span class="line">        <span class="comment">// 通过占位符，打印多个变量</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%d, %d, %d, %d, %d, %d\n&quot;</span>, i, i2, i3, i4, i5, l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2147483647</span>, -<span class="number">2147483648</span>, <span class="number">2000000</span>, <span class="number">16711680</span>, <span class="number">512</span>, <span class="number">9000000000000000000</span></span><br><span class="line"><span class="number">2147483647</span>, -<span class="number">2147483648</span>, <span class="number">2000000</span>, <span class="number">16711680</span>, <span class="number">512</span>, <span class="number">9000000000000000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>printf 支持的占位符如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%c        单个字符 </span></span><br><span class="line"><span class="comment">%d        十进制整数 </span></span><br><span class="line"><span class="comment">%f        十进制浮点数 </span></span><br><span class="line"><span class="comment">%o        八进制数 </span></span><br><span class="line"><span class="comment">%s        字符串 </span></span><br><span class="line"><span class="comment">%u        无符号十进制数 </span></span><br><span class="line"><span class="comment">%x        十六进制数 </span></span><br><span class="line"><span class="comment">%08x      十六进制数，用0补足8位</span></span><br><span class="line"><span class="comment">%e	      格式化输出科学计数法表示的浮点数</span></span><br><span class="line"><span class="comment">%%        输出百分号% </span></span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://blog.csdn.net/CrayonK/article/details/84822448">java一条System.out语句打印多个变量</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Jupyter 中使用 Matlab</title>
    <url>/2021/07/27/jupyter-kernel-matlab/</url>
    <content><![CDATA[<p>Jupyter 为创建交互式脚本提供了一个强大且广泛的平台，在这里介绍一种在 Jupyter 中调用 Matlab 的方法。假设已经安装了 Miniconda 或者 Anaconda， Matlab 版本是 2020a，安装在路径：<code>/usr/local/MATLAB</code> 下。</p>
<a id="more"></a>

<h1 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h1><p>因为 Matlab 2020a 对用的 Python 版本最高为 3.7，所以这里安装对于版本，虚拟环境名字命名为 jmatlab</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -vv -n jmatlab python=3.7 jupyter</span><br></pre></td></tr></table></figure>

<h1 id="激活-jmatlab-环境"><a href="#激活-jmatlab-环境" class="headerlink" title="激活 jmatlab 环境"></a>激活 jmatlab 环境</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate jmatlab</span><br></pre></td></tr></table></figure>

<h1 id="安装-jupyterlab-和-matlab-内核"><a href="#安装-jupyterlab-和-matlab-内核" class="headerlink" title="安装 jupyterlab 和 matlab 内核"></a>安装 jupyterlab 和 matlab 内核</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install jupyterlab</span><br><span class="line">pip install matlab_kernel</span><br><span class="line">python -m matlab_kernel install</span><br></pre></td></tr></table></figure>

<h1 id="查看安装的内核"><a href="#查看安装的内核" class="headerlink" title="查看安装的内核"></a>查看安装的内核</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter kernelspec list</span><br></pre></td></tr></table></figure>

<p>您应该在可用内核列表中看到 Matlab.</p>
<h1 id="安装-Matlab-引擎"><a href="#安装-Matlab-引擎" class="headerlink" title="安装 Matlab 引擎"></a>安装 Matlab 引擎</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/MATLAB/extern/engines/python</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>

<p>这将允许从 Python 会话中调用 Matlab 引擎。</p>
<h1 id="重启-jupyterlab"><a href="#重启-jupyterlab" class="headerlink" title="重启 jupyterlab"></a>重启 jupyterlab</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart jupyterhub.service</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="http://www.jmlilly.net/jupyter-matlab">Using Jupyter Notebooks and JupyterLab with Matlab</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>jupyter</tag>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Java 命令运行 jar 包</title>
    <url>/2021/03/30/java-run-jar/</url>
    <content><![CDATA[<p>Java 使用 Maven 等 打包好程序为 Jar 后，如何运行，这里根据 Jar 包中是否有主类 （main class）入口，来分两种方法运行。</p>
<a id="more"></a>

<h1 id="Maven-打包-Java-代码"><a href="#Maven-打包-Java-代码" class="headerlink" title="Maven 打包 Java 代码"></a>Maven 打包 Java 代码</h1><p>这种方法打包的 JAR 包默认不包含主类入口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在工程代码主目录下</span></span><br><span class="line">mvn clean package</span><br><span class="line"><span class="comment"># clean 是清除之前打包的残留</span></span><br><span class="line"><span class="comment"># package 是打包</span></span><br></pre></td></tr></table></figure>

<h1 id="利用-Artifacts-打包带有主类入口的-Jar-包"><a href="#利用-Artifacts-打包带有主类入口的-Jar-包" class="headerlink" title="利用 Artifacts 打包带有主类入口的 Jar 包"></a>利用 Artifacts 打包带有主类入口的 Jar 包</h1><p>File—》Project Structure—》Artifacts—》+—》JAR—&gt;from module with dependencies—&gt;Main Class—&gt;copy to the output directory and link via manifest—&gt;Directory for META-INF/MANIFEST.MF 选择 resources文件夹—》ok—&gt;ok—&gt;Build—&gt;Build Artifacts—&gt;Build</p>
<p>当不选主类或者 Directory for META-INF/MANIFEST.MF 选择默认的 java 文件夹时，都不会包含主类入口。</p>
<h1 id="Jar-包中有主类入口"><a href="#Jar-包中有主类入口" class="headerlink" title="Jar 包中有主类入口"></a>Jar 包中有主类入口</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar target\java-learn-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<h1 id="Jar-包中没有主类入口"><a href="#Jar-包中没有主类入口" class="headerlink" title="Jar 包中没有主类入口"></a>Jar 包中没有主类入口</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -cp target\java-learn-1.0-SNAPSHOT.jar com.mathscv.App</span><br><span class="line"><span class="comment"># 这里 com.mathscv 为包名或者 groupId，App 为主类</span></span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://blog.csdn.net/SweetTool/article/details/73826121">java命令如何运行jar包</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jar</tag>
      </tags>
  </entry>
  <entry>
    <title>把 jupyter notebook 导出为 pdf</title>
    <url>/2021/05/25/jupyter-notebook-output-pdf/</url>
    <content><![CDATA[<p>在 Jupyter Notebook 中书写代码非常方便，同时可以书写 Markdown 说明文档，使得其展示、交流非常高效。但是，常常需要我们把 Jupyter Notebook 导出为 PDF 才更容易交流，这样接收者只需要能打开 PDF 即可，不需要专门安装打开 .ipynb 的工具。但是，从Jupyter Notebook 导出 PDF 需要安装一些包，这里以 Debian 平台为例。</p>
<a id="more"></a>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install texlive texlive-latex-extra pandoc texlive-xetex</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>jupyter</tag>
        <tag>notebook</tag>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 jupyterhub 搭建多用户 python 开发环境</title>
    <url>/2021/12/21/jupyterhub-2-multiuser/</url>
    <content><![CDATA[<p>JupyterHub 是为多个用户提供 JupyterLab 的集成服务系统，每个用户相互隔离。在 JupyterHub 版本低于 2.0.0 时，可采用<a href="https://xujinzh.github.io/2021/02/20/jupyterhub">该方法</a>部署。本篇介绍对于最新版 JupyterHub 2.0.0 （截止到2021年12月21日）的部署方法。相关环境是 miniconda, wsl (ubuntu)，所有命令以 root 用户运行。</p>
<a id="more"></a>

<h1 id="安装-miniconda"><a href="#安装-miniconda" class="headerlink" title="安装 miniconda"></a>安装 miniconda</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到主目录，下载miniconda并安装</span></span><br><span class="line"><span class="built_in">cd</span> </span><br><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line">chmod +x Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line">./Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line"><span class="comment"># 选择安装在 /usr/local/miniconda</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=/usr/local/miniconda/bin:$PATH&#x27;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=/usr/local/miniconda/bin:$PATH&#x27;</span> &gt;&gt; .bashrc</span><br><span class="line"><span class="comment"># 同时添加到普通用户，如 jinzhongxu</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=/usr/local/miniconda/bin:$PATH&#x27;</span> &gt;&gt; /home/jinzhongxu/.bashrc</span><br><span class="line"><span class="comment"># 更新环境变量</span></span><br><span class="line"><span class="built_in">source</span> .bashrc</span><br><span class="line"><span class="comment"># 添加用户访问权限</span></span><br><span class="line">groupadd miniconda</span><br><span class="line">chgrp -R miniconda /usr/<span class="built_in">local</span>/miniconda</span><br><span class="line">chmod 770 -R /usr/<span class="built_in">local</span>/miniconda</span><br><span class="line">usermod -a -G miniconda root</span><br><span class="line">usermod -a -G miniconda jinzhongxu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果添加新的用户(如 admin)使用 jupyterhub，后续只需要将该用户 admin 添加到组 miniconda 中即可，方法如下</span></span><br><span class="line"><span class="comment"># sudo usermod -a -G miniconda admin</span></span><br><span class="line"><span class="comment"># 删除用户方法如下，即把用户admin从组miniconda中删除。然后重启jupyterhub</span></span><br><span class="line"><span class="comment"># sudo gpasswd -d admin miniconda</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装常用包</span></span><br><span class="line">pip install --upgrade pip </span><br><span class="line">pip install jupyterhub jupyterlab pandas matplotlib youtube_dl numba boost scipy numpy sympy scikit-learn opencv-contrib-python Pillow</span><br><span class="line">pip install jupyterlab_code_formatter;jupyter server extension <span class="built_in">enable</span> jupyterlab_code_formatter;pip install black isort</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 configurable-http-proxy</span></span><br><span class="line">apt install nodejs npm -y</span><br><span class="line">npm install -g configurable-http-proxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成配置文件</span></span><br><span class="line">jupyterhub --generate-config</span><br><span class="line">mkdir -p /etc/jupyterhub</span><br><span class="line">mv jupyterhub_config.py /etc/jupyterhub/config.py</span><br><span class="line"><span class="comment"># 使得普通用户jinzhongxu也能够在该目录创建文件</span></span><br><span class="line">chown -R jinzhongxu /etc/jupyterhub/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 wsl 为base url, jinzhongxu 为管理员用户</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c.JupyterHub.base_url = &#x27;/wsl&#x27;&quot;</span> &gt;&gt; /etc/jupyterhub/config.py</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c.JupyterHub.hub_ip = &#x27;0.0.0.0&#x27;&quot;</span> &gt;&gt; /etc/jupyterhub/config.py</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c.Authenticator.delete_invalid_users = True&quot;</span> &gt;&gt; /etc/jupyterhub/config.py</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c.Authenticator.admin_users = set([&#x27;jinzhongxu&#x27;])&quot;</span> &gt;&gt; /etc/jupyterhub/config.py</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c.JupyterHub.admin_access = True&quot;</span> &gt;&gt; /etc/jupyterhub/config.py</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c.Spawner.cmd = [&#x27;/usr/local/miniconda/bin/jupyterhub-singleuser&#x27;]&quot;</span> &gt;&gt; /etc/jupyterhub/config.py</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c.JupyterHub.authenticator_class = &#x27;jupyterhub.auth.DummyAuthenticator&#x27;&quot;</span>  &gt;&gt; /etc/jupyterhub/config.py</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>如果之前使用过 jupyter，需删除 /root/.jupyter 和 /home/jinzhongxu/.jupyter</li>
<li>如果使用普通用户启动jupyterhub，需要该用户有使用configurable-http-proxy的权限</li>
</ol>
<h1 id="配置启动"><a href="#配置启动" class="headerlink" title="配置启动"></a>配置启动</h1><p>因为 wsl 不能使用 systemctl，这里使用 service，创建文件 <code>/etc/init.d/jupyterhub</code>，添加如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line"><span class="comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="comment"># Provides:          jupyterhub</span></span><br><span class="line"><span class="comment"># Required-Start:    $remote_fs $syslog</span></span><br><span class="line"><span class="comment"># Required-Stop:     $remote_fs $syslog</span></span><br><span class="line"><span class="comment"># Default-Start:     2 3 4 5</span></span><br><span class="line"><span class="comment"># Default-Stop:      0 1 6</span></span><br><span class="line"><span class="comment"># Short-Description: Start jupyterhub</span></span><br><span class="line"><span class="comment"># Description:       This file should be used to construct scripts to be</span></span><br><span class="line"><span class="comment">#                    placed in /etc/init.d.</span></span><br><span class="line"><span class="comment">### END INIT INFO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: JX</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please remove the &quot;Author&quot; lines above and replace them</span></span><br><span class="line"><span class="comment"># with your own name if you copy and modify this script.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Do NOT &quot;set -e&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PATH should only include /usr/* if it runs after the mountnfs.sh script</span></span><br><span class="line">PATH=/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/miniconda/bin:/usr/sbin:/bin:/usr/bin</span><br><span class="line">DESC=<span class="string">&quot;Multi-user server for Jupyter notebooks&quot;</span></span><br><span class="line">NAME=jupyterhub</span><br><span class="line">DAEMON=/usr/<span class="built_in">local</span>/miniconda/bin/jupyterhub</span><br><span class="line">DAEMON_ARGS=<span class="string">&quot;--config=/etc/jupyterhub/config.py&quot;</span></span><br><span class="line">WORKING_DIR=<span class="string">&quot;/etc/jupyterhub&quot;</span></span><br><span class="line">PIDFILE=/etc/jupyterhub/<span class="variable">$NAME</span>.pid</span><br><span class="line">SCRIPTNAME=/etc/init.d/<span class="variable">$NAME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Exit if the package is not installed</span></span><br><span class="line">[ -x <span class="string">&quot;<span class="variable">$DAEMON</span>&quot;</span> ] || <span class="built_in">exit</span> 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read configuration variable file if it is present</span></span><br><span class="line">[ -r /etc/default/<span class="variable">$NAME</span> ] &amp;&amp; . /etc/default/<span class="variable">$NAME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the VERBOSE setting and other rcS variables</span></span><br><span class="line">. /lib/init/vars.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define LSB log_* functions.</span></span><br><span class="line"><span class="comment"># Depend on lsb-base (&gt;= 3.2-14) to ensure that this file is present</span></span><br><span class="line"><span class="comment"># and status_of_proc is working.</span></span><br><span class="line">. /lib/lsb/init-functions</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Function that starts the daemon/service</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">do_start()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"># Return</span></span><br><span class="line">	<span class="comment">#   0 if daemon has been started</span></span><br><span class="line">	<span class="comment">#   1 if daemon was already running</span></span><br><span class="line">	<span class="comment">#   2 if daemon could not be started</span></span><br><span class="line">	start-stop-daemon --start --quiet -d <span class="string">&quot;<span class="variable">$WORKING_DIR</span>&quot;</span> --pidfile <span class="variable">$PIDFILE</span> --<span class="built_in">exec</span> <span class="variable">$DAEMON</span> --<span class="built_in">test</span> &gt; /dev/null \</span><br><span class="line">		|| <span class="built_in">return</span> 1</span><br><span class="line">	start-stop-daemon --start --background --make-pidfile --quiet -d <span class="string">&quot;<span class="variable">$WORKING_DIR</span>&quot;</span> --pidfile <span class="variable">$PIDFILE</span> --<span class="built_in">exec</span> <span class="variable">$DAEMON</span> -- \</span><br><span class="line">		<span class="variable">$DAEMON_ARGS</span> \</span><br><span class="line">		|| <span class="built_in">return</span> 2</span><br><span class="line">	<span class="comment"># Add code here, if necessary, that waits for the process to be ready</span></span><br><span class="line">	<span class="comment"># to handle requests from services started subsequently which depend</span></span><br><span class="line">	<span class="comment"># on this one.  As a last resort, sleep for some time.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Function that stops the daemon/service</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">do_stop()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"># Return</span></span><br><span class="line">	<span class="comment">#   0 if daemon has been stopped</span></span><br><span class="line">	<span class="comment">#   1 if daemon was already stopped</span></span><br><span class="line">	<span class="comment">#   2 if daemon could not be stopped</span></span><br><span class="line">	<span class="comment">#   other if a failure occurred</span></span><br><span class="line">	start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --pidfile <span class="variable">$PIDFILE</span> --name <span class="variable">$NAME</span></span><br><span class="line">	RETVAL=<span class="string">&quot;$?&quot;</span></span><br><span class="line">	[ <span class="string">&quot;<span class="variable">$RETVAL</span>&quot;</span> = 2 ] &amp;&amp; <span class="built_in">return</span> 2</span><br><span class="line">	<span class="comment"># Wait for children to finish too if this is a daemon that forks</span></span><br><span class="line">	<span class="comment"># and if the daemon is only ever run from this initscript.</span></span><br><span class="line">	<span class="comment"># If the above conditions are not satisfied then add some other code</span></span><br><span class="line">	<span class="comment"># that waits for the process to drop all resources that could be</span></span><br><span class="line">	<span class="comment"># needed by services started subsequently.  A last resort is to</span></span><br><span class="line">	<span class="comment"># sleep for some time.</span></span><br><span class="line">	start-stop-daemon --stop --quiet --oknodo --retry=0/30/KILL/5 --<span class="built_in">exec</span> <span class="variable">$DAEMON</span></span><br><span class="line">	[ <span class="string">&quot;$?&quot;</span> = 2 ] &amp;&amp; <span class="built_in">return</span> 2</span><br><span class="line">	<span class="comment"># Many daemons don&#x27;t delete their pidfiles when they exit.</span></span><br><span class="line">	rm -f <span class="variable">$PIDFILE</span></span><br><span class="line">	<span class="built_in">return</span> <span class="string">&quot;<span class="variable">$RETVAL</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Function that sends a SIGHUP to the daemon/service</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="function"><span class="title">do_reload</span></span>() &#123;</span><br><span class="line">	<span class="comment">#</span></span><br><span class="line">	<span class="comment"># If the daemon can reload its configuration without</span></span><br><span class="line">	<span class="comment"># restarting (for example, when it is sent a SIGHUP),</span></span><br><span class="line">	<span class="comment"># then implement that here.</span></span><br><span class="line">	<span class="comment">#</span></span><br><span class="line">	start-stop-daemon --stop --signal 1 --quiet --pidfile <span class="variable">$PIDFILE</span> --name <span class="variable">$NAME</span></span><br><span class="line">	<span class="built_in">return</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  start)</span><br><span class="line">	[ <span class="string">&quot;<span class="variable">$VERBOSE</span>&quot;</span> != no ] &amp;&amp; log_daemon_msg <span class="string">&quot;Starting <span class="variable">$DESC</span>&quot;</span> <span class="string">&quot;<span class="variable">$NAME</span>&quot;</span></span><br><span class="line">	do_start</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;$?&quot;</span> <span class="keyword">in</span></span><br><span class="line">		0|1) [ <span class="string">&quot;<span class="variable">$VERBOSE</span>&quot;</span> != no ] &amp;&amp; log_end_msg 0 ;;</span><br><span class="line">		2) [ <span class="string">&quot;<span class="variable">$VERBOSE</span>&quot;</span> != no ] &amp;&amp; log_end_msg 1 ;;</span><br><span class="line">	<span class="keyword">esac</span></span><br><span class="line">	;;</span><br><span class="line">  stop)</span><br><span class="line">	[ <span class="string">&quot;<span class="variable">$VERBOSE</span>&quot;</span> != no ] &amp;&amp; log_daemon_msg <span class="string">&quot;Stopping <span class="variable">$DESC</span>&quot;</span> <span class="string">&quot;<span class="variable">$NAME</span>&quot;</span></span><br><span class="line">	do_stop</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;$?&quot;</span> <span class="keyword">in</span></span><br><span class="line">		0|1) [ <span class="string">&quot;<span class="variable">$VERBOSE</span>&quot;</span> != no ] &amp;&amp; log_end_msg 0 ;;</span><br><span class="line">		2) [ <span class="string">&quot;<span class="variable">$VERBOSE</span>&quot;</span> != no ] &amp;&amp; log_end_msg 1 ;;</span><br><span class="line">	<span class="keyword">esac</span></span><br><span class="line">	;;</span><br><span class="line">  status)</span><br><span class="line">	status_of_proc <span class="string">&quot;<span class="variable">$DAEMON</span>&quot;</span> <span class="string">&quot;<span class="variable">$NAME</span>&quot;</span> &amp;&amp; <span class="built_in">exit</span> 0 || <span class="built_in">exit</span> $?</span><br><span class="line">	;;</span><br><span class="line">  <span class="comment">#reload|force-reload)</span></span><br><span class="line">	<span class="comment">#</span></span><br><span class="line">	<span class="comment"># If do_reload() is not implemented then leave this commented out</span></span><br><span class="line">	<span class="comment"># and leave &#x27;force-reload&#x27; as an alias for &#x27;restart&#x27;.</span></span><br><span class="line">	<span class="comment">#</span></span><br><span class="line">	<span class="comment">#log_daemon_msg &quot;Reloading $DESC&quot; &quot;$NAME&quot;</span></span><br><span class="line">	<span class="comment">#do_reload</span></span><br><span class="line">	<span class="comment">#log_end_msg $?</span></span><br><span class="line">	<span class="comment">#;;</span></span><br><span class="line">  restart|force-reload)</span><br><span class="line">	<span class="comment">#</span></span><br><span class="line">	<span class="comment"># If the &quot;reload&quot; option is implemented then remove the</span></span><br><span class="line">	<span class="comment"># &#x27;force-reload&#x27; alias</span></span><br><span class="line">	<span class="comment">#</span></span><br><span class="line">	log_daemon_msg <span class="string">&quot;Restarting <span class="variable">$DESC</span>&quot;</span> <span class="string">&quot;<span class="variable">$NAME</span>&quot;</span></span><br><span class="line">	do_stop</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;$?&quot;</span> <span class="keyword">in</span></span><br><span class="line">	  0|1)</span><br><span class="line">		do_start</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;$?&quot;</span> <span class="keyword">in</span></span><br><span class="line">			0) log_end_msg 0 ;;</span><br><span class="line">			1) log_end_msg 1 ;; <span class="comment"># Old process is still running</span></span><br><span class="line">			*) log_end_msg 1 ;; <span class="comment"># Failed to start</span></span><br><span class="line">		<span class="keyword">esac</span></span><br><span class="line">		;;</span><br><span class="line">	  *)</span><br><span class="line">		<span class="comment"># Failed to stop</span></span><br><span class="line">		log_end_msg 1</span><br><span class="line">		;;</span><br><span class="line">	<span class="keyword">esac</span></span><br><span class="line">	;;</span><br><span class="line">  *)</span><br><span class="line">	<span class="comment">#echo &quot;Usage: $SCRIPTNAME &#123;start|stop|restart|reload|force-reload&#125;&quot; &gt;&amp;2</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$SCRIPTNAME</span> &#123;start|stop|status|restart|force-reload&#125;&quot;</span> &gt;&amp;2</span><br><span class="line">	<span class="built_in">exit</span> 3</span><br><span class="line">	;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line">:</span><br></pre></td></tr></table></figure>

<p>使用方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># jinzhongxu 普通用户 或 root 用户均可使用</span></span><br><span class="line">service jupyterhub status</span><br><span class="line">service jupyterhub start</span><br><span class="line">service jupyterhub stop</span><br><span class="line"></span><br><span class="line">/etc/init.d/jupyterhub status</span><br><span class="line">/etc/init.d/jupyterhub start</span><br><span class="line">/etc/init.d/jupyterhub stop</span><br></pre></td></tr></table></figure>

<p>开启成功后，访问网址 <a href="http://localhost:8000/wsl">http://localhost:8000/wsl</a> 即可打开，输入用户名: jinzhongxu，密码: 该用户登录系统的密码。</p>
<h1 id="如果可使用-systemctl"><a href="#如果可使用-systemctl" class="headerlink" title="如果可使用 systemctl"></a>如果可使用 systemctl</h1><p>如果系统可以使用 systemctl，则可使用如下配置。创建文件 <code>/etc/systemd/system/jupyterhub.service</code>，写入内容如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Jupyterhub service</span><br><span class="line">After=syslog.target network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/miniconda/bin/jupyterhub -f /etc/jupyterhub/config.py</span><br><span class="line">WorkingDirectory=/etc/jupyterhub/</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>使用方法如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root 用户使用，普通用户请使用 sudo </span></span><br><span class="line">systemctl status jupyterhub.service</span><br><span class="line">systemctl start jupyterhub.service</span><br><span class="line">systemctl stop jupyterhub.service</span><br><span class="line">systemctl <span class="built_in">enable</span> jupyterhub.service</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>jupyterhub</tag>
        <tag>jupyterlab</tag>
      </tags>
  </entry>
  <entry>
    <title>JupyterLab 的常用快捷键</title>
    <url>/2021/04/07/jupyterlab-common-hotkey/</url>
    <content><![CDATA[<p>JupyterLab 是一款强大的科学生成工具，作为一种基于 WEB 的集成开发环境，可以方便的编写 Python、R、C、Java 等等代码，并且可以操作终端，查看文档、图片等，最优秀的是可以编辑 markdown 文本，这样在代码上下文中书写 markdown 文档。而 Notebook 是我们最常使用的，下面介绍一些常用的 JupyterLab 中 Notebook 快捷键，方便快速编写代码和书写 markdown 文档。</p>
<a id="more"></a>

<h1 id="模式介绍"><a href="#模式介绍" class="headerlink" title="模式介绍"></a>模式介绍</h1><p>在 JupyterLab 的 Notebook 中有两种模式，分别是编码模式（Edit mode）和命令模式（Comman mode）。编码模式就是光标在 code 栏中闪烁时的模式，而命令模式就是点击 code 栏中括号后，code 栏变成灰色时的模式。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">在编码模式下可以通过按 Esc 键进入命令模式</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在命令模式下可以通过按 Enter 键进入编码模式</span><br></pre></td></tr></table></figure>

<h1 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h1><p>这里介绍运行一个 code 栏代码的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctrl + Enter	运行本栏代码，保持在本栏并进入命令模式</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Shift + Enter	运行本栏代码，跳到下一栏并进入命令模式</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alt + Enter	运行本栏代码，跳到下一栏并进入编辑模式</span><br></pre></td></tr></table></figure>

<h1 id="增加代码栏"><a href="#增加代码栏" class="headerlink" title="增加代码栏"></a>增加代码栏</h1><p>在编辑时往往需要插入新的代码栏，快捷键都是在命令模式下进行的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a	在本栏代码前增加一栏，并跳到新增加的一栏，仍处在命令模式下</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b	在本栏代码后增加一栏，并跳到新增加的一栏，仍处在命令模式下</span><br></pre></td></tr></table></figure>

<h1 id="删除不需要的代码栏"><a href="#删除不需要的代码栏" class="headerlink" title="删除不需要的代码栏"></a>删除不需要的代码栏</h1><p>在编辑时，有些无用的代码栏或空白栏需要删除，首先进入命令模型下，通过上下键跳到需要删除的代码栏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd	删除本代码栏，并自动跳到下一栏代码栏，仍处在命令模式下</span><br></pre></td></tr></table></figure>

<h1 id="代码栏-Code-和-Markdown-切换"><a href="#代码栏-Code-和-Markdown-切换" class="headerlink" title="代码栏 Code 和 Markdown 切换"></a>代码栏 Code 和 Markdown 切换</h1><p>当新增一栏后，默认是 Code 模式，如何切换到 Markdown 模式，可以使用如下快捷键。快捷键都是在命令模式下进行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m	切换到 Markdown 模式，仍处在命令模式下，按下 Enter 可进入编辑模式</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y	切换到 Code 模型，仍处在命令行模式下，按下 Enter 可进入编辑模式</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/87403131">JupyterLab，极其强大的下一代notebook！</a></li>
<li><a href="https://blog.csdn.net/qq_35423500/article/details/79565146">jupyter code和markdown转换</a> </li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>jupyterlab</tag>
        <tag>hotkey</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 jupyterhub 搭建多用户 jupyterlab 开发环境</title>
    <url>/2021/02/20/jupyterhub/</url>
    <content><![CDATA[<p>使用 jupyterlab 开发 python 程序非常方便，但是只能单用户访问。想要多用户共用服务器使用 jupyterlab 可以采用 jupyterhub 实现。下面演示在 CentOS 上搭建 jupyterhub 实现多用户访问 jupyterlab。本篇所有命令均使用 root 用户运行，jupyterhub 版本小于 2.0.0，对于 jupyterhub 2.0.0 的部署方法请参看<a href="https://xujinzh.github.io/2021/12/21/jupyterhub-2-multiuser/">这篇</a>。</p>
<a id="more"></a>

<h1 id="安装-Miniconda"><a href="#安装-Miniconda" class="headerlink" title="安装 Miniconda"></a>安装 Miniconda</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install wget -y</span><br><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line">chmod +x Miniconda*.sh</span><br><span class="line"><span class="comment"># 安装在 /usr/local/miniconda 目录下</span></span><br><span class="line">./Miniconda*.sh</span><br><span class="line">rm -rf Miniconda*.sh</span><br><span class="line"><span class="comment"># 将 miniconda 命令目标添加到系统环境变量中，使得所有用户均可访问</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=/usr/local/miniconda/bin:$PATH&#x27;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="comment"># 创建 miniconda 用户组，使得包含在该组下的用户均可使用 miniconda 里的 python</span></span><br><span class="line">groupadd miniconda</span><br><span class="line">chgrp -R miniconda /usr/<span class="built_in">local</span>/miniconda</span><br><span class="line">chmod 770 -R /usr/<span class="built_in">local</span>/miniconda</span><br><span class="line">usermod -a -G miniconda root</span><br><span class="line">usermod -a -G miniconda jinzhongxu</span><br><span class="line"><span class="comment"># 查看某用户所属组可以使用 </span></span><br><span class="line">id root</span><br><span class="line">id jinzhongxu</span><br><span class="line">groups</span><br><span class="line"><span class="comment"># 安装 jupyterhub, jupyterlab 以及其他常用的包</span></span><br><span class="line">pip install --upgrade pip jupyterhub jupyterlab pandas matplotlib youtube_dl numba boost scipy numpy sympy scikit-learn</span><br><span class="line"><span class="comment"># 安装配置代码格式化工具</span></span><br><span class="line">pip install jupyterlab_code_formatter;jupyter server extension <span class="built_in">enable</span> jupyterlab_code_formatter;pip install black isort</span><br></pre></td></tr></table></figure>

<h1 id="安装-npm-nodejs"><a href="#安装-npm-nodejs" class="headerlink" title="安装 npm, nodejs"></a>安装 npm, nodejs</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum update -y</span><br><span class="line">yum remove nodejs npm -y</span><br><span class="line">yum install epel-release -y</span><br><span class="line">yum install psmisc vim htop zsh git nload curl bzip2 util-linux-user gcc npm -y</span><br><span class="line">curl -sL https://rpm.nodesource.com/setup_14.x | sudo bash -</span><br><span class="line">yum install nodejs -y</span><br></pre></td></tr></table></figure>

<h1 id="配置-jupyterhub"><a href="#配置-jupyterhub" class="headerlink" title="配置 jupyterhub"></a>配置 jupyterhub</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install npm -y</span><br><span class="line">npm install -g configurable-http-proxy</span><br><span class="line">eventlog_dir=`find / -name eventlog.py`</span><br><span class="line">sed -i <span class="string">&quot;s/ruamel.yaml/ruamel_yaml/g&quot;</span> <span class="variable">$&#123;eventlog_dir&#125;</span></span><br><span class="line">jupyterhub --generate-config</span><br><span class="line">mkdir -p /etc/jupyterhub</span><br><span class="line">mv jupyterhub_config.py /etc/jupyterhub/config.py</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c.JupyterHub.base_url = &#x27;/jupyterhub&#x27;&quot;</span> &gt;&gt; /etc/jupyterhub/config.py</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c.JupyterHub.ip = &#x27;0.0.0.0&#x27;&quot;</span> &gt;&gt; /etc/jupyterhub/config.py</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c.Spawner.default_url = &#x27;/lab&#x27;&quot;</span> &gt;&gt; /etc/jupyterhub/config.py</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c.PAMAuthenticator.open_sessions = False&quot;</span> &gt;&gt; /etc/jupyterhub/config.py</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c.LocalAuthenticator.create_system_users = True&quot;</span> &gt;&gt; /etc/jupyterhub/config.py</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;c.Authenticator.admin_users = set([&quot;jinzhongxu&quot;])&#x27;</span> &gt;&gt; /etc/jupyterhub/config.py</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c.JupyterHub.admin_access = True&quot;</span> &gt;&gt; /etc/jupyterhub/config.py</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c.Spawner.cmd = [&#x27;/usr/local/miniconda/bin/jupyterhub-singleuser&#x27;]&quot;</span> &gt;&gt; /etc/jupyterhub/config.py</span><br><span class="line">wget https://www.dropbox.com/s/vak1nsajt7s8muj/jupyterhub.service?dl=0 -O jupyterhub.service</span><br><span class="line">mv jupyterhub.service /etc/systemd/system/jupyterhub.service</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart jupyterhub.service</span><br><span class="line">systemctl <span class="built_in">enable</span> jupyterhub.service</span><br></pre></td></tr></table></figure>

<h1 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 nginx 不再介绍，然后，修改配置文件</span></span><br><span class="line">vim  /etc/nginx/nginx.conf</span><br><span class="line"><span class="comment"># 在</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.vvv.com;</span><br><span class="line">        root /usr/share/nginx/html;</span><br><span class="line">        index index.php index.html index.htm;</span><br><span class="line"><span class="comment"># 下面添加如下内容：</span></span><br><span class="line">location /jupyterhub &#123;</span><br><span class="line">            proxy_pass           http://127.0.0.1:8000;</span><br><span class="line">            proxy_set_header     Host <span class="variable">$host</span>;</span><br><span class="line">            proxy_set_header     X-Real-Scheme <span class="variable">$scheme</span>;</span><br><span class="line">            proxy_set_header     X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            proxy_set_header     X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            proxy_http_version   1.1;</span><br><span class="line">            proxy_set_header     Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">            proxy_set_header     Connection <span class="string">&#x27;upgrade&#x27;</span>;</span><br><span class="line">            proxy_read_timeout   120s;</span><br><span class="line">            proxy_next_upstream  error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面所有都配置好后，访问 <a href="https://www.vvv.com/jupyterhub">https://www.vvv.com/jupyterhub</a> 即可登录。</p>
<p>更多搭建方式（如 docker）可参考 <a href="https://github.com/jupyterhub/jupyterhub">https://github.com/jupyterhub/jupyterhub</a></p>
<h1 id="增加新用户"><a href="#增加新用户" class="headerlink" title="增加新用户"></a>增加新用户</h1><p>在网页上的以用户 jinzhongxu 登录 jupyterhub后，默认进入 jupyterlab，点击 File –&gt; Hub Control Panel 进入 jupyterhub 管理后台，点击 admin 即可管理增加用户，开启服务，关闭服务，关闭 Hub 等。</p>
<p>点击增加用户 username 后，根据上面的配置默认会在系统上创建该用户及家目录。但此时还不能使用过 jupyterlab 服务，需要管理员登录 shell，将新创建的用户增加到 miniconda 组中，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -a -G miniconda username</span><br><span class="line"><span class="comment"># 同时给该用户增加密码</span></span><br><span class="line">passwd username</span><br></pre></td></tr></table></figure>

<p>此时，该用户即可登录 <a href="https://www.vvv.com/jupyterhub">https://www.vvv.com/jupyterhub</a> 了，用户名和密码就是该用户登录 shell 的用户名（username）和密码。</p>
<h1 id="禁止某用户登录"><a href="#禁止某用户登录" class="headerlink" title="禁止某用户登录"></a>禁止某用户登录</h1><p>一种方法是使用命令将该用户的密码删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd -d username</span><br></pre></td></tr></table></figure>

<p>另一种方法是，将该用户从 miniconda 组中剔除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此命令仅从 miniconda 组中删除用户 username，但不会永久地从系统中删除用户</span></span><br><span class="line">deluser username miniconda</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">gpasswd -d username miniconda</span><br></pre></td></tr></table></figure>



<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><p><a href="https://github.com/jupyterhub/jupyterhub">github:jupyterhub</a></p>
</li>
<li><p><a href="https://www.hatarilabs.com/ih-en/how-to-set-a-multiuser-jupyterlab-server-with-jupyterhub-in-windows-with-docker">How to set a multiuser Jupyterlab server with Jupyterhub</a></p>
</li>
<li><p><a href="https://blog.csdn.net/luoluonuoyasuolong/article/details/88526526">jupyterhub 安装教程</a></p>
</li>
<li><p><a href="https://sthsf.github.io/wiki/Linux%20Tricks/JupyterHub%20%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97.html">JupyterHub 部署与应用指南</a></p>
</li>
<li><p><a href="https://gist.github.com/tanbro/a94bfa4a552381f599e7e6b551ccadcf">单机多用户 JupyterLab 环境搭建</a></p>
</li>
<li><p><a href="https://blog.csdn.net/codedancing/article/details/103936542">Linux下多用户Anaconda环境的安装与卸载</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/sheldonxu/archive/2012/05/22/2513036.html">Linux: 删除用户密码/禁止登录</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/57883153">如何在 Ubuntu 上为用户授予和移除 sudo 权限</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>jupyterhub</tag>
        <tag>jupyterlab</tag>
      </tags>
  </entry>
  <entry>
    <title>jupyterlab 扩展</title>
    <url>/2019/12/31/jupyterlab-extension/</url>
    <content><![CDATA[<h1 id="jupyterlab-代码折叠-Collapsible-Headings"><a href="#jupyterlab-代码折叠-Collapsible-Headings" class="headerlink" title="jupyterlab 代码折叠 - Collapsible_Headings"></a>jupyterlab 代码折叠 - <strong><a href="https://github.com/aquirdTurtle/Collapsible_Headings">Collapsible_Headings</a></strong></h1><p>按照 Github 上扩展安装步骤进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter labextension install @aquirdturtle/collapsible_headings</span><br></pre></td></tr></table></figure>

<p>效果如图</p>
<a id="more"></a>

<p><img src="https://raw.githubusercontent.com/aquirdTurtle/Collapsible_Headings/master/Demo2.gif"></p>
<h1 id="jupyterlab-目录-TOC"><a href="#jupyterlab-目录-TOC" class="headerlink" title="jupyterlab 目录 - TOC"></a>jupyterlab 目录 - <a href="https://github.com/jupyterlab/jupyterlab-toc">TOC</a></h1><p>按照 Github 上扩展安装步骤进行安装</p>
<p><font color='dd00dd'>注意：如果 jupyterlab &gt;= 3.0.0，则自带该插件功能，不需再次安装</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter labextension install @jupyterlab/toc</span><br></pre></td></tr></table></figure>

<h1 id="jupyterlab-代码自动补全-Kite"><a href="#jupyterlab-代码自动补全-Kite" class="headerlink" title="jupyterlab 代码自动补全 - Kite"></a>jupyterlab 代码自动补全 - <a href="https://github.com/kiteco/jupyterlab-kite">Kite</a></h1><p>按照 Github 上扩展安装步骤进行安装</p>
<h2 id="安装-Kite-Engine"><a href="#安装-Kite-Engine" class="headerlink" title="安装 Kite Engine"></a>安装 Kite Engine</h2><p><strong>macOS Instructions</strong></p>
<ol>
<li>Download the <a href="https://kite.com/download">installer</a> and open the downloaded <code>.dmg</code> file.</li>
<li>Drag the Kite icon into the <code>Applications</code> folder.</li>
<li>Run <code>Kite.app</code> to start the Kite Engine.</li>
</ol>
<p><strong>Windows Instructions</strong></p>
<ol>
<li>Download the <a href="https://kite.com/download">installer</a> and run the downloaded <code>.exe</code> file.</li>
<li>The installer should run the Kite Engine automatically after installation is complete.</li>
</ol>
<p><strong>Linux Instructions</strong></p>
<ol>
<li><p>Run <code>bash -c &quot;$(wget -q -O - https://linux.kite.com/dls/linux/current)&quot;</code> from the terminal.</p>
</li>
<li><p>The installer should run the Kite Engine automatically after installation is complete.</p>
</li>
</ol>
<h2 id="安装-Kite-Extension-for-JupyterLab"><a href="#安装-Kite-Extension-for-JupyterLab" class="headerlink" title="安装 Kite Extension for JupyterLab"></a>安装 Kite Extension for JupyterLab</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install jupyter-kite</span><br><span class="line">jupyter labextension install <span class="string">&quot;@kiteco/jupyterlab-kite&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后，重启 jupyterlab</p>
<h1 id="Jupyterlab-代码格式化-code-formatter"><a href="#Jupyterlab-代码格式化-code-formatter" class="headerlink" title="Jupyterlab 代码格式化 - code formatter"></a>Jupyterlab 代码格式化 - <a href="https://github.com/ryantam626/jupyterlab_code_formatter/blob/master/docs/installation.rst">code formatter</a></h1><p>按照如下步骤安装</p>
<p><font color='dd00dd'>对于 jupyterlab &lt; 3.0.0, 按照如下方式安装</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter labextension install @ryantam626/jupyterlab_code_formatter</span><br><span class="line">pip install jupyterlab_code_formatter black isort</span><br><span class="line">jupyter serverextension <span class="built_in">enable</span> --py jupyterlab_code_formatter</span><br></pre></td></tr></table></figure>

<p><font color='dd00dd'>对于 jupyterlab &gt;= 3.0.0，按照如下方式安装</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install jupyterlab_code_formatter</span><br><span class="line">jupyter server extension <span class="built_in">enable</span> jupyterlab_code_formatter</span><br><span class="line"><span class="comment"># if you installed the plugin with pip and using --user, you need to add it here as well</span></span><br><span class="line"><span class="comment"># jupyter server extension enable --user jupyterlab_code_formatter</span></span><br><span class="line">pip install black isort</span><br></pre></td></tr></table></figure>

<p>然后，重启 jupyterlab</p>
<h1 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h1><h2 id="无法卸载扩展"><a href="#无法卸载扩展" class="headerlink" title="无法卸载扩展"></a>无法卸载扩展</h2><p>如果使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter labextension list</span><br></pre></td></tr></table></figure>

<p>出现</p>
<p>installed 和 uninstalled 相同的条目，可以移除 build_config.json 来解决。</p>
<h2 id="无法安装扩展"><a href="#无法安装扩展" class="headerlink" title="无法安装扩展"></a>无法安装扩展</h2><p>因为build jupyterlab 扩展时，需要使用 npm 安装一些插件，所以 npm 按照插件成功与否会直接影响 jupyterlab 扩展 build 的成败。下面介绍如何安装 npm 和配置国内源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update </span><br><span class="line">sudo apt install nodejs</span><br><span class="line"><span class="comment"># 配置淘宝源</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line"><span class="comment"># 或者使用工具 nrm 管理源，首先安装 nrm</span></span><br><span class="line">npm install -g nrm</span><br><span class="line"><span class="comment"># 查看可用源</span></span><br><span class="line">nrm ls</span><br><span class="line"><span class="comment"># 切换国内源</span></span><br><span class="line">nrm use taobao</span><br></pre></td></tr></table></figure>

<p>这样，再次使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter lab build</span><br></pre></td></tr></table></figure>

<p>时，就能够 build 成功了。</p>
<p><font color='dd0000'>注意：在 jupyterlab 3.0.0 以后，部分插件安装不需要 nodejs，可以直接使用 pip 安装，如 @ryantam626/jupyterlab_code_formatter </font></p>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://www.runoob.com/w3cnote/npm-switch-repo.html">npm 切换镜像站点</a></p>
<p><a href="https://www.runoob.com/w3cnote/npm-slow-use-cnpm.html">NPM 国内慢的问题解决</a></p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>jupyterlab</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 nginx 反向代理为 jupyterlab 配置二级网址页面</title>
    <url>/2020/11/09/jupyterlab-nginx/</url>
    <content><![CDATA[<p>当服务器配置好 Python, Jupyterlab 后，访问总是通过 8888 端口，出于某些原因，想要为其配置二级页面，这样当想要更改端口时只需要修改一下配置，而不需要再次记忆到底是打开了哪个端口，只需要记住二级页面 web 地址就可以。本篇不介绍如何配置 Jupyterlab，而是假设已经配置好了 Jupyterlab，且申请了域名，直接说如何通过 nginx 配置 Jupyterlab.</p>
<a id="more"></a>

<h1 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nginx</span><br><span class="line">sudo systemctl status nginx.service</span><br><span class="line">sudo systemctl start nginx.service</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> nginx.service</span><br></pre></td></tr></table></figure>

<h1 id="配置-Jupyterlab"><a href="#配置-Jupyterlab" class="headerlink" title="配置 Jupyterlab"></a>配置 Jupyterlab</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成 jupyterlab 配置文件</span></span><br><span class="line">jupyter notebook --generate-config</span><br><span class="line"><span class="comment"># 修改配置</span></span><br><span class="line">vim .jupyter/jupyter_notebook_config.py</span><br><span class="line"><span class="comment"># 修改如下内容</span></span><br><span class="line">c.NotebookApp.base_project_url = <span class="string">&#x27;/jupyter&#x27;</span></span><br><span class="line">c.NotebookApp.ip = <span class="string">&#x27;0.0.0.0&#x27;</span></span><br><span class="line"><span class="comment"># 或者修改如下内容</span></span><br><span class="line">c.NotebookApp.base_url = <span class="string">&#x27;/jupyter&#x27;</span></span><br><span class="line">c.NotebookApp.ip = <span class="string">&#x27;0.0.0.0&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  配置 nginx</span></span><br><span class="line">cat /etc/nginx/nginx.conf</span><br><span class="line"><span class="comment"># 修改如下内容</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.googj.com;</span><br><span class="line">        location /jupyter &#123;</span><br><span class="line">            proxy_pass          http://127.0.0.1:8888;</span><br><span class="line">            proxy_set_header    Host <span class="variable">$host</span>;</span><br><span class="line">            proxy_set_header    X-Real-Scheme <span class="variable">$scheme</span>;</span><br><span class="line">            proxy_set_header    X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            proxy_set_header    X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            proxy_http_version  1.1;</span><br><span class="line">            proxy_set_header    Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">            proxy_set_header    Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">            proxy_read_timeout  120s;</span><br><span class="line">            proxy_next_upstream error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重启服务器后，在网页上访问地址：<a href="http://www.googj.com/jupyter">http://www.googj.com/jupyter</a> (这里是样例地址)，就可以打开 Jupyterlab.</p>
<p>注意，上面假设已经配置了 Jupyterlab 自启，如果没有可以访问我的其他博文配置。并假设域名已经指向服务器IP地址。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><p><a href="https://www.byincd.com/bobjiang/article-0161/">Jupyter Notebook在nginx中无法配置为二级页面的解决办法</a></p>
</li>
<li><p><a href="http://blog.wangcaimeng.top/2020/01/31/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86jupyterlab%E9%85%8D%E7%BD%AE/">nginx反向代理jupyterlab配置</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>linux</tag>
        <tag>nginx</tag>
        <tag>jupyter</tag>
        <tag>jupyterlab</tag>
      </tags>
  </entry>
  <entry>
    <title>JupyterLab 中 Pandas 打印行列省略问题</title>
    <url>/2021/10/20/jupyterlab-pandas-omission/</url>
    <content><![CDATA[<p>在 JupyterLab 中书写 Python 代码非常的方便，交互性强，并且能够书写 Markdown 文档等。但是，使用其处理 Pandas 的 DataFrame 对象时，当表格数据行或列太大时，打印时总是显示不全，在中间出现一些省略号，这使得想要查看所有内容时不是太方便，下面给出一种方法，能够显示所有的行和列。</p>
<a id="more"></a>

<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>在 JupyterLab 的第一个单元格内，添加如下内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有列</span></span><br><span class="line">pd.set_option(<span class="string">&#x27;display.max_columns&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 显示所有行</span></span><br><span class="line">pd.set_option(<span class="string">&#x27;display.max_rows&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 设置 value 的显示长度为 100，默认为 50</span></span><br><span class="line">pd.set_option(<span class="string">&#x27;max_colwidth&#x27;</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>在 JupyterLab 中使用如下命令，可以查看所有可自定义参数</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">pd.set_option?</span><br></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://blog.csdn.net/weekdawn/article/details/81389865">pandas中关于DataFrame行，列显示不完全（省略）的解决办法</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>jupyter</tag>
        <tag>jupyterlab</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>jupyterlab安装plotly</title>
    <url>/2020/06/22/jupyterlab-plotly/</url>
    <content><![CDATA[<p>Plotly是一家技术计算公司，总部位于魁北克省的蒙特利尔市，致力于开发在线数据分析和可视化工具。Plotly为个人和协作提供了在线图形，分析和统计工具，以及用于Python，R，MATLAB，Perl，Julia，Arduino和REST的科学图形库。本篇介绍的就是其 Python 画图库plotly，常常在jupyterlab使用plotly进行离线画图时总是出现图形不显示的问题。因为plotly画出的图形比matplotlib更加好看且有交互性，同时，matplotlib画的图形也可以使用plotly转化为同态交互图。所以，希望能够使用plotly画图，并能够在常用软件jupyterlab中使用。</p>
<a id="more"></a>

<h1 id="安装plotly"><a href="#安装plotly" class="headerlink" title="安装plotly"></a>安装plotly</h1><p>推荐使用pip安装最新的plotly，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install plotly</span><br></pre></td></tr></table></figure>

<h1 id="jupyterlab使用plotly"><a href="#jupyterlab使用plotly" class="headerlink" title="jupyterlab使用plotly"></a>jupyterlab使用plotly</h1><p>在jupyterlab中使用plotly需要安装一些支持扩展，其中 jupyterlab-plotly@ 需要根据最新的plotly版本对应，参考网址<a href="https://plotly.com/python/getting-started/?utm_source=mailchimp-jan-2015&utm_medium=email&utm_campaign=generalemail-jan2015&utm_term=bubble-chart">Python\Getting Started with Plotly</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install ipywidgets</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install nodejs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> JupyterLab renderer support</span></span><br><span class="line">jupyter labextension install jupyterlab-plotly@4.8.1</span><br></pre></td></tr></table></figure>

<p>在  <a href="mailto:&#x6a;&#x75;&#x70;&#x79;&#x74;&#101;&#114;&#108;&#97;&#x62;&#x2d;&#112;&#108;&#111;&#116;&#108;&#x79;&#64;&#52;&#x2e;&#x38;&#46;&#49;">&#x6a;&#x75;&#x70;&#x79;&#x74;&#101;&#114;&#108;&#97;&#x62;&#x2d;&#112;&#108;&#111;&#116;&#108;&#x79;&#64;&#52;&#x2e;&#x38;&#46;&#49;</a>中，需要编译一会，可能会消耗2G多内存，建议内存小的用户创建交换分区。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看安装的jupyterlab扩展</span></span><br><span class="line">jupyter labextension list</span><br></pre></td></tr></table></figure>

<h1 id="使用plotly画图"><a href="#使用plotly画图" class="headerlink" title="使用plotly画图"></a>使用plotly画图</h1><p>按照上面方法按照后，需要先 log out jupyterlab，然后，在登录进去使用plotly才能正常显示图形。</p>
<p>更多jupyterlab使用plotly画图，请参考<a href="https://plotly.com/python/getting-started/">官网</a></p>
<h1 id="无法安装扩展解决办法"><a href="#无法安装扩展解决办法" class="headerlink" title="无法安装扩展解决办法"></a>无法安装扩展解决办法</h1><p>因为 build jupyterlab 扩展时，需要使用 npm 安装一些插件，所以 npm 按照插件成功与否会直接影响 jupyterlab 扩展 build 的成败。下面介绍如何安装 npm 和配置国内源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update </span><br><span class="line">sudo apt install nodejs</span><br><span class="line"><span class="comment"># 配置淘宝源</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line"><span class="comment"># 或者使用工具 nrm 管理源，首先安装 nrm</span></span><br><span class="line">npm install -g nrm</span><br><span class="line"><span class="comment"># 查看可用源</span></span><br><span class="line">nrm ls</span><br><span class="line"><span class="comment"># 切换国内源</span></span><br><span class="line">nrm use taobao</span><br></pre></td></tr></table></figure>

<p>这样，再次使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter lab build</span><br></pre></td></tr></table></figure>

<p>时，就能够 build 成功了。</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>jupyterlab</tag>
        <tag>plotly</tag>
      </tags>
  </entry>
  <entry>
    <title>Python jupyter lab 开机自启动</title>
    <url>/2019/12/20/jupyterlab-startup/</url>
    <content><![CDATA[<h2 id="generate-config"><a href="#generate-config" class="headerlink" title="generate config"></a>generate config</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c.NotebookApp.ip = &#x27;0.0.0.0&#x27;&quot;</span> &gt;&gt; ~/.jupyter/jupyter_notebook_config.py</span><br></pre></td></tr></table></figure>

<h2 id="activate-service-开机自启"><a href="#activate-service-开机自启" class="headerlink" title="activate service 开机自启"></a>activate service 开机自启</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/jupyter.service</span><br></pre></td></tr></table></figure>
<p>添加如下代码，并保存</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Jupyter Notebook</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/home/jinzhongxu/miniconda3/bin/jupyter-lab --config=/home/jinzhongxu/.jupyter/jupyter_notebook_config.py --no-browser</span><br><span class="line">User=jinzhongxu</span><br><span class="line">Group=jinzhongxu</span><br><span class="line">WorkingDirectory=/home/jinzhongxu/</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<h2 id="enable-jupyter"><a href="#enable-jupyter" class="headerlink" title="enable jupyter"></a>enable jupyter</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> jupyter</span><br><span class="line">systemctl start jupyter</span><br></pre></td></tr></table></figure>

<p>其他程序或服务，也可以使用上面的方法，需要注意两点：</p>
<ol>
<li>系统版本不能太低，如 Ubuntu 14.04等，因为该系统没有 systemd</li>
<li>jupyter.service 中的 ExecStart 后面的命令不能使用 ~jinzhongxu，必须使用绝对路径</li>
</ol>
<p>一个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/frpc.service</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=frpc daemon</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/home/jinzhongxu/.frp.local/frpc -c /home/jinzhongxu/.frp.local/frpc.ini</span><br><span class="line"><span class="meta">#</span><span class="bash">ExecStart=/home/jinzhongxu/.frp.local/frp <span class="comment"># 这种方法不可行，其中 frp 即 frp.sh，里面就是</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nohup /home/jinzhongxu/.frp.local/frpc -c /home/jinzhongxu/.frp.local/frpc.ini &gt; <span class="built_in">log</span> &amp;</span></span><br><span class="line">User=jinzhongxu</span><br><span class="line">Group=jinzhongxu</span><br><span class="line">WorkingDirectory=/home/jinzhongxu/.frp.local/</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start frpc.service</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> frpc.service</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>ubuntu</tag>
        <tag>jupyterlab</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka集群部署</title>
    <url>/2020/03/03/kafka-cluster-deployment/</url>
    <content><![CDATA[<p>Kafka最初是由领英(LinkedIn)开发，并随后于2011年初开源，并于2012年10月23日由Apache Incubator孵化出站。它是为处理实时数据提供一个统一、高吞吐、低延迟的<a href="http://baike.baidu.com/view/402382.htm">分布式</a>发布订阅消息系统。Kafka由Java和Scala编写。根据2014年Quora的帖子，Jay Kreps似乎已经将它以作家<a href="https://zh.wikipedia.org/wiki/%E5%BC%97%E6%9C%97%E8%8C%A8%C2%B7%E5%8D%A1%E5%A4%AB%E5%8D%A1">弗朗茨·卡夫卡</a>命名。Kreps选择将该系统以一个作家命名是因为，它是“一个用于优化写作的系统”，而且他很喜欢卡夫卡的作品。Kafka架构的主要术语包括Topic、Record和Broker。Topic由Record组成，Record持有不同的信息，而Broker则负责复制消息。Kafka有四个主要API：</p>
<a id="more"></a>

<ul>
<li><strong>生产者API</strong>：支持应用程序发布Record流。</li>
<li><strong>消费者API</strong>：支持应用程序订阅Topic和处理Record流。</li>
<li><strong>Stream API</strong>：将输入流转换为输出流，并产生结果。</li>
<li><strong>Connector API</strong>：执行可重用的生产者和消费者API，可将Topic链接到现有应用程序。</li>
</ul>
<p>下面进行Kafka集群部署工作。这里以3台服务器为例，假设IP分别是1.1.1.0， 1.1.1.1， 1.1.1.2，默认在1.1.1.0上演示。这里假设Java和Zookeeper已经部署成功，如果没有部署可以参考我之前的文章。</p>
<h1 id="下载Kafka"><a href="#下载Kafka" class="headerlink" title="下载Kafka"></a>下载Kafka</h1><p>从官网下载<a href="https://kafka.apache.org/downloads">Kafka</a> ，这里下载2.4.0版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.ocf.berkeley.edu/apache/kafka/2.4.0/kafka_2.11-2.4.0.tgz</span><br></pre></td></tr></table></figure>

<h1 id="安装Kafka"><a href="#安装Kafka" class="headerlink" title="安装Kafka"></a>安装Kafka</h1><p>安装Kafka非常简单，直接解压即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzf kafka_2.11-2.4.0.tgz</span><br></pre></td></tr></table></figure>

<p>也可以指定解压目录，如Documents</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzf kafka_2.11-2.4.0.tgz -C ./Documents/.</span><br></pre></td></tr></table></figure>

<h1 id="配置Kafka"><a href="#配置Kafka" class="headerlink" title="配置Kafka"></a>配置Kafka</h1><p>进入Kafka安装目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> kafka_2.11-2.4.0/</span><br></pre></td></tr></table></figure>

<p>创建日志文件夹，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir <span class="built_in">log</span></span><br><span class="line">vim config/server.properties</span><br></pre></td></tr></table></figure>

<p>修改如下信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">broker.id=0</span><br><span class="line">log.dirs=/home/jinzhongxu/kafka_2.11-2.4.0/<span class="built_in">log</span></span><br><span class="line">zookeeper.connect=1.1.1.0:2181, 1.1.1.1:2181, 1.1.1.2:2181</span><br></pre></td></tr></table></figure>

<p>把文件夹kafka_2.11-2.4.0/ 拷贝到另外两台服务器上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r kafka_2.11-2.4.0/ 1.1.1.1:/home/jinzhongxu/.</span><br><span class="line">scp -r kafka_2.11-2.4.0/ 1.1.1.2:/home/jinzhongxu/.</span><br></pre></td></tr></table></figure>

<p>并分别修改（ <code>broker.id</code> 属性是集群中服务器的永久的固定的名字）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">broker.id=1</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">broker.id=2</span><br></pre></td></tr></table></figure>

<h1 id="启动Kafka"><a href="#启动Kafka" class="headerlink" title="启动Kafka"></a>启动Kafka</h1><p>进入Kafka安装目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;kafka-server-start.sh config&#x2F;server.properties</span><br></pre></td></tr></table></figure>

<p>运行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure>

<p>查看Kafka是否启动成功。并在其他服务器上也分别启动Kafka。</p>
<h1 id="测试Kafka"><a href="#测试Kafka" class="headerlink" title="测试Kafka"></a>测试Kafka</h1><h2 id="创建topic"><a href="#创建topic" class="headerlink" title="创建topic"></a>创建topic</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h2 id="查看topic"><a href="#查看topic" class="headerlink" title="查看topic"></a>查看topic</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>

<h2 id="创建producer"><a href="#创建producer" class="headerlink" title="创建producer"></a>创建producer</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list localhost:909-topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h2 id="创建consumer"><a href="#创建consumer" class="headerlink" title="创建consumer"></a>创建consumer</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --from-beginning</span><br></pre></td></tr></table></figure>

<h1 id="删除Topic"><a href="#删除Topic" class="headerlink" title="删除Topic"></a>删除Topic</h1><p>首先，在config/server.properties中增加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">delete.topic.enable=true</span><br></pre></td></tr></table></figure>

<p>否则，并不能立刻删除该topic，而是标记为待删除(marked for deletion)，当重启Kafka时才会删除。</p>
<p>然后，查看该Kafka集群有哪些topic</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/kafka-topics.sh  --list --zookeeper localhost:2181 </span><br></pre></td></tr></table></figure>

<p>最后，使用命令删除topic</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/kafka-topics.sh  --delete --zookeeper localhost:2181 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>再次查看Kafka的topic发现已经没有了。</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>big data</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>JupyterLab 中单元格同时能够输出多行的方法</title>
    <url>/2021/10/20/jupyterlab-cell-multi-print/</url>
    <content><![CDATA[<p>在 JupyterLab 中书写 Python 代码非常的方便，交互性强，并且能够书写 Markdown 文档等。但是，使用其进行多行打印输出时，要么使用 print 函数，要么把需要输出的参数都写在最后一行，这大大降低了其交互性。下面给出一种解决方法。</p>
<a id="more"></a>

<h1 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案 1"></a>解决方案 1</h1><p>每次在 JupyterLab 的第一行添加如下代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line"></span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">&quot;all&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="解决方案2"><a href="#解决方案2" class="headerlink" title="解决方案2"></a>解决方案2</h1><p>在配置文件中修改，这样不用每次在 JupyterLab 首行都添加代码</p>
<ol>
<li><p>终端输入如下命令，创建 ipython_config.py 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.ipython/profile_default/ipython_config.py</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>在文件中写入如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">c = get_config()</span><br><span class="line">c.InteractiveShell.ast_node_interactivity = <span class="string">&quot;all&quot;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>使其生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.ipython/profile_default/ipython_config.py</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://blog.csdn.net/enter89/article/details/90633718">Jupyter cell同时输出多行</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>jupyter</tag>
        <tag>jupyterlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka 监控软件 Kafka-Eagle 安装教程</title>
    <url>/2020/07/17/kafka-eagle-install/</url>
    <content><![CDATA[<p>Kafka-Eagle 是一款国产Kafka监控软件，总体上还是挺不错的。这里介绍如何安装它。</p>
<h2 id="下载-Kafka-Eagle"><a href="#下载-Kafka-Eagle" class="headerlink" title="下载 Kafka-Eagle"></a>下载 Kafka-Eagle</h2><p>从官网下载，地址为：<a href="http://download.kafka-eagle.org/">http://download.kafka-eagle.org/</a></p>
<p>选择 Direct File Download</p>
<a id="more"></a>

<h2 id="安装-Kafka-Eagle"><a href="#安装-Kafka-Eagle" class="headerlink" title="安装 Kafka-Eagle"></a>安装 Kafka-Eagle</h2><p>可以参考官网教程进行安装，教程地址，<a href="https://www.kafka-eagle.org/articles/docs/documentation.html%EF%BC%8C%E9%80%89%E6%8B%A9%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B%E3%80%82">https://www.kafka-eagle.org/articles/docs/documentation.html，选择对应的系统类型。</a></p>
<p>这里给出自己安装的步骤以及需要注意的点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xzf kafka-eagle-bin-2.0.0.tar.gz</span><br><span class="line">cd kafka-eagle-bin-2.0.0</span><br><span class="line">tar -xzf kafka-eagle-web-2.0.0-bin.tar.gz</span><br><span class="line">mv kafka-eagle-web-2.0.0 ../kafka-eagle-web</span><br></pre></td></tr></table></figure>

<p>这里很奇怪，为什么解压后还要有一个压缩，搞不懂！</p>
<p>记录下，kafka-eagle-web的目录，我这里是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/jinzhongxu/kafka-eagle-web/</span><br></pre></td></tr></table></figure>

<p>配置 kafka-eagle 环境，类似于官网</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br><span class="line">export JAVA_HOME=/home/jinzhongxu/jdk-11.0.7</span><br><span class="line">export KE_HOME=/home/jinzhongxu/kafka-eagle-web</span><br><span class="line">export PATH=$PATH:$KE_HOME/bin:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure>

<p>使之生效方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">. /etc/profile</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<p>修改配置</p>
<p><strong>这里注意，1.5版本后，不在提供ke.sql。默认/home/jinzhongxu/kafka-eagle-web/db/ 是空文件夹，运行后，里面会自动出现ke.db</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim kafka-eagle-web/conf/system-config.properties</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 改成自己的zookeeper节点</span></span><br><span class="line">kafka.eagle.zk.cluster.alias=cluster</span><br><span class="line">cluster.zk.list=box0:2181,box1:2181:box2:2181</span><br><span class="line"><span class="meta">#</span><span class="bash">cluster1.zk.list=tdn1:2181,tdn2:2181,tdn3:2181</span></span><br><span class="line"><span class="meta">#</span><span class="bash">cluster2.zk.list=xdn10:2181,xdn11:2181,xdn12:2181</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 改成自己的 kafka.eagle.url</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kafka sqlite jdbc driver address</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line">kafka.eagle.driver=org.sqlite.JDBC</span><br><span class="line">kafka.eagle.url=jdbc:sqlite:/home/jinzhongxu/kafka-eagle-web/db/ke.db</span><br><span class="line">kafka.eagle.username=root</span><br><span class="line">kafka.eagle.password=www.kafka-eagle.org</span><br></pre></td></tr></table></figure>

<h2 id="运行-Kafka-Eagle"><a href="#运行-Kafka-Eagle" class="headerlink" title="运行 Kafka-Eagle"></a>运行 Kafka-Eagle</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./ke.sh start</span><br></pre></td></tr></table></figure>

<p>这是会提示打开地址：<a href="http://127.0.1.1:8048/">http://127.0.1.1:8048</a>    </p>
<p>（当然，也可以直接输入你的hostname，我这里是box0），输入用户名：admin，输入密码：123456</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行zookeeper/kafka来查看监控数据</span></span><br><span class="line"></span><br><span class="line">zookeeper-3.5.8/bin/zkServer.sh start</span><br><span class="line">nohup kafka_2.11-2.4.1/bin/kafka-server-start.sh kafka_2.11-2.4.1/config/server.properties &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<h1 id="kafka-监控显示问题"><a href="#kafka-监控显示问题" class="headerlink" title="kafka 监控显示问题"></a>kafka 监控显示问题</h1><p>搭建完后，总是不能显示监控的 kafka 数据，只能显示部分数据，这很可能是因为 kafka jmx 配置问题，解决方法如下：</p>
<ol>
<li><p>首先保证 kafka eagle 的配置文件 system-config.properties 中的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kafka.eagle.metrics.charts=<span class="literal">true</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>打开 kafka broker 的 jmx 端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim kafka-server-start.sh</span><br><span class="line"><span class="comment"># 配置 JMX 端口，可随意指定</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;x<span class="variable">$KAFKA_HEAP_OPTS</span>&quot;</span> = <span class="string">&quot;x&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> KAFKA_HEAP_OPTS=<span class="string">&quot;-server -Xms2G -Xmx2G -XX:PermSize=128m -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:ParallelGCThreads=8 -XX:ConcGCThreads=5 -XX:InitiatingHeapOccupancyPercent=70&quot;</span></span><br><span class="line">    <span class="built_in">export</span> JMX_PORT=<span class="string">&quot;9999&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 配置 RMI </span></span><br><span class="line"><span class="built_in">exec</span> <span class="variable">$base_dir</span>/kafka-run-class.sh <span class="variable">$EXTRA_ARGS</span> -Djava.rmi.server.hostname=该kafka broker的ip   kafka.kafka <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>重启 kafka 和 kafka eagle</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启 kafka</span></span><br><span class="line">./kafka-server-start.sh ../config/server.properties</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 kafka eagle</span></span><br><span class="line">./ke.sh restart</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.kafka-eagle.org/articles/docs/quickstart/metrics.html">kafka jmx</a></p>
<p><a href="https://www.kafka-eagle.org/articles/docs/architecture/collect.html">kafka jmx telnet</a></p>
<p><a href="https://www.kafka-eagle.org/articles/docs/installation/linux-macos.html">kafka eagle Install on Linux/macOS</a></p>
<p><a href="https://blog.csdn.net/yezonggang/article/details/97749786">kafka实践三：监控利器kafka-eagle</a></p>
<p><a href="https://blog.csdn.net/caidongxuan/article/details/105247609">关于JMX三个端口的说明</a></p>
<p><a href="https://blog.csdn.net/wk_dream/article/details/108086266">kafka-eagle 使用配置及远程jmx端口设置遇到的问题</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>kafka</tag>
        <tag>kafka-eagle</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX中文模版代码</title>
    <url>/2019/12/21/latex-chinese/</url>
    <content><![CDATA[<p>LaTeX - 中文（模板）</p>
<p>有些初使用LaTeX进行中文写作的作者，总是会遇到不能正确利用LaTeX编译中文文档的问题，这里总结出一个模板，来帮助这些作者方便进行LaTeX中文写作，具体步骤如下：</p>
<ol>
<li>添加如下代码</li>
<li>XeLaTeX编译执行</li>
</ol>
<p>（注意：生成目录需要编译两次）</p>
<p>具体LaTeX代码如下：</p>
<a id="more"></a>

<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;geometry&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">geometry</span><span class="string">&#123;a4paper&#125;</span></span></span><br><span class="line"><span class="comment">%\usepackage[UTF8, heading = false, scheme = plain]&#123;ctex&#125;%格式</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;ctex&#125;</span></span></span><br><span class="line"><span class="comment">%\usepackage&#123;authblk&#125; %添加机构，需要安装preprint包</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;graphicx&#125;</span></span> <span class="comment">%添加图片</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsthm&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">renewcommand</span><span class="string">&#123;\vec&#125;</span><span class="string">[1]</span><span class="string">&#123;\boldsymbol&#123;#1&#125;</span></span>&#125; <span class="comment">% 生产粗体向量，而不是带箭头的向量</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amssymb&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;booktabs&#125;</span></span> <span class="comment">% excel导出的大表格%</span></span><br><span class="line"><span class="tag">\<span class="name">newtheorem</span><span class="string">&#123;definition&#125;</span><span class="string">&#123;Definition&#125;</span></span> <span class="comment">%英文</span></span><br><span class="line"><span class="comment">%\newtheorem&#123;theorem&#125;&#123;Theorem&#125;</span></span><br><span class="line"><span class="tag">\<span class="name">newtheorem</span><span class="string">&#123;definition&#125;</span><span class="string">&#123;定义&#125;</span></span> <span class="comment">%中文</span></span><br><span class="line"><span class="tag">\<span class="name">newtheorem</span><span class="string">&#123;lemma&#125;</span><span class="string">&#123;引理&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">newtheorem</span><span class="string">&#123;theorem&#125;</span><span class="string">&#123;定理&#125;</span></span></span><br><span class="line"><span class="comment">%\newenvironment&#123;proof&#125;&#123;&#123;\noindent\it 证明&#125;\quad&#125;&#123;\hfill $\square$\par&#125;</span></span><br><span class="line"><span class="tag">\<span class="name">DeclareMathOperator</span><span class="string">&#123;\Ima&#125;</span><span class="string">&#123;Im&#125;</span></span><span class="comment">%定义新符号</span></span><br><span class="line"><span class="tag">\<span class="name">DeclareMathOperator</span><span class="string">&#123;\Rank&#125;</span><span class="string">&#123;rank&#125;</span></span><span class="comment">%定义求秩算子</span></span><br><span class="line"><span class="tag">\<span class="name">title</span><span class="string">&#123;数学-计算机视觉&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">author</span><span class="string">&#123;Jayzon Xu&#125;</span></span></span><br><span class="line"><span class="comment">%\affil&#123;MIT&#125;</span></span><br><span class="line"><span class="comment">%date&#123;2019年11月8日&#125; %注释后显示为编译时日期</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">maketitle</span></span></span><br><span class="line"><span class="tag">\<span class="name">tableofcontents</span></span></span><br><span class="line"><span class="tag">\<span class="name">newpage</span></span></span><br><span class="line"><span class="comment">% 生成目录，请删除上面两行注释</span></span><br><span class="line"><span class="comment">%\listoffigures</span></span><br><span class="line"><span class="comment">%\newpage</span></span><br><span class="line"><span class="comment">% 生成图片列表，请删除上面两行注释</span></span><br><span class="line"><span class="tag">\<span class="name">section</span><span class="string">&#123;数学&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">subsection</span><span class="string">&#123;高等代数与最优化理论&#125;</span></span></span><br><span class="line"><span class="comment">%\begin&#123;figure&#125;[ht] %htbp</span></span><br><span class="line"><span class="comment">%\centering</span></span><br><span class="line"><span class="comment">%\includegraphics[scale=0.6]&#123;gradient.png&#125;</span></span><br><span class="line"><span class="comment">%\caption&#123;this is a figure demo&#125;</span></span><br><span class="line"><span class="comment">%\label&#123;fig:label&#125;</span></span><br><span class="line"><span class="comment">%\end&#123;figure&#125;</span></span><br><span class="line">A =</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;pmatrix&#125;</span></span></span><br><span class="line">    1 &amp; 2 &amp; 3 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">    2 &amp; 3 &amp; 1 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">    3 &amp; 1 &amp; 2</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;pmatrix&#125;</span></span></span><br><span class="line"><span class="formula">$<span class="tag">\<span class="name">rho</span></span>(A) = 6$</span>.</span><br><span class="line"><span class="tag">\<span class="name">subsection</span><span class="string">&#123;数学分析&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;equation&#125;</span></span><span class="tag">\<span class="name">label</span><span class="string">&#123;equ:sin&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">sin</span></span>(z) = 2</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">其中，<span class="formula">$z<span class="tag">\<span class="name">in</span></span> <span class="tag">\<span class="name">mathbb</span><span class="string">&#123;C&#125;</span></span>$</span>.</span><br><span class="line">您能求解方程(<span class="tag">\<span class="name">ref</span><span class="string">&#123;equ:sin&#125;</span></span>)吗？</span><br><span class="line"><span class="tag">\<span class="name">section</span><span class="string">&#123;计算机视觉&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">subsection</span><span class="string">[Panoptic Segmentation]</span><span class="string">&#123;全景分割&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">subsubsection</span><span class="string">&#123;语义分割&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">subsubsection</span><span class="string">&#123;实例分割&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span>&lt;/code&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>

<p>建议使用<a href="https://miktex.org/download">MikTex</a> + <a href="http://texstudio.sourceforge.net/">TeXstudio</a>作为编译器。</p>]]></content>
      <categories>
        <category>maths</category>
      </categories>
      <tags>
        <tag>latex</tag>
        <tag>template</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyterlab Code Formatter 的快捷键 Keyboard Shortcuts 设置</title>
    <url>/2021/11/11/jupyterlab-code-formatter-keyboard-shortcuts/</url>
    <content><![CDATA[<p>Jupyterlab Code Formatter 能够在 notebook 中对代码进行格式化，安装成功后，只需要点击代码格式化按钮。那么如何像在 pycharm 中一样使用快捷键对代码进行格式化呢，本篇记录一下。</p>
<a id="more"></a>

<h1 id="安装格式化包"><a href="#安装格式化包" class="headerlink" title="安装格式化包"></a>安装格式化包</h1><ol>
<li><p>安装插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install jupyterlab_code_formatter</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装格式化支持</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install black isort</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li>重启 Jupyterlab</li>
</ol>
<h1 id="设置快捷键"><a href="#设置快捷键" class="headerlink" title="设置快捷键"></a>设置快捷键</h1><p>打开 Jupyterlab，点击 settings -&gt; Advanced Settings Editor -&gt; Keyboard Shortcuts</p>
<p>在 User Preferences 中输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;shortcuts&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;command&quot;</span>: <span class="string">&quot;jupyterlab_code_formatter:black&quot;</span>,</span><br><span class="line">        <span class="string">&quot;keys&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;Ctrl Alt L&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;selector&quot;</span>: <span class="string">&quot;.jp-Notebook.jp-mod-editMode&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>我这里设置的快捷键是 <code>Ctrl Alt L</code></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://jupyterlab-code-formatter.readthedocs.io/en/latest/installation.html#installation-step-1-installing-the-plugin-itself">jupyterlab-code-formatter Prerequisites and Installation Steps</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 定时任务 crontab</title>
    <url>/2021/03/19/linux-crontab/</url>
    <content><![CDATA[<p>在 Linux 上执行定时任务具有便利性，可以使用命令 crontab 来实现。如因为服务器资源紧张需要错峰使用，想要在晚上才进行具有较大运行压力的任务，或者对于执行任务有具体时间要求。本篇以 Ubuntu 20.04 为例进行介绍，同样适用于 Debian/MacOS/CentOS/Red Hat  等系统。</p>
<a id="more"></a>

<h1 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h1><p>可以使用如下命令查看 crontab</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ cat /etc/crontab</span><br><span class="line"><span class="comment"># /etc/crontab: system-wide crontab</span></span><br><span class="line"><span class="comment"># Unlike any other crontab you don&#x27;t have to run the `crontab&#x27;</span></span><br><span class="line"><span class="comment"># command to install the new version when you edit this file</span></span><br><span class="line"><span class="comment"># and files in /etc/cron.d. These files also have username fields,</span></span><br><span class="line"><span class="comment"># that none of the other crontabs do.</span></span><br><span class="line"></span><br><span class="line">SHELL=/bin/sh</span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name command to be executed</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每小时的第17分钟执行命令： cd / &amp;&amp; run-parts --report /etc/cron.hourly</span></span><br><span class="line">17 *    * * *   root    <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.hourly</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每天6点25分执行命令： test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.daily )</span></span><br><span class="line">25 6    * * *   root    <span class="built_in">test</span> -x /usr/sbin/anacron || ( <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.daily )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每周日的6点47分执行命令： test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.weekly )</span></span><br><span class="line">47 6    * * 7   root    <span class="built_in">test</span> -x /usr/sbin/anacron || ( <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.weekly )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个月1号6点52分执行命令：test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.monthly )</span></span><br><span class="line">52 6    1 * *   root    <span class="built_in">test</span> -x /usr/sbin/anacron || ( <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.monthly )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一分钟执行一次命令</span></span><br><span class="line">* *  * * *   root    <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.hourly</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每3分钟执行一次命令</span></span><br><span class="line">*/3  *  * * *   root    <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.hourly</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每天1点第1，3分钟执行一次命令</span></span><br><span class="line">1,3  1  * * *   root    <span class="built_in">cd</span> / &amp;&amp; run-parts --report /etc/cron.hourly</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建一个定时任务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"><span class="comment"># 所有任务在 /var/spool/cron 中</span></span><br></pre></td></tr></table></figure>

<p>在以下添加按照上面规则定义任务命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Edit this file to introduce tasks to be run by cron.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Each task to run has to be defined through a single line</span></span><br><span class="line"><span class="comment"># indicating with different fields when the task will be run</span></span><br><span class="line"><span class="comment"># and what command to run for the task</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># To define the time you can provide concrete values for</span></span><br><span class="line"><span class="comment"># minute (m), hour (h), day of month (dom), month (mon),</span></span><br><span class="line"><span class="comment"># and day of week (dow) or use &#x27;*&#x27; in these fields (for &#x27;any&#x27;).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Notice that tasks will be started based on the cron&#x27;s system</span></span><br><span class="line"><span class="comment"># daemon&#x27;s notion of time and timezones.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Output of the crontab jobs (including errors) is sent through</span></span><br><span class="line"><span class="comment"># email to the user the crontab file belongs to (unless redirected).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For example, you can run a backup of all your user accounts</span></span><br><span class="line"><span class="comment"># at 5 a.m every week with:</span></span><br><span class="line"><span class="comment"># 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information see the manual pages of crontab(5) and cron(8)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># m h  dom mon dow   command</span></span><br><span class="line">1 1 1 * * shutdown -r now <span class="comment"># 每月1号1点1分重启系统</span></span><br></pre></td></tr></table></figure>

<p>查看定时任务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure>

<p>删除定时任务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -r</span><br></pre></td></tr></table></figure>

<h1 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h1><p>cron 是 crontab 命令的守护进程，在后台运行，负责每分钟监测是否有预定的任务需要执行。</p>
<p>查看 cron 守护进程是否运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ systemctl status cron.service</span><br><span class="line">● cron.service - Regular background program processing daemon</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/cron.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Wed 2021-03-17 17:10:58 CST; 1 day 19h ago</span><br><span class="line">       Docs: man:cron(8)</span><br><span class="line">   Main PID: 417 (cron)</span><br><span class="line">      Tasks: 1 (<span class="built_in">limit</span>: 1160)</span><br><span class="line">     Memory: 6.8M</span><br><span class="line">     CGroup: /system.slice/cron.service</span><br><span class="line">             └─417 /usr/sbin/cron -f</span><br><span class="line"></span><br><span class="line">Warning: some journal files were not opened due to insufficient permissions.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>开启 cron 守护进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ systemctl start cron.service</span><br></pre></td></tr></table></figure>

<p>关闭 cron 守护进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ systemctl stop cron.service</span><br></pre></td></tr></table></figure>

<p>重启 cron 守护进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ systemctl restart cron.service</span><br></pre></td></tr></table></figure>

<p>设置开机启动 cron 守护进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ systemctl <span class="built_in">enable</span> cron.service</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><p><a href="https://blog.csdn.net/qq_41755706/article/details/112801266">crontab</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/xiaoluo501395377/archive/2013/04/06/3002602.html">Linux学习之CentOS(十二)–crontab命令的使用方法</a></p>
</li>
<li><p><a href="https://blog.csdn.net/ithomer/article/details/6817019">linux定时运行命令脚本——crontab</a></p>
</li>
<li><p><a href="https://www.runoob.com/w3cnote/linux-crontab-tasks.html">Linux Crontab 定时任务</a></p>
</li>
<li><p><a href="https://blog.csdn.net/whatday/article/details/106834657">linux 定时器 crontab 实例 计划任务 定时任务</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>linux</tag>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX 数学符号</title>
    <url>/2020/04/16/latex-maths-character/</url>
    <content><![CDATA[<h1 id="LaTeX-数学符号"><a href="#LaTeX-数学符号" class="headerlink" title="LaTeX 数学符号"></a>LaTeX 数学符号</h1><h2 id="常用基本LaTeX书写"><a href="#常用基本LaTeX书写" class="headerlink" title="常用基本LaTeX书写"></a>常用基本LaTeX书写</h2><a id="more"></a>

<h3 id="幂和下脚标"><a href="#幂和下脚标" class="headerlink" title="幂和下脚标"></a>幂和下脚标</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$x_1$</span> <span class="tag">\<span class="name">quad</span></span> <span class="formula">$x^2$</span> <span class="tag">\<span class="name">quad</span></span> <span class="formula">$e^&#123;-<span class="tag">\<span class="name">alpha</span></span> x&#125;$</span> <span class="tag">\<span class="name">quad</span></span> <span class="formula">$x^3_&#123;ij&#125;$</span> <span class="tag">\<span class="name">quad</span></span> <span class="formula">$e^&#123;x^3&#125;$</span> <span class="tag">\<span class="name">neq</span></span> <span class="formula">$e^&#123;3x&#125;$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>x_1 \quad x^2 \quad e^{-\alpha x} \quad x^3_{ij} \quad e^{x^3} \neq e^{3x}<br>$$</p>
<h3 id="开方"><a href="#开方" class="headerlink" title="开方"></a>开方</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">sqrt</span><span class="string">&#123;x&#125;</span></span>$</span> <span class="tag">\<span class="name">quad</span></span> <span class="formula">$<span class="tag">\<span class="name">sqrt</span><span class="string">&#123;x^2 + y^2&#125;</span></span>$</span> <span class="tag">\<span class="name">qquad</span></span> <span class="formula">$<span class="tag">\<span class="name">sqrt</span><span class="string">[3]</span><span class="string">&#123;x&#125;</span></span>$</span> <span class="tag">\<span class="name">quad</span></span> <span class="formula">$<span class="tag">\<span class="name">surd</span><span class="string">[x^3 + y^3]</span></span>$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>\sqrt{x} \quad \sqrt{x^2 + y^2} \qquad \sqrt[3]{x} \quad \surd[x^3 + y^3]<br>$$</p>
<h3 id="上下水平线"><a href="#上下水平线" class="headerlink" title="上下水平线"></a>上下水平线</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">overline</span><span class="string">&#123;x + y&#125;</span></span>$</span> <span class="tag">\<span class="name">qquad</span></span> <span class="formula">$<span class="tag">\<span class="name">underline</span><span class="string">&#123;x - y&#125;</span></span>$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>\overline{x + y} \qquad \underline{x - y}<br>$$</p>
<h3 id="上下大括号"><a href="#上下大括号" class="headerlink" title="上下大括号"></a>上下大括号</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">overbrace</span><span class="string">&#123;\Lambda + \Upsilon + \cdots + \Gamma&#125;</span></span>^&#123;i&#125;$</span> <span class="tag">\<span class="name">qquad</span></span> <span class="formula">$<span class="tag">\<span class="name">underbrace</span><span class="string">&#123;\alpha + \beta + \cdots + \gamma&#125;</span></span>_&#123;j&#125;$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>\overbrace{\Lambda + \Upsilon + \cdots + \Gamma}^{i} \qquad \underbrace{\alpha + \beta + \cdots + \gamma}_{j}<br>$$</p>
<h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">vec</span><span class="string">&#123;x&#125;</span></span>$</span> <span class="tag">\<span class="name">qquad</span></span> <span class="formula">$<span class="tag">\<span class="name">overrightarrow</span><span class="string">&#123;XY&#125;</span></span>$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>\vec{x} \qquad \overrightarrow{XY}<br>$$</p>
<h3 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">frac</span><span class="string">&#123;1&#125;</span><span class="string">&#123;2&#125;</span></span>$</span> <span class="tag">\<span class="name">quad</span></span> <span class="formula">$<span class="tag">\<span class="name">frac</span><span class="string">&#123;x^2&#125;</span><span class="string">&#123;z + 2&#125;</span></span>$</span> <span class="tag">\<span class="name">quad</span></span> <span class="formula">$e^&#123;<span class="tag">\<span class="name">frac</span><span class="string">&#123;n&#125;</span><span class="string">&#123;\sin x + 1&#125;</span></span>&#125;$</span> <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">sqrt</span><span class="string">&#123;x&#125;</span>=</span>x^&#123;1/2&#125;<span class="formula">$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>\frac{1}{2} \quad \frac{x^2}{z + 2} \quad e^{\frac{n}{\sin x + 1}} \quad \sqrt{x}=x^{1/2}<br>$$</p>
<h3 id="累加、累积、积分"><a href="#累加、累积、积分" class="headerlink" title="累加、累积、积分"></a>累加、累积、积分</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">sum</span></span>_&#123;i = 1&#125;^n i = <span class="tag">\<span class="name">frac</span><span class="string">&#123;n(n+1)&#125;</span><span class="string">&#123;2&#125;</span></span>$</span> <span class="tag">\<span class="name">quad</span></span> <span class="formula">$<span class="tag">\<span class="name">prod</span></span>_&#123;j = 1&#125;^&#123;n&#125; = n!$</span> <span class="tag">\<span class="name">quad</span></span> <span class="formula">$<span class="tag">\<span class="name">int</span></span>_&#123;0&#125;^&#123;<span class="tag">\<span class="name">pi</span></span>/2&#125; <span class="tag">\<span class="name">sin</span></span> x <span class="tag">\<span class="name">mathrm</span><span class="string">&#123;d&#125;</span></span>x = 1$</span> </span><br></pre></td></tr></table></figure>

<p>$$<br>\sum_{i = 1}^n i = \frac{n(n+1)}{2} \quad \prod_{j = 1}^{n} = n! \quad \int_{0}^{\pi/2} \sin x \mathrm{d}x = 1<br>$$</p>
<h2 id="数学符号表"><a href="#数学符号表" class="headerlink" title="数学符号表"></a>数学符号表</h2><h3 id="数学模式重音符"><a href="#数学模式重音符" class="headerlink" title="数学模式重音符"></a>数学模式重音符</h3><table>
<thead>
<tr>
<th>$\hat{x}$  \hat{x}</th>
<th>$\check{x}$  \check{x}</th>
<th>$\tilde{x}$  \tilde{x}</th>
<th>$\acute{x}$  \acute{x}</th>
</tr>
</thead>
<tbody><tr>
<td>$\grave{x}$  \grave{x}</td>
<td>$\dot{x}$  \dot{x}</td>
<td>$\ddot{x}$  \ddot{x}</td>
<td>$\breve{x}$  \breve{x}</td>
</tr>
<tr>
<td>$\bar{x}$  \bar{x}</td>
<td>$\vec{x}$  \vec{x}</td>
<td>$\widehat{X}$  \widehat{X}</td>
<td>$\widetilde{Y}$  \widetilde{Y}</td>
</tr>
</tbody></table>
<h3 id="小写希腊字母"><a href="#小写希腊字母" class="headerlink" title="小写希腊字母"></a>小写希腊字母</h3><table>
<thead>
<tr>
<th>$\alpha$  \alpha</th>
<th>$\beta$  \beta</th>
<th>$\gamma$  \gamma</th>
<th>$\delta$  \delta</th>
</tr>
</thead>
<tbody><tr>
<td>$\epsilon$  \epsilon</td>
<td>$\varepsilon$  \varepsilon</td>
<td>$\zeta$  \zeta</td>
<td>$\eta$  \eta</td>
</tr>
<tr>
<td>$\theta$  \theta</td>
<td>$\vartheta$  \vartheta</td>
<td>$\iota$  \iota</td>
<td>$\kappa$  \kappa</td>
</tr>
<tr>
<td>$\lambda$  \lambda</td>
<td>$\mu$  \mu</td>
<td>$\nu$  \nu</td>
<td>$\xi$  \xi</td>
</tr>
<tr>
<td>$\omicron$  \omicron</td>
<td>$\pi$  \pi</td>
<td>$\varpi$  \varpi</td>
<td>$\rho$  \rho</td>
</tr>
<tr>
<td>$\sigma$  \sigma</td>
<td>$\varsigma$  \varsigma</td>
<td>$\tau$  \tau</td>
<td>$\upsilon$ \upsilon</td>
</tr>
<tr>
<td>$\phi$  \phi</td>
<td>$\varphi$  \varphi</td>
<td>$\chi$  \chi</td>
<td>$\psi$ \psi</td>
</tr>
<tr>
<td>$\omega$  \omega</td>
<td>$\varrho$  \varrho</td>
<td>$\varsigma$  \varsigma</td>
<td></td>
</tr>
</tbody></table>
<h3 id="大写希腊字母"><a href="#大写希腊字母" class="headerlink" title="大写希腊字母"></a>大写希腊字母</h3><table>
<thead>
<tr>
<th>$\Theta$  \Theta</th>
<th>$\Psi$  \Psi</th>
<th>$\Gamma$  \Gamma</th>
<th>$\Lambda$  \Lambda</th>
</tr>
</thead>
<tbody><tr>
<td>$\Sigma$  \Sigma</td>
<td>$\Delta$  \Delta</td>
<td>$\Xi$  \Xi</td>
<td>$\Pi$  \Pi</td>
</tr>
<tr>
<td>$\Upsilon$  \Upsilon</td>
<td>$\Phi$  \Phi</td>
<td>$\Omega$  \Omega</td>
<td></td>
</tr>
</tbody></table>
<h3 id="二元关系符"><a href="#二元关系符" class="headerlink" title="二元关系符"></a>二元关系符</h3><table>
<thead>
<tr>
<th>$&lt;$  &lt;</th>
<th>$&gt;$  &gt;</th>
<th>$=$  =</th>
<th>$\neq$  \neq</th>
</tr>
</thead>
<tbody><tr>
<td>$\leq$  \leq or \le</td>
<td>$\geq$  \geq or \ge</td>
<td>$\equiv$  \equiv</td>
<td>$\doteq$  \doteq</td>
</tr>
<tr>
<td>$\ll$  \ll</td>
<td>$\gg$  \gg</td>
<td>$\sim$  \sim</td>
<td>$\approx$  \approx</td>
</tr>
<tr>
<td>$\prec$  \prec</td>
<td>$\succ$  \succ</td>
<td>$\simeq$  \simeq</td>
<td>$\cong$  \cong</td>
</tr>
<tr>
<td>$\preceq$  \preceq</td>
<td>$\succeq$  \succeq</td>
<td>$\in$  \in</td>
<td>$\ni$  \ni or \owns</td>
</tr>
<tr>
<td>$\subset$  \subset</td>
<td>$\supset$  \supset</td>
<td>$\Join$  \Join</td>
<td>$\bowtie$  \bowtie</td>
</tr>
<tr>
<td>$\subseteq$  \subseteq</td>
<td>$\supseteq$  \supseteq</td>
<td>$\propto$  \propto</td>
<td>$\vdash$  \vdash</td>
</tr>
<tr>
<td>$\sqsubset$  \sqsubset</td>
<td>$\sqsupset$  \sqsupset</td>
<td>$\models$  \models</td>
<td>$\dashv$  \dashv</td>
</tr>
<tr>
<td>$\sqsubseteq$  \sqsubset</td>
<td>$\sqsupseteq$  \sqsupseteq</td>
<td>$\smile$  \smile</td>
<td>$\perp$  \perp</td>
</tr>
<tr>
<td>$\mid$  \mid</td>
<td>$\parallel$  \parallel</td>
<td>$\frown$  \frown</td>
<td>$\asymp$  \asymp</td>
</tr>
<tr>
<td>$\not \leq$  \not \leq</td>
<td>$\not\prec$  \not \prec</td>
<td>$\not \in$ \not \in</td>
<td>$\not \perp$  \not \perp</td>
</tr>
</tbody></table>
<h3 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h3><table>
<thead>
<tr>
<th>$+$  +</th>
<th>$-$  -</th>
<th>$\pm$  \pm</th>
<th>$\mp$  \mp</th>
</tr>
</thead>
<tbody><tr>
<td>$\cdot$  \cdot</td>
<td>$\div$  \div</td>
<td>$\times$  \times</td>
<td>$\setminus$  \setminus</td>
</tr>
<tr>
<td>$\cup$  \cup</td>
<td>$\cap$  \cap</td>
<td>$\sqcup$  \sqcup</td>
<td>$\sqcap$  \sqcap</td>
</tr>
<tr>
<td>$\vee$ \vee or \lor</td>
<td>$\wedge$ \wedge or \land</td>
<td>$\triangleleft$ \triangleleft</td>
<td>$\triangleright$ \triangleright</td>
</tr>
<tr>
<td>$\star$ \star</td>
<td>$\ast$ \ast</td>
<td>$\circ$ \circ</td>
<td>$\bullet$  \bullet</td>
</tr>
<tr>
<td>$\oplus$  \oplus</td>
<td>$\ominus$  \ominus</td>
<td>$\odot$  \odot</td>
<td>$\oslash$  \oslash</td>
</tr>
<tr>
<td>$\otimes$  \otimes</td>
<td>$\oslash$  \oslash</td>
<td>$\diamond$  \diamond</td>
<td>$\uplus$  \uplus</td>
</tr>
<tr>
<td>$\bigtriangleup$ \bigtriangleup</td>
<td>$\bigtriangledown$  \bigtriangledown</td>
<td>$\amalg$  \amalg</td>
<td>$\wr$  \wr</td>
</tr>
<tr>
<td>$\lhd$  \lhd</td>
<td>$\rhd$  \rhd</td>
<td>$\dagger$  \dagger</td>
<td>$\ddagger$  \ddagger</td>
</tr>
<tr>
<td>$\unlhd$  \unlhd</td>
<td>$\unrhd$  \unrhd</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="大尺寸运算符"><a href="#大尺寸运算符" class="headerlink" title="大尺寸运算符"></a>大尺寸运算符</h3><table>
<thead>
<tr>
<th>$\sum$  \sum</th>
<th>$\prod$  \prod</th>
<th>$\coprod$  \coprod</th>
<th>$\int$  \int</th>
</tr>
</thead>
<tbody><tr>
<td>$\bigcup$  \bigcup</td>
<td>$\bigcap$  \bigcap</td>
<td>$\bigsqcup$  \bigsqcup</td>
<td>$\oint$  \oint</td>
</tr>
<tr>
<td>$\bigvee$  \bigvee</td>
<td>$\bigwedge$  \bigwedge</td>
<td>$\bigoplus$  \bigoplus</td>
<td>$\bigotimes$  \bigotimes</td>
</tr>
<tr>
<td>$\bigodot$  \bigodot</td>
<td>$\biguplus$  \biguplus</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h3><table>
<thead>
<tr>
<th>$\leftarrow$  \leftarrow or \gets</th>
<th>$\rightarrow$  \rightarrow or \to</th>
<th>$\leftrightarrow$ \leftrightarrow</th>
<th>$\mapsto$  \mapsto</th>
</tr>
</thead>
<tbody><tr>
<td>$\Leftarrow$  \Leftarrow</td>
<td>$\Rightarrow$  \Rightarrow</td>
<td>$\Leftrightarrow$ \Leftrightarrow</td>
<td>$\longmapsto$ \longmapsto</td>
</tr>
<tr>
<td>$\hookleftarrow$ \hookleftarrow</td>
<td>$\hookrightarrow$ \hookrightarrow</td>
<td>$\leftharpoonup$ \leftharpoonup</td>
<td>$\rightharpoonup$ \rightharpoonup</td>
</tr>
<tr>
<td>$\longleftarrow$ \longleftarrow</td>
<td>$\longrightarrow$ \longrightarrow</td>
<td>$\leftharpoondown$ \leftharpoondown</td>
<td>$\rightharpoondown$ \rightharpoondown</td>
</tr>
<tr>
<td>$\Longleftarrow$ \Longleftarrow</td>
<td>$\Longrightarrow$ \Longrightarrow</td>
<td>$\rightleftharpoons$ \rightleftharpoons</td>
<td>$\iff$ \iff</td>
</tr>
<tr>
<td>$\longleftrightarrow$ \longleftrightarrow</td>
<td>$\Longleftrightarrow$ \Longleftrightarrow</td>
<td>$\uparrow$  \uparrow</td>
<td>$\downarrow$ \downarrow</td>
</tr>
<tr>
<td>$\nearrow$  \nearrow</td>
<td>$\swarrow$ \swarrow</td>
<td>$\Uparrow$ \Uparrow</td>
<td>$\Downarrow$ \Downarrow</td>
</tr>
<tr>
<td>$\searrow$ \searrow</td>
<td>$\nwarrow$  \nwarrow</td>
<td>$\updownarrow$ \updownarrow</td>
<td>$\Updownarrow$ \Updownarrow</td>
</tr>
<tr>
<td>$\leadsto$ \leadsto</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="定界符"><a href="#定界符" class="headerlink" title="定界符"></a>定界符</h3><table>
<thead>
<tr>
<th>$($  (</th>
<th>$)$ )</th>
<th>$\vert$  \vert or |</th>
<th>$\Vert$  \Vert or \</th>
</tr>
</thead>
<tbody><tr>
<td>$[$  [ or \lbrack</td>
<td>$]$ ] or \rbrack</td>
<td>$\lceil$  \lceil</td>
<td>$\rceil$  \rceil</td>
</tr>
<tr>
<td>$\lbrace$ \{ or \lbrace</td>
<td>$\rbrace$ \} or \rbrace</td>
<td>$\lgroup$ \lgroup</td>
<td>$\rgroup$  \rgroup</td>
</tr>
<tr>
<td>$\langle$  \langle</td>
<td>$\rangle$  \rangle</td>
<td>$\lmoustache$  lmoustache</td>
<td>$\rmoustache$ \rmoustache</td>
</tr>
<tr>
<td>$\lfloor$  \lfloor</td>
<td>$\rfloor$  \rfloor</td>
<td>$\arrowvert$  \arrowvert</td>
<td>$\Arrowvert$  \Arrowvert</td>
</tr>
<tr>
<td>$/$  /</td>
<td>$\backslash$  \backslash</td>
<td>$\bracevert$  bracevert</td>
<td></td>
</tr>
</tbody></table>
<h3 id="其他符号"><a href="#其他符号" class="headerlink" title="其他符号"></a>其他符号</h3><table>
<thead>
<tr>
<th>$\cdots$  \cdots</th>
<th>$\dots$  \dots</th>
<th>$\vdots$  \vdots</th>
<th>$\ddots$  \ddots</th>
</tr>
</thead>
<tbody><tr>
<td>$\hbar$  \hbar</td>
<td>$\imath$  \imath</td>
<td>$\jmath$  \jmath</td>
<td>$\ell$  \ell</td>
</tr>
<tr>
<td>$\Re$  \Re</td>
<td>$\Im$  \Im</td>
<td>$\aleph$  \aleph</td>
<td>$\wp$  \wp</td>
</tr>
<tr>
<td>$\forall$  \forall</td>
<td>$\exists$  \exists</td>
<td>$\mho$  \mho</td>
<td>$\partial$  \partial</td>
</tr>
<tr>
<td>$’$  ‘</td>
<td>$\prime$  \prime</td>
<td>$\emptyset$  \emptyset</td>
<td>$\infty$  \infty</td>
</tr>
<tr>
<td>$\nabla$  \nabla</td>
<td>$\triangle$  \triangle</td>
<td>$\Box$  \Box</td>
<td>$\Diamond$  \Diamond</td>
</tr>
<tr>
<td>$\bot$  \bot</td>
<td>$\top$  \top</td>
<td>$\angle$  \angle</td>
<td>$\surd$  \surd</td>
</tr>
<tr>
<td>$\diamondsuit$  \diamondsuit</td>
<td>$\heartsuit$  \heartsuit</td>
<td>$\clubsuit$  \clubsuit</td>
<td>$\spadesuit$  \spadesuit</td>
</tr>
<tr>
<td>$\neg$  \neg or \lnot</td>
<td>$\flat$  \flat</td>
<td>$\natural$  \natural</td>
<td>$\sharp$  \sharp</td>
</tr>
<tr>
<td>$\S$  \S</td>
<td>$\ulcorner$ \ulcorner</td>
<td>$\urcorner$  \urcorner</td>
<td>$\llcorner$  \llcorner</td>
</tr>
<tr>
<td>$\lvert$  \lvert</td>
<td>$\lVert$  \lVert</td>
<td>$\rVert$  \rVert</td>
<td>$\lrcorner$  lrcorner</td>
</tr>
<tr>
<td>$\rvert$  \rvert</td>
<td>$\digamma$  \digamma</td>
<td>$\varkappa$  \varkappa</td>
<td>$\P$</td>
</tr>
<tr>
<td>$\beth$  \beth</td>
<td>$\daleth$  \daleth</td>
<td>$\gimel$  \gimel</td>
<td></td>
</tr>
</tbody></table>
<h3 id="AMS-二元关系符"><a href="#AMS-二元关系符" class="headerlink" title="AMS 二元关系符"></a>AMS 二元关系符</h3><table>
<thead>
<tr>
<th>$\lessdot$  \lessdot</th>
<th>$\gtrdot$  \gtrdot</th>
<th>$\doteqdot$  \doteqdot</th>
<th>$\triangleq$  \triangleq</th>
</tr>
</thead>
<tbody><tr>
<td>$\leqslant$  \leqslant</td>
<td>$\geqslant$  \geqslant</td>
<td>$\risingdotseq$  \risingdotseq</td>
<td>$\bumpeq$  \bumpeq</td>
</tr>
<tr>
<td>$\eqslantless$  \eqslantless</td>
<td>$\eqslantgtr$  \eqslantgtr</td>
<td>$\fallingdotseq$  \fallingdotseq</td>
<td>$\Bumpeq$  \Bumpeq</td>
</tr>
<tr>
<td>$\leqq$  \leqq</td>
<td>$\geqq$  \geqq</td>
<td>$\eqcirc$  \eqcirc</td>
<td>$\thicksim$  \thicksim</td>
</tr>
<tr>
<td>$\lll$  \lll</td>
<td>$\ggg$  \ggg</td>
<td>$\circeq$  \circeq</td>
<td>$\thickapprox$  \thickapprox</td>
</tr>
<tr>
<td>$\lesssim$  \lesssim</td>
<td>$\gtrsim$  \gtrsim</td>
<td>$\backsimeq$  \backsimeq</td>
<td>$\approxeq$  \approxeq</td>
</tr>
<tr>
<td>$\lessapprox$  \lessapprox</td>
<td>$\gtrapprox$  \gtrapprox</td>
<td>$\backsim$  \backsim</td>
<td>$\vDash$  \vDash</td>
</tr>
<tr>
<td>$\lessgtr$  \lessgtr</td>
<td>$\gtrless$  \gtrless</td>
<td>$\Vvdash$  \Vvdash</td>
<td>$\Vdash$  \Vdash</td>
</tr>
<tr>
<td>$\lesseqgtr$  \lesseqgtr</td>
<td>$\gtreqless$  \gtreqless</td>
<td>$\backepsilon$  \backepsilon</td>
<td>$\varpropto$  \varpropto</td>
</tr>
<tr>
<td>$\lesseqqgtr$  \lesseqqgtr</td>
<td>$\gtreqqless$  \gtreqqless</td>
<td>$\between$  \between</td>
<td>$\pitchfork$  \pitchfork</td>
</tr>
<tr>
<td>$\preccurlyeq$  \preccurlyeq</td>
<td>$\succcurlyeq$  \succcurlyeq</td>
<td>$\vartriangleleft$  \vartriangleleft</td>
<td>$\trianglelefteq$  \trianglelefteq</td>
</tr>
<tr>
<td>$\curlyeqprec$  \curlyeqprec</td>
<td>$\curlyeqsucc$  \curlyeqsucc</td>
<td>$\vartriangleright$  \vartriangleright</td>
<td>$\trianglerighteq$  \trianglerighteq</td>
</tr>
<tr>
<td>$\precsim$  \precsim</td>
<td>$\succsim$  \succsim</td>
<td>$\blacktriangleleft$  \blacktriangleleft</td>
<td>$\blacktriangleright$  \blacktriangleright</td>
</tr>
<tr>
<td>$\precapprox$  \precapprox</td>
<td>$\succapprox$ \succapprox</td>
<td>$\therefore$  \therefore</td>
<td>$\because$  \because</td>
</tr>
<tr>
<td>$\subseteqq$  \subseteqq</td>
<td>$\supseteqq$  \supseteqq</td>
<td>$\shortmid$  \shortmid</td>
<td>$\shortparallel$  \shortparallel</td>
</tr>
<tr>
<td>$\Subset$  \Subset</td>
<td>$\Subset$  \Subset</td>
<td>$\smallsmile$  \smallsmile</td>
<td>$\smallfrown$  \smallfrown</td>
</tr>
</tbody></table>
<h3 id="AMS-箭头"><a href="#AMS-箭头" class="headerlink" title="AMS 箭头"></a>AMS 箭头</h3><table>
<thead>
<tr>
<th>$\dashleftarrow$  \dashleftarrow</th>
<th>$\leftarrowtail$  \leftarrowtail</th>
<th>$\circlearrowleft$  \circlearrowleft</th>
<th>$\rightleftarrows$  \rightleftarrows</th>
</tr>
</thead>
<tbody><tr>
<td>$\leftleftarrows$  \leftleftarrows</td>
<td>$\leftrightharpoons$  \leftrightharpoons</td>
<td>$\circlearrowright$  \circlearrowright</td>
<td>$\Rrightarrow$   \Rrightarrow</td>
</tr>
<tr>
<td>$\leftrightarrows$  \leftrightarrows</td>
<td>$\Lsh$  \Lsh</td>
<td>$\curvearrowright$  \curvearrowright</td>
<td>$\twoheadrightarrow$  \twoheadrightarrow</td>
</tr>
<tr>
<td>$\Lleftarrow$  \Lleftarrow</td>
<td>$\looparrowleft$  \looparrowleft</td>
<td>$\looparrowright$  \looparrowright</td>
<td>$\rightarrowtail$  \rightarrowtail</td>
</tr>
<tr>
<td>$\twoheadleftarrow$  \twoheadleftarrow</td>
<td>$\curvearrowleft$  \curvearrowleft</td>
<td>$\Rsh$  \Rsh</td>
<td>$\rightleftharpoons$   \rightleftharpoons</td>
</tr>
<tr>
<td>$\rightrightarrows$  \rightrightarrows</td>
<td>$\multimap$  \multimap</td>
<td>$\rightsquigarrow$  \rightsquigarrow</td>
<td>$\leftrightsquigarrow$   \leftrightsquigarrow</td>
</tr>
<tr>
<td>$\dashrightarrow$  \dashrightarrow</td>
<td>$\upuparrows$  \upuparrows</td>
<td>$\downdownarrows$  \downdownarrows</td>
<td></td>
</tr>
<tr>
<td>$\upharpoonleft$  \upharpoonleft</td>
<td>$\upharpoonright$  \upharpoonright</td>
<td>$\downharpoonleft$  \downharpoonleft</td>
<td>$\downharpoonright$  \downharpoonright</td>
</tr>
</tbody></table>
<h3 id="AMS二元否定关系符和箭头"><a href="#AMS二元否定关系符和箭头" class="headerlink" title="AMS二元否定关系符和箭头"></a>AMS二元否定关系符和箭头</h3><table>
<thead>
<tr>
<th>$\nless$ \nless</th>
<th>$\ngtr$ \ngtr</th>
<th>$\varsubsetneqq$ \varsubsetneqq</th>
<th>$\ncong$ \ncong</th>
</tr>
</thead>
<tbody><tr>
<td>$\lneq$ \lneq</td>
<td>$\gneq$ \gneq</td>
<td>$\varsupsetneqq$ \varsupsetneqq</td>
<td>$\nvdash$ \nvdash</td>
</tr>
<tr>
<td>$\nleq$ \nleq</td>
<td>$\ngeq$ \ngeq</td>
<td>$\nsubseteqq$ \nsubseteqq</td>
<td>$\nvDash$ \nvDash</td>
</tr>
<tr>
<td>$\nleqslant$ \nleqslant</td>
<td>$\ngeqslant$ \ngeqslant</td>
<td>$\nsupseteqq$ \nsupseteqq</td>
<td>$\nVdash$ \nVdash</td>
</tr>
<tr>
<td>$\lneqq$ \lneqq</td>
<td>$\gneqq$ \gneqq</td>
<td>$\nmid$ \nmid</td>
<td>$\nVDash$ \nVDash</td>
</tr>
<tr>
<td>$\lvertneqq$ \lvertneqq</td>
<td>$\gvertneqq$ \gvertneqq</td>
<td>$\nparallel$ \nparallel</td>
<td>$\ntriangleleft$ \ntriangleleft</td>
</tr>
<tr>
<td>$\nleqq$ \nleqq</td>
<td>$\ngeqq$ \ngeqq</td>
<td>$\nshortmid$ \nshortmid</td>
<td>$\ntriangleright$ \ntriangleright</td>
</tr>
<tr>
<td>$\lnsim$ \lnsim</td>
<td>$\gnsim$ \gnsim</td>
<td>$\nshortparallel$ \nshortparallel</td>
<td>$\ntrianglelefteq$ \ntrianglelefteq</td>
</tr>
<tr>
<td>$\lnapprox$ \lnapprox</td>
<td>$\gnapprox$ \gnapprox</td>
<td>$\nsim$ \nsim</td>
<td>$\ntrianglerighteq$ \ntrianglerighteq</td>
</tr>
<tr>
<td>$\nprec$ \nprec</td>
<td>$\nsucc$ \nsucc</td>
<td>$\nleftrightarrow$ \nleftrightarrow</td>
<td>$\nLeftrightarrow$ \nLeftrightarrow</td>
</tr>
<tr>
<td>$\npreceq$ \npreceq</td>
<td>$\nsucceq$ \nsucceq</td>
<td>$\nleftarrow$ \nleftarrow</td>
<td>$\nrightarrow$ \nrightarrow</td>
</tr>
<tr>
<td>$\precneqq$ \precneqq</td>
<td>$\succneqq$ \succneqq</td>
<td>$\nLeftarrow$ \nLeftarrow</td>
<td>$\nRightarrow$ \nRightarrow</td>
</tr>
<tr>
<td>$\precnsim$ \precnsim</td>
<td>$\succnsim$ \succnsim</td>
<td>$\varsubsetneq$ \varsubsetneq</td>
<td>$\varsupsetneq$ \varsupsetneq</td>
</tr>
<tr>
<td>$\precnapprox$ \precnapprox</td>
<td>$\succnapprox$ \succnapprox</td>
<td>$\nsubseteq$ \nsubseteq</td>
<td>$\nsupseteq$ \nsupseteq</td>
</tr>
<tr>
<td>$\subsetneq$ \subsetneq</td>
<td>$\supsetneq$ \supsetneq</td>
<td>$\subsetneqq$ \subsetneqq</td>
<td>$\supsetneqq$ \supsetneqq</td>
</tr>
</tbody></table>
<h3 id="AMS二元运算符及其他符号"><a href="#AMS二元运算符及其他符号" class="headerlink" title="AMS二元运算符及其他符号"></a>AMS二元运算符及其他符号</h3><table>
<thead>
<tr>
<th>$\dotplus$  \dotplus</th>
<th>$\centerdot$  \centerdot</th>
<th>$\intercal$  \intercal</th>
<th>$\hbar$  \hbar</th>
</tr>
</thead>
<tbody><tr>
<td>$\ltimes$  \ltimes</td>
<td>$\rtimes$  \rtimes</td>
<td>$\divideontimes$  \divideontimes</td>
<td>$\square$  \square</td>
</tr>
<tr>
<td>$\Cup$  \Cup</td>
<td>$\Cap$  \Cap</td>
<td>$\smallsetminus$   \smallsetminus</td>
<td>$\vartriangle$  \vartriangle</td>
</tr>
<tr>
<td>$\veebar$  \veebar</td>
<td>$\barwedge$  \barwedge</td>
<td>$\doublebarwedge$  \doublebarwedge</td>
<td>$\lozenge$  \lozenge</td>
</tr>
<tr>
<td>$\boxplus$  \boxplus</td>
<td>$\boxminus$  \boxminus</td>
<td>$\circleddash$  \circleddash</td>
<td>$\angle$   \angle</td>
</tr>
<tr>
<td>$\boxtimes$  \boxtimes</td>
<td>$\boxdot$  \boxdot</td>
<td>$\circledcirc$  \circledcirc</td>
<td>$\diagup$  \diagup</td>
</tr>
<tr>
<td>$\leftthreetimes$  \leftthreetimes</td>
<td>$\rightthreetimes$  \rightthreetimes</td>
<td>$\circledast$  \circledast</td>
<td>$\nexists$  \nexists</td>
</tr>
<tr>
<td>$\curlyvee$  \curlyvee</td>
<td>$\curlywedge$  \curlywedge</td>
<td>$\hslash$  \hslash</td>
<td>$\eth$  \eth</td>
</tr>
<tr>
<td>$\blacksquare$  \blacksquare</td>
<td>$\blacktriangle$  \blacktriangle</td>
<td>$\blacktriangledown$  \blacktriangledown</td>
<td>$\blacklozenge$  \blacklozenge</td>
</tr>
<tr>
<td>$\measuredangle$  \measuredangle</td>
<td>$\diagdown$  \diagdown</td>
<td>$\Finv$  \Finv</td>
<td>$\mho$  \mho</td>
</tr>
<tr>
<td>$\Bbbk$  \Bbbk</td>
<td>$\circledS$  \circledS</td>
<td>$\complement$  \complement</td>
<td>$\Game$  \Game</td>
</tr>
<tr>
<td>$\bigstar$  \bigstar</td>
<td>$\sphericalangle$  \sphericalangle</td>
<td>$\backprime$  \backprime</td>
<td>$\varnothing$  \varnothing</td>
</tr>
</tbody></table>
<h3 id="数学字母类"><a href="#数学字母类" class="headerlink" title="数学字母类"></a>数学字母类</h3><p>罗马字体 roman</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">mathrm</span><span class="string">&#123;ABCdef&#125;</span></span>$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>\mathrm{ABCdef}<br>$$</p>
<p>斜体</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">mathit</span><span class="string">&#123;ABCdef&#125;</span></span>$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>\mathit{ABCdef}<br>$$</p>
<p>美术字体-书法字体</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">mathcal</span><span class="string">&#123;ABCdef&#125;</span></span>$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>\mathcal{ABCdef}<br>$$</p>
<p>花体 <code>\usepackage&#123;mathrsfs&#125;</code></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">mathscr</span><span class="string">&#123;ABCdef&#125;</span></span>$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>\mathscr{ABCdef}<br>$$</p>
<p>德文尖角体 <code>\usepackage&#123;amssymb&#125;</code></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">mathfrak</span><span class="string">&#123;ABCdef&#125;</span></span>$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>\mathfrak{ABCdef}<br>$$</p>
<p>黑板粗体 <code>\usepackage&#123;amssymb&#125;</code></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">mathbb</span><span class="string">&#123;ABCdef&#125;</span></span>$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>\mathbb{ABCdef}<br>$$</p>
<p>打字机体</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">mathtt</span><span class="string">&#123;ABCdef&#125;</span></span>$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>\mathtt{ABCdef}<br>$$</p>
<p>无衬线</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">mathsf</span><span class="string">&#123;ABCdef&#125;</span></span>$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>\mathsf{ABCdef}<br>$$</p>
<p>打字机体</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">mathtt</span><span class="string">&#123;ABCdef&#125;</span></span>$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>\mathtt{ABCdef}<br>$$</p>
<h1 id="常用特殊符号"><a href="#常用特殊符号" class="headerlink" title="常用特殊符号"></a>常用特殊符号</h1><p>$\ell$ (\ell) ：区分 l 和 1</p>
<p>$\Re$ (\Re) ：复数实部</p>
<p>$\Im$（\Im）：复数虚部</p>
<p>$\nabla$ (\nabla) ： 拉普拉斯算子</p>
<p>$\mathcal{L}$（\mathcal{L}）：机器学习损失函数</p>
<p>$\mathcal{N}$（\mathcal{N}）：高斯分布</p>
<p>$\mathbb{N}$（\mathbb{N}）：自然数</p>
<h1 id="Python-中输出-latex-特殊符号"><a href="#Python-中输出-latex-特殊符号" class="headerlink" title="Python 中输出 latex 特殊符号"></a>Python 中输出 latex 特殊符号</h1><p>介绍在 notebook 中输出 latex 符号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%latex</span><br><span class="line">$\mathscr&#123;a&#125;$</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Latex, display, Math</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">97</span>, <span class="number">123</span>):</span><br><span class="line">    display(Latex(<span class="string">r&quot;$\mathscr&#123;&#123;&#123;0&#125;&#125;&#125;$&quot;</span>.format(chr(i))))</span><br><span class="line"><span class="comment">#    display(Math(r&quot;$\mathscr&#123;&#123;&#123;0&#125;&#125;&#125;$&quot;.format(chr(i))))</span></span><br></pre></td></tr></table></figure>

<p><strong>注释与说明</strong></p>
<ol>
<li><p>本篇为参考<a href="http://mohu.org/info/symbols/symbols.htm">常用数学符号的 LaTeX 表示方法</a>总结的LaTeX常用数学运算符号和字母符号集。</p>
</li>
<li><p>网页版显示效果跟浏览器有关系，但是，对于用LaTeX写文章都是一样的显示效果。</p>
</li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="http://mohu.org/info/symbols/symbols.htm">常用数学符号的 LaTeX 表示方法</a></li>
<li><a href="https://blog.csdn.net/lanchunhui/article/details/54633576">LaTeX —— 特殊符号与数学字体</a></li>
<li><a href="https://www.cnblogs.com/MTandHJ/p/10527926.html">Latex(数学)</a></li>
</ol>
]]></content>
      <categories>
        <category>maths</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件隐藏属性</title>
    <url>/2020/07/18/linux-file-hidden-attributes/</url>
    <content><![CDATA[<p>Linux 隐藏属性对于系统安全非常重要，特别是chattr命令。所谓隐藏属性就是使用标准的 ls -la命令无法查看的属性，不过需要知道的是chattr命令只能在Ext2/Ext3/Ext4的Linux传统文件系统上完整生效，其他文件系统可能无法完整支持这个命令。如xfs仅仅支持chattr命令的部分参数而已。</p>
<a id="more"></a>

<ul>
<li><p>chattr 设置文件隐藏属性</p>
<p>基本命令方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@centos ~]# chattr  [+-=] [AaSscdiu] 文件或目录名称</span><br><span class="line">选项与参数：</span><br><span class="line">+：增加某一个特殊参数，其他原本存在参数不动</span><br><span class="line">-：移除某一个特殊参数，其他原本存在参数不动</span><br><span class="line">=：设置一定，且仅有后面接的参数</span><br><span class="line">A：存取文件或目录时，存取时间atime不会被修改，可避免I/O较慢机器过度存取磁盘</span><br><span class="line">a：文件只能增加数据，不能删除不能修改数据，只有root可以设置该属性</span><br><span class="line">S：一般的文件是使用非同步的方式写入磁盘，设置该属性后可保证文件修改后同步写入磁盘</span><br><span class="line">s：文件被删除，则将会被完全的移除出硬盘，误删将完全无法挽回</span><br><span class="line">c：将自动“压缩”文件，读取时将自动解压缩，存储时将压缩后再存储</span><br><span class="line">d：当dump程序被执行的时候，设置d属性将可使该文件或目录不会被dump备份</span><br><span class="line">i：可使得文件不能被删除、改名、设置链接、写入或新增数据，只有root可以设置该属性</span><br><span class="line">u：与s相反，如果文件被删除，则数据内容还存在磁盘中，可以使用该方法保证文件内容在磁盘上</span><br></pre></td></tr></table></figure>

<p>更多更详细(man chattr)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CHATTR(1)                             General Commands Manual                             CHATTR(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       chattr - change file attributes on a Linux file system</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       chattr [ -RVf ] [ -v version ] [ -p project ] [ mode ] files...</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       chattr changes the file attributes on a Linux file system.</span><br><span class="line"></span><br><span class="line">       The format of a symbolic mode is +-=[aAcCdDeijPsStTu].</span><br><span class="line"></span><br><span class="line">       The  operator  &#x27;+&#x27;  causes the selected attributes to be added to the existing attributes of</span><br><span class="line">       the files; &#x27;-&#x27; causes them to be removed; and &#x27;=&#x27; causes them to be the only attributes that</span><br><span class="line">       the files have.</span><br><span class="line"></span><br><span class="line">       The  letters &#x27;aAcCdDeFijPsStTu&#x27; select the new attributes for the files: append only (a), no</span><br><span class="line">       atime updates (A), compressed (c), no copy on write (C), no dump (d), synchronous  directory</span><br><span class="line">       updates  (D), extent format (e), case-insensitive directory lookups (F), immutable (i), data</span><br><span class="line">       journalling (j), project hierarchy (P), secure deletion (s),  synchronous  updates  (S),  no</span><br><span class="line">       tail-merging (t), top of directory hierarchy (T), and undeletable (u).</span><br><span class="line"></span><br><span class="line">       The  following  attributes are read-only, and may be listed by lsattr(1) but not modified by</span><br><span class="line">       chattr: encrypted (E), indexed directory (I), and inline data (N).</span><br><span class="line"></span><br><span class="line">       Not all flags are supported or utilized by all filesystems; refer to filesystem-specific man</span><br><span class="line">       pages such as btrfs(5), ext4(5), and xfs(5) for more filesystem-specific details.</span><br><span class="line"></span><br><span class="line">OPTIONS</span><br><span class="line">       -R     Recursively change attributes of directories and their contents.</span><br><span class="line"></span><br><span class="line">       -V     Be verbose with chattr&#x27;s output and print the program version.</span><br><span class="line"></span><br><span class="line">       -f     Suppress most error messages.</span><br><span class="line"></span><br><span class="line">       -v version</span><br><span class="line">              Set the file&#x27;s version/generation number.</span><br><span class="line"></span><br><span class="line">       -p project</span><br><span class="line">              Set the file&#x27;s project number.</span><br><span class="line"></span><br><span class="line">ATTRIBUTES</span><br><span class="line">       A  file  with  the  &#x27;a&#x27; attribute set can only be open in append mode for writing.  Only the</span><br><span class="line">       superuser or a process possessing the CAP_LINUX_IMMUTABLE capability can set or  clear  this</span><br><span class="line">       attribute.</span><br><span class="line"></span><br><span class="line">       When  a file with the &#x27;A&#x27; attribute set is accessed, its atime record is not modified.  This</span><br><span class="line">       avoids a certain amount of disk I/O for laptop systems.</span><br><span class="line"></span><br><span class="line">       A file with the &#x27;c&#x27; attribute set is automatically compressed on the disk by the kernel.   A</span><br><span class="line">       read  from this file returns uncompressed data.  A write to this file compresses data before</span><br><span class="line">       storing them on the disk.  Note: please make sure to read the bugs and  limitations  section</span><br><span class="line">       at the end of this document.</span><br><span class="line"></span><br><span class="line">       A  file  with the &#x27;C&#x27; attribute set will not be subject to copy-on-write updates.  This flag</span><br><span class="line">       is only supported on file systems which perform copy-on-write.  (Note: For  btrfs,  the  &#x27;C&#x27;</span><br><span class="line">       flag  should  be  set  on new or empty files.  If it is set on a file which already has data</span><br><span class="line">       blocks, it is undefined when the blocks assigned to the file will be fully stable.   If  the</span><br><span class="line">       &#x27;C&#x27;  flag is set on a directory, it will have no effect on the directory, but new files cre‐</span><br><span class="line">       ated in that directory will have the No_COW attribute set.)</span><br><span class="line"></span><br><span class="line">       A file with the &#x27;d&#x27; attribute set is not candidate for backup when the  dump(8)  program  is</span><br><span class="line">       run.</span><br><span class="line"></span><br><span class="line">       When  a  directory  with  the  &#x27;D&#x27;  attribute  set is modified, the changes are written syn‐</span><br><span class="line">       chronously on the disk; this is equivalent to the &#x27;dirsync&#x27; mount option applied to a subset</span><br><span class="line">       of the files.</span><br><span class="line"></span><br><span class="line">       The  &#x27;e&#x27;  attribute indicates that the file is using extents for mapping the blocks on disk.</span><br><span class="line">       It may not be removed using chattr(1).</span><br><span class="line"></span><br><span class="line">       The &#x27;E&#x27; attribute is used by the experimental encryption patches to indicate that  the  file</span><br><span class="line">       has  been  encrypted.   It  may not be set or reset using chattr(1), although it can be dis‐</span><br><span class="line">       played by lsattr(1).</span><br><span class="line"></span><br><span class="line">       A directory with the &#x27;F&#x27; attribute set indicates that  all  the  path  lookups  inside  that</span><br><span class="line">       directory  are  made  in  a case-insensitive fashion.  This attribute can only be changed in</span><br><span class="line">       empty directories on file systems with the casefold feature enabled.</span><br><span class="line"></span><br><span class="line">       A file with the &#x27;i&#x27; attribute cannot be modified: it cannot be deleted or renamed,  no  link</span><br><span class="line">       can  be  created to this file, most of the file&#x27;s metadata can not be modified, and the file</span><br><span class="line">       can not be  opened  in  write  mode.   Only  the  superuser  or  a  process  possessing  the</span><br><span class="line">       CAP_LINUX_IMMUTABLE capability can set or clear this attribute.</span><br><span class="line"></span><br><span class="line">       The  &#x27;I&#x27;  attribute  is used by the htree code to indicate that a directory is being indexed</span><br><span class="line">       using hashed trees.  It may not be set or reset using chattr(1), although  it  can  be  dis‐</span><br><span class="line">       played by lsattr(1).</span><br><span class="line"></span><br><span class="line">       A file with the &#x27;j&#x27; attribute has all of its data written to the ext3 or ext4 journal before</span><br><span class="line">       being written to the file itself, if the file system is mounted with the  &quot;data=ordered&quot;  or</span><br><span class="line">       &quot;data=writeback&quot;  options and the file system has a journal.  When the filesystem is mounted</span><br><span class="line">       with the &quot;data=journal&quot; option all file data is already journalled and this attribute has no</span><br><span class="line">       effect.   Only the superuser or a process possessing the CAP_SYS_RESOURCE capability can set</span><br><span class="line">       or clear this attribute.</span><br><span class="line"></span><br><span class="line">       A file with the &#x27;N&#x27; attribute set indicates that the file has data stored inline, within the</span><br><span class="line">       inode  itself.  It  may not be set or reset using chattr(1), although it can be displayed by</span><br><span class="line">       lsattr(1).</span><br><span class="line"></span><br><span class="line">       A directory with the &#x27;P&#x27; attribute set will enforce a  hierarchical  structure  for  project</span><br><span class="line">       id&#x27;s.  This means that files and directory created in the directory will inherit the project</span><br><span class="line">       id of the directory, rename operations are constrained so when a file or directory is  moved</span><br><span class="line">       into  another directory, that the project id&#x27;s much match.  In addition, a hard link to file</span><br><span class="line">       can only be created when the project id for the file and the destination directory match.</span><br><span class="line"></span><br><span class="line">       When a file with the &#x27;s&#x27; attribute set is deleted, its blocks are zeroed and written back to</span><br><span class="line">       the  disk.   Note:  please  make sure to read the bugs and limitations section at the end of</span><br><span class="line">       this document.</span><br><span class="line"></span><br><span class="line">       When a file with the &#x27;S&#x27; attribute set is modified, the changes are written synchronously on</span><br><span class="line">       the disk; this is equivalent to the &#x27;sync&#x27; mount option applied to a subset of the files.</span><br><span class="line"></span><br><span class="line">       A  file with the &#x27;t&#x27; attribute will not have a partial block fragment at the end of the file</span><br><span class="line">       merged with other files (for those filesystems which support tail-merging).  This is  neces‐</span><br><span class="line">       sary  for  applications  such  as  LILO  which read the filesystem directly, and which don&#x27;t</span><br><span class="line">       understand tail-merged files.  Note: As of this writing, the ext2 or ext3 filesystems do not</span><br><span class="line">       (yet, except in very experimental patches) support tail-merging.</span><br><span class="line"></span><br><span class="line">       A directory with the &#x27;T&#x27; attribute will be deemed to be the top of directory hierarchies for</span><br><span class="line">       the purposes of the Orlov block allocator.  This is a hint to the block  allocator  used  by</span><br><span class="line">       ext3  and ext4 that the subdirectories under this directory are not related, and thus should</span><br><span class="line">       be spread apart for allocation purposes.   For example it is a very good idea to set the &#x27;T&#x27;</span><br><span class="line">       attribute on the /home directory, so that /home/john and /home/mary are placed into separate</span><br><span class="line">       block groups.  For directories where this attribute is not set, the  Orlov  block  allocator</span><br><span class="line">       will try to group subdirectories closer together where possible.</span><br><span class="line"></span><br><span class="line">       When  a file with the &#x27;u&#x27; attribute set is deleted, its contents are saved.  This allows the</span><br><span class="line">       user to ask for its undeletion.  Note: please make sure to read  the  bugs  and  limitations</span><br><span class="line">       section at the end of this document.</span><br></pre></td></tr></table></figure>
<p>注意1：属性设置常见的是 a 与 i 的设置值，而且很多设置值必须要身为 root 才能设置 </p>
<p>注意2：xfs 文件系统仅支持 AadiS 而已 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">范例：请尝试到/tmp下面创建文件，并加入 i 的参数，尝试删除看看。 </span><br><span class="line">[root@study ~]# cd /tmp </span><br><span class="line">[root@study tmp]# touch attrtest &lt;==创建一个空文件 </span><br><span class="line">[root@study tmp]# chattr +i attrtest &lt;==给予 i 的属性 </span><br><span class="line">[root@study tmp]# rm attrtest &lt;==尝试删除看看 </span><br><span class="line"></span><br><span class="line">rm: remove regular empty file `attrtest&#x27;? y</span><br><span class="line">rm: cannot remove `attrtest&#x27;: Operation not permitted </span><br><span class="line"></span><br><span class="line">看到了吗？呼呼！连 root 也没有办法将这个文件删除呢！赶紧解除设置！ </span><br><span class="line"></span><br><span class="line">范例：请将该文件的 i 属性取消！</span><br><span class="line">[root@study tmp]# chattr -i attrtest</span><br></pre></td></tr></table></figure>
</li>
<li><p>lsattr 显示文件隐藏属性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@study ~]# lsattr [-adR] 文件或目录</span><br><span class="line">选项与参数：</span><br><span class="line">-a ：将隐藏文件的属性也秀出来；</span><br><span class="line">-d ：如果接的是目录，仅列出目录本身的属性而非目录内的文件名；</span><br><span class="line">-R ：连同子目录的数据也一并列出来！</span><br><span class="line">[root@study tmp]# chattr +aiS attrtest</span><br><span class="line">[root@study tmp]# lsattr attrtest</span><br><span class="line">--S-ia---------- attrtest</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>设置chattr后，可以使用lsattr查看隐藏属性，请小心使用这两个命令，特别是chattr。一个例子，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chattr +i /etc/shadow</span><br></pre></td></tr></table></figure>

<p>则将无法增加新用户。</p>
<p>该篇参考：鸟哥的Linux私房菜 基础学习篇 第四版 p322</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>chattr</tag>
        <tag>lasttr</tag>
      </tags>
  </entry>
  <entry>
    <title>查看内存消耗排序情况</title>
    <url>/2019/12/21/linux-memory/</url>
    <content><![CDATA[<p>在终端运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -aux | sort -k4nr | head -n 25</span><br></pre></td></tr></table></figure>

<p>查看占用内存从大到小的25个进程</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux端口占用情况查询与释放端口</title>
    <url>/2019/12/21/linux-port/</url>
    <content><![CDATA[<p>查询特定端口占用情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ip-172-26-1-96:/<span class="comment"># netstat -ntulp | grep 8080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcp        0      0 127.0.0.1:8080          0.0.0.0:*               LISTEN      5759/filebrowser</span><br></pre></td></tr></table></figure>

<p>结果最后一位分别是进程id/进程名，使用如下方法杀死进程：</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ip-172-26-1-96:/<span class="comment"># kill 5759</span></span><br></pre></td></tr></table></figure>

<p>再次查看端口得到释放</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ip-172-26-1-96:/<span class="comment"># netstat -ntulp | grep 8080</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>port</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件和目录的默认权限和特殊权限</title>
    <url>/2021/03/17/linux-hidden-authority/</url>
    <content><![CDATA[<p>对于 Linux 用户而言，当创建文件或目录时都会自动为该文件或目录分配权限，该权限就是默认权限。对于 Linux 文件和目录，除了具有默认权限外，还有特殊权限。默认权限和特殊权限在使用 Linux 系统时非常重要，特别是和团队开发时尤为重要。本篇就介绍一下如何查看和设置默认权限和特殊权限。以 Ubuntu 20.04 为例进行介绍。</p>
<a id="more"></a>

<h1 id="文件默认权限：umask"><a href="#文件默认权限：umask" class="headerlink" title="文件默认权限：umask"></a>文件默认权限：<strong>umask</strong></h1><p>查看用户的默认权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">umask</span></span><br><span class="line">002</span><br><span class="line">➜  ~ <span class="built_in">umask</span> -S</span><br><span class="line">u=rwx,g=rwx,o=rx</span><br></pre></td></tr></table></figure>

<p>以 umask 显示的是数字，加上参数 -S (Symbolic) 显示的是字符。含义解释：文件权限有 r, w, x 三个，分别对应数字 4， 2， 1，002 表示创建文件、目录时剔除 w 写权限。如 umask -S 显示的是创建目录时的默认权限，从上面命令可以看到其他用户 o 缺少 w 写权限。值得注意的是，文件默认是没有可执行权限 x 的。即文件的默认最高权限是 -rw-rw-rw-，目录的默认最高权限是 drwxrwxrwx，因此，剔除 w 写权限时，用户新创建的文件的默认权限是 -rw-rw-r–，新创建的目录的默认权限是 drwxrwxr-x，如下示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ touch test1</span><br><span class="line">➜  ~ mkdir test2</span><br><span class="line">➜  ~ ls -ld <span class="built_in">test</span>[12]  <span class="comment"># -d 表示只显示目录本身，不显示它里面包含的内容；中括号表示中间有个指定的字符，而不是任意字符，任意字符用 *</span></span><br><span class="line">-rw-rw-r-- 1 jinzhongxu jinzhongxu    0 3月  17 15:30 test1</span><br><span class="line">drwxrwxr-x 2 jinzhongxu jinzhongxu 4096 3月  17 15:30 test2</span><br></pre></td></tr></table></figure>

<p>如何修改用户的默认权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果想要用户创建的新文件或目录的群组和其他人没有写权限，可以设置如下，即剔除用户的写权限</span></span><br><span class="line"><span class="built_in">umask</span> 022</span><br></pre></td></tr></table></figure>

<h1 id="文件特殊权限：SUID-SGID-SBIT"><a href="#文件特殊权限：SUID-SGID-SBIT" class="headerlink" title="文件特殊权限：SUID, SGID, SBIT"></a>文件特殊权限：<strong>SUID, SGID, SBIT</strong></h1><p>对于 Linux 系统中有一个目录 /tmp 它的权限如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ ls -ld /tmp</span><br><span class="line">drwxrwxrwt 12 root root 4096 3月  17 15:05 /tmp</span><br></pre></td></tr></table></figure>

<p>可以看到它的权限中有一个 t，熟悉该目录的人应该知道，/tmp 目录下我们可以自由创建内容，也可以查看别人在该目录下创建的文件和目录，但是，我们不能删除别人创建的文件和目录。同时，别人也不能删除我们自己创建的文件和目录。这一切都要归功于特殊权限。</p>
<p>​    又如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ ls -l /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x 1 root root 68208 5月  28  2020 /usr/bin/passwd</span><br><span class="line">➜  ~ ls -l /etc/shadow</span><br><span class="line">-rw-r----- 1 root shadow 1229 3月  14 21:38 /etc/shadow</span><br></pre></td></tr></table></figure>

<p>在 /etc/shadow 中存储的是所有用户的密码，但只有 root 用户可以查看和修改。但是，有些人可能会疑惑了，明明自己可以修改自己用户的密码啊，使用 passwd 直接修改就可以了，不需要通知 root 进行修改。这是为什么呢？其实，这也要归功于 /usr/bin/passwd 可执行文件特殊权限 s，那么这些特殊权限符号代表什么含义呢，如何进行设置呢？比如，使用 iftop 命令需要输入密码，如何不输入密码直接使用呢？</p>
<h2 id="Set-UID"><a href="#Set-UID" class="headerlink" title="Set UID"></a>Set UID</h2><p>当 s 出现在文件拥有者的 x 权限上时，称为 Set UID，简称为 SUID 的特殊权限。关于该特殊权限有如下几个特点：</p>
<ol>
<li>SUID 权限仅对二进制程序有效，如 passwd, iftop；</li>
<li>执行者对于该程序需要具有执行权限；</li>
<li>本权限仅在执行该程序的过程中有效；</li>
<li>执行者将具有该程序拥有者的权限；</li>
</ol>
<p>当普通用户使用 passwd 执行修改密码的时候，因为 passwd 拥有特殊权限，因此，普通用户能够使用该命令，且命令执行期间拥有 root 的权限修改 /etc/shadow 文件</p>
<h2 id="Set-GID"><a href="#Set-GID" class="headerlink" title="Set GID"></a>Set GID</h2><p>当 s 出现在群组的 x 上时，称为 Set GID，简称为 SGID，它有如下特点：</p>
<ol>
<li>SGID 对二进制程序有用；</li>
<li>程序执行者对于该程序来说，需具备 x 的权限；</li>
<li>执行者在执行的过程中将会获得该程序群组的支持；</li>
</ol>
<h2 id="Sticky-Bit"><a href="#Sticky-Bit" class="headerlink" title="Sticky Bit"></a>Sticky Bit</h2><p>与 Set UID 和 Set GID 不同，Sticky Bit 只针对目录有效。简称为 SBIT，其对目录的作用是：</p>
<ol>
<li>当使用者对于此目录具有 w, x 权限时，即具有写入的权限；</li>
<li>当使用者在该目录下创建文件或目录时，仅有自己与 root 才有权利删除该文件；</li>
</ol>
<p>举例来说，我们的 /tmp 本身的权限是 drwxrwxrwt， 在这样的权限内容下，任何人都可以在 /tmp 内新增、修改文件，但仅有该文件/目录创建者与 root 能够删除自己的目录或文件。</p>
<h2 id="设置特殊权限"><a href="#设置特殊权限" class="headerlink" title="设置特殊权限"></a>设置特殊权限</h2><p>和读写执行一样，特殊权限也对应有数字：</p>
<ul>
<li>4 为 SUID</li>
<li>2 为 SGID</li>
<li>1 为 SBIT</li>
</ul>
<p>如下示例进行特殊权限设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ touch <span class="built_in">test</span></span><br><span class="line">➜  ~ ls -l <span class="built_in">test</span></span><br><span class="line">-rw-rw-r-- 1 jinzhongxu jinzhongxu 0 3月  17 16:02 <span class="built_in">test</span></span><br><span class="line">➜  ~ chmod 4664 <span class="built_in">test</span></span><br><span class="line">➜  ~ ls -l <span class="built_in">test</span></span><br><span class="line">-rwSrw-r-- 1 jinzhongxu jinzhongxu 0 3月  17 16:02 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>我们发现出现的是大 S，而不是小 s，这是为什么呢？因为文件 test 本身缺乏 x 可执行权限，所以增加特殊权限也为无法执行该文件，大 S 表示空，即无用的特殊权限。想要使用有用的特殊权限，需要我们的文件本身具有执行权限，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ chmod +x <span class="built_in">test</span></span><br><span class="line">➜  ~ ls -l <span class="built_in">test</span></span><br><span class="line">-rwsrwxr-x 1 jinzhongxu jinzhongxu 0 3月  17 16:02 <span class="built_in">test</span></span><br><span class="line">➜  ~ chmod 6775 <span class="built_in">test</span></span><br><span class="line">➜  ~ ls -l <span class="built_in">test</span></span><br><span class="line">-rwsrwsr-x 1 jinzhongxu jinzhongxu 0 3月  17 16:02 <span class="built_in">test</span></span><br><span class="line">➜  ~ chmod u+s,g+s,o+t <span class="built_in">test</span></span><br><span class="line">➜  ~ ls -l <span class="built_in">test</span></span><br><span class="line">-rwsrwsr-t 1 jinzhongxu jinzhongxu 0 3月  17 16:02 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>可见这样就给文件附加了特殊权限。</p>
<p>再比如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 4755 /usr/sbin/iftop</span><br><span class="line">ll /usr/sbin/iftop</span><br><span class="line">	-rwsr-xr-x 1 root root 68408 9月   5  2019 /usr/sbin/iftop*</span><br></pre></td></tr></table></figure>

<p>这样普通用户就不需要输入密码就可以使用命令 iftop 了。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>鸟哥的 LINUX 私房菜 基础学习篇（第四版）</p>
]]></content>
      <categories>
        <category>technology</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 端口占用与释放</title>
    <url>/2020/07/21/linux-port-occupation/</url>
    <content><![CDATA[<p>Linux 端口占用会导致某些想使用该端口运行的程序无法成功，比如，启动Zookeeper时默认2181端口占用，这时候除了修改配置文件的端口号外，也可以将Linux服务器的端口释放掉供Zookeeper使用。下面介绍，如何查看端口释放被占用以及如何释放端口，一般查看端口占用有两个命令可以使用，分别是 lsof 和 netstat 命令，释放端口除了正常关闭占用端口的程序外就是直接 kill 掉占用端口的程序 pid</p>
<a id="more"></a>

<h1 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h1><h2 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h2><p>lsof(list open files)是一个列出当前系统打开文件的工具。</p>
<p>lsof 查看端口占用语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -i:port</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line">lsof -i:2181</span><br></pre></td></tr></table></figure>

<p>其他更多用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsof -i:8080：查看8080端口占用</span><br><span class="line">lsof abc.txt：显示开启文件abc.txt的进程</span><br><span class="line">lsof -c abc：显示abc进程现在打开的文件</span><br><span class="line">lsof -c -p 1234：列出进程号为1234的进程所打开的文件</span><br><span class="line">lsof -g gid：显示归属gid的进程情况</span><br><span class="line">lsof +d &#x2F;usr&#x2F;local&#x2F;：显示目录下被进程开启的文件</span><br><span class="line">lsof +D &#x2F;usr&#x2F;local&#x2F;：同上，但是会搜索目录下的目录，时间较长</span><br><span class="line">lsof -d 4：显示使用fd为4的进程</span><br><span class="line">lsof -i -U：显示所有打开的端口和UNIX domain文件</span><br></pre></td></tr></table></figure>

<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p><strong>netstat -tunlp</strong> 用于显示 tcp，udp 的端口和进程等相关情况</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">-t (tcp) 仅显示tcp相关选项</span><br><span class="line">-u (udp)仅显示udp相关选项</span><br><span class="line">-n 拒绝显示别名，能显示数字的全部转化为数字</span><br><span class="line">-l 仅列出在Listen(监听)的服务状态</span><br><span class="line">-p 显示建立相关链接的程序名</span><br></pre></td></tr></table></figure>

<p>netstat 查看端口占用语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -tunlp | grep port</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line">netstat -tunlp | grep 2181</span><br></pre></td></tr></table></figure>

<h1 id="释放端口占用"><a href="#释放端口占用" class="headerlink" title="释放端口占用"></a>释放端口占用</h1><h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>在查到端口占用的进程后，如果你要杀掉对应的进程可以使用 kill 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> PID</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者当无法杀掉时，强制杀掉</span></span><br><span class="line"><span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></table></figure>

<p>像一些大数据框架服务，如Zookeeper, Kafka, Flink, Storm等，可以使用命令 jps 查看相应的 pid</p>
<h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p>本篇参考：<a href="https://www.runoob.com/w3cnote/linux-check-port-usage.html">Linux 查看端口占用情况</a></p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>port</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 系统的运行级别及设置</title>
    <url>/2021/04/02/linux-runlevel-setting/</url>
    <content><![CDATA[<p>Linux 系统默认有多种运行级别，如 Ubuntu 系统有 7 种运行级别，通过设置不同的运行级别，可以对计算机进行访问控制（如单用户模式，多用户模式等）、关机、重启、关闭图形界面、打开图形界面等。下面分别对这些运行级别进行介绍，并给出如何使用，如关闭图形界面，节省计算资源。</p>
<a id="more"></a>

<h1 id="runlevel"><a href="#runlevel" class="headerlink" title="runlevel"></a>runlevel</h1><p>查看当前计算机的运行级别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ runlevel</span><br><span class="line">N 3</span><br><span class="line"><span class="comment"># 运行级别是 3，说明是多用户控制台模式</span></span><br></pre></td></tr></table></figure>

<p>通过命令可以查看各个运行级别信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ man runlevel</span><br><span class="line">Table 1. Mapping between runlevels and systemd targets</span><br><span class="line">       ┌─────────┬───────────────────┐</span><br><span class="line">       │Runlevel │ Target            │</span><br><span class="line">       ├─────────┼───────────────────┤</span><br><span class="line">       │0        │ poweroff.target   │</span><br><span class="line">       ├─────────┼───────────────────┤</span><br><span class="line">       │1        │ rescue.target     │</span><br><span class="line">       ├─────────┼───────────────────┤</span><br><span class="line">       │2, 3, 4  │ multi-user.target │</span><br><span class="line">       ├─────────┼───────────────────┤</span><br><span class="line">       │5        │ graphical.target  │</span><br><span class="line">       ├─────────┼───────────────────┤</span><br><span class="line">       │6        │ reboot.target     │</span><br><span class="line">       └─────────┴───────────────────┘</span><br></pre></td></tr></table></figure>

<ul>
<li><p>运行级别 0：系统停机状态，系统默认运行级别不要设为 0，否则不能正常启动；</p>
</li>
<li><p>运行级别 1：单用户工作状态，具有 root 权限，用于系统维护，禁止远程登陆；</p>
</li>
<li><p>运行级别 2：多用户状态 ( 没有NFS，不能联网 )；</p>
</li>
<li><p>运行级别 3：完全的多用户状态 ( 有 NFS，能联网 )，登陆后进入控制台命令行模式；</p>
</li>
<li><p>运行级别 4：系统未使用，保留；</p>
</li>
<li><p>运行级别 5：X11 控制台，登陆后进入图形 GUI 模式；</p>
</li>
<li><p>运行级别 6：系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动；</p>
</li>
</ul>
<p>因此，普通用户一般较多使用运行级别 5 或者 3.</p>
<h1 id="切换运行级别"><a href="#切换运行级别" class="headerlink" title="切换运行级别"></a>切换运行级别</h1><p>关闭计算机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">init 0</span><br></pre></td></tr></table></figure>

<p>重启计算机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">init 6</span><br></pre></td></tr></table></figure>

<p>查看默认启动级别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl get-default</span><br></pre></td></tr></table></figure>

<p>设置默认启动为多用户控制台模式 3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">set</span>-default multi-user.target</span><br></pre></td></tr></table></figure>

<p>从控制台模式切换到图形界面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不需要输入用户名和密码</span></span><br><span class="line">startx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要输入用户名和密码</span></span><br><span class="line">systemctl isolate graphical.target  <span class="comment"># 可以通过systemctl isolate multi-user.target再切换回命令行模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要输入用户名和密码</span></span><br><span class="line">init 5   <span class="comment">#可以通过 init 3 再切换回命令行模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 快捷键方法</span></span><br><span class="line">可使用 Ctrl + Alt + F1~6 进行切换，Ctrl + Alt + 1 为图形界面</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/25816300">Linux系统7个运行级别(runlevel)详解</a></li>
<li><a href="https://blog.csdn.net/liu1055087125/article/details/48381007">Linux 的Run level介绍</a></li>
<li><a href="https://blog.csdn.net/yiifaa/article/details/77266951">Linux(一)：运行级别查询及切换</a></li>
<li><a href="https://blog.csdn.net/qq_21453783/article/details/100251461">Linux运行级别及切换方法</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件按大小或时间排序</title>
    <url>/2019/12/20/linux-sort-file/</url>
    <content><![CDATA[<h2 id="1-查看-Linux-某一个文件夹下所有文件，并按从新到旧的时间排序："><a href="#1-查看-Linux-某一个文件夹下所有文件，并按从新到旧的时间排序：" class="headerlink" title="1, 查看 Linux 某一个文件夹下所有文件，并按从新到旧的时间排序："></a>1, 查看 Linux 某一个文件夹下所有文件，并按从新到旧的时间排序：</h2><a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -tl</span><br></pre></td></tr></table></figure>


<h2 id="2-从旧到新的时间排序："><a href="#2-从旧到新的时间排序：" class="headerlink" title="2, 从旧到新的时间排序："></a>2, 从旧到新的时间排序：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -tlr</span><br></pre></td></tr></table></figure>


<h2 id="3-查看-Linux-某一个文件夹下所有文件，并按文件大小从大到小排序"><a href="#3-查看-Linux-某一个文件夹下所有文件，并按文件大小从大到小排序" class="headerlink" title="3, 查看 Linux 某一个文件夹下所有文件，并按文件大小从大到小排序:"></a>3, 查看 Linux 某一个文件夹下所有文件，并按文件大小从大到小排序:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对于子文件夹，则只有文件夹的大小，不会计算整个子文件夹下所有文件的大小</span></span><br><span class="line">ls -Sl</span><br><span class="line">ls -Slh</span><br><span class="line"><span class="comment"># 同时会计算文件夹下子文件夹所有文件的大小，参与排序</span></span><br><span class="line">du -s * | sort -nr</span><br></pre></td></tr></table></figure>


<h2 id="4-从小到大排序："><a href="#4-从小到大排序：" class="headerlink" title="4, 从小到大排序："></a>4, 从小到大排序：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -Slr</span><br><span class="line">ls -Slhr</span><br><span class="line">du -s * | sort -n</span><br></pre></td></tr></table></figure>


<h2 id="5-查看最大的前几个文件"><a href="#5-查看最大的前几个文件" class="headerlink" title="5, 查看最大的前几个文件"></a>5, 查看最大的前几个文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">du -s * | sort -nr | head <span class="comment"># 默认前10个</span></span><br><span class="line">ls -Slh | head -n 3  <span class="comment"># 最大的3个</span></span><br><span class="line">du -s * | sort -n | tail</span><br></pre></td></tr></table></figure>


<h2 id="6-查看最小的几个个文件："><a href="#6-查看最小的几个个文件：" class="headerlink" title="6, 查看最小的几个个文件："></a>6, 查看最小的几个个文件：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">du -s * | sort -nr | tail <span class="comment"># 默认前10个</span></span><br><span class="line">ls -Slrh | head -n 3 <span class="comment"># 最小的3个</span></span><br><span class="line">du -s * | sort -n | head</span><br></pre></td></tr></table></figure>

<h2 id="7-查看根目录下所有文件的大小"><a href="#7-查看根目录下所有文件的大小" class="headerlink" title="7, 查看根目录下所有文件的大小"></a>7, 查看根目录下所有文件的大小</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 发现哪些文件夹占用磁盘比较多</span></span><br><span class="line">sudo du -h --max-depth=1 /</span><br><span class="line">df -h</span><br><span class="line"><span class="comment"># 不进入文件夹查看文件夹下文件的大小</span></span><br><span class="line">du -h --max-depth=1 archive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归查看文件夹下子文件夹的大小</span></span><br><span class="line">du -h archive</span><br><span class="line"><span class="comment"># 查看某一个文件夹下所有文件大小和</span></span><br><span class="line">du -h --max-depth=0 archive</span><br><span class="line">du -sh archive</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>linux</tag>
        <tag>ls</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Linux 上设置不同的语言和时区</title>
    <url>/2020/12/30/locale-linux-language/</url>
    <content><![CDATA[<p>Linux 系统语言的设置至关重要，当设置不匹配的语言时，严重影响使用的效率。如在系统上没有设置中文时，大多出现乱码、数字等情况，使得使用的体验感大幅下降。下面介绍在 Debian, CentOS 等系统上设置中文或其他语言的方法。本篇命令以 root 身份运行。</p>
<a id="more"></a>

<h1 id="Debian-类"><a href="#Debian-类" class="headerlink" title="Debian 类"></a>Debian 类</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install locale</span><br><span class="line">dpkg-reconfigure locales</span><br><span class="line"><span class="comment"># 使用空格选择相应的语言，使用上下键移动光标</span></span><br><span class="line"><span class="comment"># 选择好需要安装的语言后，使用 TAB 键切换到 ok</span></span><br><span class="line"><span class="comment"># 使用上下键选择默认的使用的语言</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装成功后，需重启系统</span></span><br><span class="line">shutdown -r now</span><br><span class="line"><span class="comment"># 使用下面命令查看是否生效</span></span><br><span class="line">locale</span><br><span class="line"><span class="comment"># 使用下面命令查看安装的语言</span></span><br><span class="line">locale -a</span><br></pre></td></tr></table></figure>

<p>设置时区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg-reconfigure tzdata</span><br></pre></td></tr></table></figure>



<h1 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum update</span><br><span class="line"><span class="comment"># 查看目前系统语言</span></span><br><span class="line">localectl status</span><br><span class="line"><span class="comment"># 或者通过如下命令也可以查看</span></span><br><span class="line">cat /etc/locale.conf</span><br><span class="line"><span class="comment"># 查看系统中安装了哪些语言</span></span><br><span class="line">localectl list-locales</span><br><span class="line"><span class="comment"># 查看系统中安装了哪些英文语言</span></span><br><span class="line">localectl list-locales | grep en_</span><br><span class="line"><span class="comment"># 设置默认语言为 en_GB.utf8</span></span><br><span class="line">localectl <span class="built_in">set</span>-locale LANG=en_GB.utf8</span><br><span class="line"><span class="comment"># 查看修改默认语言是否成功</span></span><br><span class="line">localectl status</span><br><span class="line"><span class="comment"># 更过使用帮助</span></span><br><span class="line">localectl --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p>设置时区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">timedatectl <span class="built_in">set</span>-timezone Asia/Shanghai</span><br><span class="line"><span class="comment"># 如何知道有那些时区可以设置，可以使用如下命令查看</span></span><br><span class="line">ls /usr/share/zoneinfo</span><br></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.rosehosting.com/blog/how-to-set-up-system-locale-on-centos-7/">How to Set Up System Locale on CentOS 7</a></p>
]]></content>
      <categories>
        <category>technology</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>debian</tag>
        <tag>locale</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 和 Ubuntu 查看网卡 Mac 地址和硬盘序列号的方法</title>
    <url>/2020/06/12/mac-addr-and-serial-number/</url>
    <content><![CDATA[<h1 id="Windows-系统"><a href="#Windows-系统" class="headerlink" title="Windows 系统"></a>Windows 系统</h1><h2 id="Windows-系统查看网卡的-Mac-地址方法"><a href="#Windows-系统查看网卡的-Mac-地址方法" class="headerlink" title="Windows 系统查看网卡的 Mac 地址方法"></a>Windows 系统查看网卡的 Mac 地址方法</h2><p>打开 CMD，输入</p>
<a id="more"></a>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure>

<p>找到物理地址</p>
<h2 id="Windows-系统查看硬盘序列号的方法"><a href="#Windows-系统查看硬盘序列号的方法" class="headerlink" title="Windows 系统查看硬盘序列号的方法"></a>Windows 系统查看硬盘序列号的方法</h2><p>打开 CMD，输入</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wmic diskdrive get serialnumber</span><br></pre></td></tr></table></figure>

<p>查看序列号</p>
<h2 id="Windows-系统初始安装日期"><a href="#Windows-系统初始安装日期" class="headerlink" title="Windows 系统初始安装日期"></a>Windows 系统初始安装日期</h2><p>Win + r 打开运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmd /k systeminfo | find <span class="string">&quot;初始安装日期&quot;</span></span><br></pre></td></tr></table></figure>



<h1 id="Ubuntu-系统"><a href="#Ubuntu-系统" class="headerlink" title="Ubuntu 系统"></a>Ubuntu 系统</h1><h2 id="Ubuntu-系统查看网卡的-Mac-地址方法"><a href="#Ubuntu-系统查看网卡的-Mac-地址方法" class="headerlink" title="Ubuntu 系统查看网卡的 Mac 地址方法"></a>Ubuntu 系统查看网卡的 Mac 地址方法</h2><p>打开终端，输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<p>找到所使用网卡的 ether</p>
<p>或者直接输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo lshw -c network | grep serial | head -n 1</span><br></pre></td></tr></table></figure>

<p>获得正在使用的网卡的 Mac 地址</p>
<h2 id="Ubuntu-系统查看硬盘的序列号"><a href="#Ubuntu-系统查看硬盘的序列号" class="headerlink" title="Ubuntu 系统查看硬盘的序列号"></a>Ubuntu 系统查看硬盘的序列号</h2><p>在 Ubuntu 桌面版中，搜索 disk，打开，找到所使用硬盘的 Serial Number</p>
<h2 id="Ubuntu-系统查看初始安装日期"><a href="#Ubuntu-系统查看初始安装日期" class="headerlink" title="Ubuntu 系统查看初始安装日期"></a>Ubuntu 系统查看初始安装日期</h2><p>打开终端，输入如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tune2fs -l /dev/sda1 | grep create</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>使用命令行更改苹果电脑的 hostname</title>
    <url>/2021/12/12/mac-book-pro-change-hostname/</url>
    <content><![CDATA[<p>更改苹果电脑名称可在系统便好设置里的共享编辑更改，但重启后终端上却没有发生变化，这篇介绍 Mac Book Pro 更改终端 hostname 方法。</p>
<a id="more"></a>

<p>打开终端，运行如下命令，其中 <code>newhostname</code>为你想设置的新名字。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scutil --<span class="built_in">set</span> ComputerName <span class="string">&quot;newhostname&quot;</span></span><br><span class="line">scutil --<span class="built_in">set</span> LocalHostName <span class="string">&quot;newhostname&quot;</span></span><br><span class="line">scutil --<span class="built_in">set</span> HostName <span class="string">&quot;newhostname&quot;</span></span><br></pre></td></tr></table></figure>

<p>查看设置后的名字。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scutil --get HostName</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">hostname</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mbp</tag>
        <tag>hostname</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 系统下 usr 目录由来</title>
    <url>/2020/12/09/linux-usr-history/</url>
    <content><![CDATA[<p>在 Linux（或Unix） 系统下，存放二进制文件的目录一般用 bin 表示，如 /bin, /usr/bin, /usr/local/bin, /opt/bin 等等，它们有什么区别？</p>
<a id="more"></a>

<p>在文章: <a href="http://lists.busybox.net/pipermail/busybox/2010-December/074114.html">Understanding the bin, sbin, usr/bin , usr/sbin split</a> 中可以知道，Linux 目录结构是历史造成的。</p>
<p>1969年，Ken Thompson 和 Dennis Ritchie 在小型机 PDP-7上发明了 Unix。1971年，他们将主机升级到 PDP-11。当时使用的存储盘 RK05 容量大约是1.5MB，随着使用，根目录（/）下的操作系统越来越大，无法装下。于是增加了第二张盘 RK05，专门储存用户（user）程序，取名挂载点为 /usr，两张盘的结构完全一样，如在第一张盘或根目录下的 /bin, /sbin, /lib, /tmp… 在第二张盘 /usr 目录下也有。但是，随着时间继续，储存的程序越来越多，就需要第三张盘，取名挂载点 /home，用于储存 /usr 里面用户的数据。</p>
<p>随着系统的发展，各个目录的含义进一步明确：</p>
<ol>
<li>/：存放系统程序，也就是 At&amp;t 开发的 Unix 程序。</li>
</ol>
<p>　2. /usr：存放 Unix 系统商（比如 IBM 和 HP ）开发的程序。</p>
<p>　3. /usr/local：存放用户自己安装的程序。</p>
<p>　4. /opt：在某些系统，用于存放第三方厂商开发的程序，所以取名为 option，意为”选装”。</p>
<p>参考链接：</p>
<ol>
<li><a href="http://www.ruanyifeng.com/blog/2012/02/a_history_of_unix_directory_structure.html">Unix目录结构的来历</a></li>
<li><a href="http://lists.busybox.net/pipermail/busybox/2010-December/074114.html">Understanding the bin, sbin, usr/bin , usr/sbin split</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>usr</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 终端显示配置</title>
    <url>/2019/12/20/linux-terminal-color/</url>
    <content><![CDATA[<p>Linux 终端配置成比较突出的颜色，有助于快速定位和美化终端，下面是配置个人比较喜欢的终端显示的方法，以Ubuntu为例：</p>
<a id="more"></a>

<h2 id="1-打开终端配置文件"><a href="#1-打开终端配置文件" class="headerlink" title="1, 打开终端配置文件"></a>1, 打开终端配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure>
<h2 id="2-把一下代码追加到文件中"><a href="#2-把一下代码追加到文件中" class="headerlink" title="2, 把一下代码追加到文件中"></a>2, 把一下代码追加到文件中</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PS1=<span class="string">&quot;\[\033[36m\]\u\[\033[m\]@\[\033[32m\]\h:\[\033[33;1m\]\w\[\033[m\]\$ &quot;</span></span><br><span class="line"><span class="built_in">export</span> CLICOLOR=1</span><br><span class="line"><span class="built_in">export</span> LSCOLORS=ExFxBxDxCxegedabagacad</span><br></pre></td></tr></table></figure>
<h2 id="3-保存文件，并运行如下代码使设置生效"><a href="#3-保存文件，并运行如下代码使设置生效" class="headerlink" title="3, 保存文件，并运行如下代码使设置生效"></a>3, 保存文件，并运行如下代码使设置生效</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 上通过 launchctl 开启守护进程</title>
    <url>/2021/12/20/mac-launchctl-plist/</url>
    <content><![CDATA[<p>Linux 系统（如 Debian 10）上可以方便的使用 systemctl 开启守护进程，关闭守护进程，那么在 Mac 上如何设置自定义守护进程并开启、关闭它呢？本篇以 JupyterHub 为例，演示在 Mac 上开启 JupyterHub 守护进程. 本篇假设已经完成了 Miniconda，JupyterHub 和 configurable-http-proxy 的安装。</p>
<a id="more"></a>

<h1 id="创建-plist-文件"><a href="#创建-plist-文件" class="headerlink" title="创建 plist 文件"></a>创建 plist 文件</h1><p>创建以 <code>com.jupyterhub.app.plist</code> 命名的文件，放在 <code>/Users/jinzhongxu/Library/LaunchAgents</code> 目录下，文件内容如下</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC <span class="string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span><br><span class="line">&lt;plist version=<span class="string">&quot;1.0&quot;</span>&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;Label&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;com.jupyterhub.app&lt;/string&gt;</span><br><span class="line">        &lt;key&gt;ProgramArguments&lt;/key&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;string&gt;/usr/local/miniconda/bin/jupyterhub&lt;/string&gt;</span><br><span class="line">            &lt;string&gt;-f&lt;/string&gt;</span><br><span class="line">            &lt;string&gt;/etc/jupyterhub/config.py&lt;/string&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">        &lt;key&gt;KeepAlive&lt;/key&gt;</span><br><span class="line">        &lt;true/&gt;</span><br><span class="line">        &lt;key&gt;StandardErrorPath&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;/tmp/jupyterhuberr.log&lt;/string&gt;</span><br><span class="line">        &lt;key&gt;StandardOutPath&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;/tmp/jupyterhubout.log&lt;/string&gt;</span><br><span class="line">        &lt;key&gt;EnvironmentVariables&lt;/key&gt;</span><br><span class="line">        &lt;dict&gt;</span><br><span class="line">          &lt;key&gt;PATH&lt;/key&gt;</span><br><span class="line">            &lt;string&gt;&lt;![CDATA[/usr/local/bin:/usr/bin:/bin:/usr/local/miniconda/bin:/usr/local/node/bin]]&gt;&lt;/string&gt;</span><br><span class="line">        &lt;/dict&gt;</span><br><span class="line">		&lt;key&gt;WorkingDirectory&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;/Users/jinzhongxu&lt;/string&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure>

<p>各条目解释：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Label：对应的需要保证全局唯一性;</span><br><span class="line">Program：要运行的程序;</span><br><span class="line">ProgramArguments：命令语句;</span><br><span class="line">StartCalendarInterval：运行的时间，单个时间点使用dict，多个时间点使用 array &lt;dict&gt;;</span><br><span class="line">StartInterval：时间间隔，与StartCalendarInterval使用其一，单位为秒;</span><br><span class="line">StandardInPath、StandardOutPath、StandardErrorPath：标准的输入输出错误文件，这里建议不要使用 .<span class="built_in">log</span> 作为后缀，会打不开里面的信息;</span><br><span class="line">定时启动任务时，如果涉及到网络，但是电脑处于睡眠状态，是执行不了的，这个时候，可以定时的启动屏幕就好了。</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>configurable-http-proxy 的路径需添加到 PATH 里面；</li>
<li>WorkingDirectory 需指定用户能够创建 jupyterhub_cookie_secret 的地方；</li>
<li>如果启动不成功，可通过 jupyterhuberr.log 查看原因。</li>
</ol>
<p>plist 可以放的目录包括</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/Library/LaunchAgents 由用户自己定义的任务项</span><br><span class="line">/Library/LaunchAgents 由管理员为用户定义的任务项</span><br><span class="line">/Library/LaunchDaemons 由管理员定义的守护进程任务项</span><br><span class="line">/System/Library/LaunchAgents 由 Mac 为用户定义的任务项</span><br><span class="line">/System/Library/LaunchDaemons 由 Mac 定义的守护进程任务项</span><br><span class="line"></span><br><span class="line">/System/Library 与 /Library 以及 ~/Library 目录的区别？</span><br><span class="line">/System/Library 目录是存放 Apple 自己开发的软件。</span><br><span class="line">/Library 目录是系统管理员存放的第三方软件。</span><br><span class="line">~/Library 是用户自己存放的第三方软件。</span><br><span class="line"></span><br><span class="line">LaunchDaemons 和 LaunchAgents 的区别？</span><br><span class="line">LaunchDaemons 是用户未登陆前就启动的服务（守护进程）。</span><br><span class="line">LaunchAgents 是用户登陆后启动的服务（守护进程）。</span><br></pre></td></tr></table></figure>

<h1 id="开启守护进程"><a href="#开启守护进程" class="headerlink" title="开启守护进程"></a>开启守护进程</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span></span><br><span class="line">launchctl load Library/LaunchAgents/com.jupyterhub.app.plist</span><br></pre></td></tr></table></figure>

<h1 id="关闭守护进程"><a href="#关闭守护进程" class="headerlink" title="关闭守护进程"></a>关闭守护进程</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span></span><br><span class="line">launchctl unload Library/LaunchAgents/com.jupyterhub.app.plist</span><br></pre></td></tr></table></figure>

<h1 id="查看守护进程是否启动成功"><a href="#查看守护进程是否启动成功" class="headerlink" title="查看守护进程是否启动成功"></a>查看守护进程是否启动成功</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">launchctl list | grep jupyterhub</span><br><span class="line">pstree | grep jupyterhub</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://www.jianshu.com/p/b65c1d339eec">Mac执行定时任务之Launchctl</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>launchctl</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 上安装使用 MySQL</title>
    <url>/2021/05/03/mac-mysql/</url>
    <content><![CDATA[<p>如何在 Mac （option + shift + k） 上安装使用 MySQL？这篇介绍在 Mac 上借助 Terminal 安装并使用 MySQL.</p>
<a id="more"></a>

<h1 id="下载-MySQL"><a href="#下载-MySQL" class="headerlink" title="下载 MySQL"></a>下载 MySQL</h1><p>官网下载地址：<a href="https://dev.mysql.com/downloads/mysql/">MySQL Community Downloads</a></p>
<p>我这里选择 <strong>macOS 11 (x86, 64-bit), Compressed TAR Archive</strong>，该压缩文件比较小，下载较快。</p>
<p>下载后是 mysql-8.0.24-macos11-x86_64.tar.gz</p>
<h1 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzf mysql-8.0.24-macos11-x86_64.tar.gz</span><br><span class="line">mv mysql-8.0.24-macos11-x86_64 /usr/<span class="built_in">local</span>/mysql</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化，注意保存初始化密码。</span></span><br><span class="line"><span class="comment"># 再注意，如果第一次打开从网上下载该软件，需要在设置隐私中允许该软件运行</span></span><br><span class="line"><span class="comment"># 如果出错，可以删除mysql目录下的data文件夹</span></span><br><span class="line">sudo bin/mysqld --initialize --user=jinzhongxu</span><br><span class="line"><span class="comment"># 查看 mysql 服务状态</span></span><br><span class="line">sudo ./support-files/mysql.server status</span><br><span class="line">sudo ./support-files/mysql.server start</span><br><span class="line">sudo ./support-files/mysql.server stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加到环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:/usr/local/mysql/bin&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更换新密码，需要输入上面产生的初始化密码</span></span><br><span class="line">mysqladmin -u root -p password xxx.yyy</span><br></pre></td></tr></table></figure>

<h1 id="使用-MySQL"><a href="#使用-MySQL" class="headerlink" title="使用 MySQL"></a>使用 MySQL</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入上面设置的密码 xxx.yyy</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line">mysql&gt; <span class="built_in">exit</span></span><br><span class="line">Bye</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置新用户</span></span><br><span class="line">$ mysql -u root -p      </span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 52</span><br><span class="line">Server version: 8.0.24 MySQL Community Server - GPL</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2021, Oracle and/or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE USER <span class="string">&#x27;jinzhongxu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;xxx.zzz&#x27;</span>;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON * . * TO <span class="string">&#x27;jinzhongxu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="built_in">exit</span></span><br><span class="line">Bye</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新数据库和新表，并添加数据</span></span><br><span class="line">$ mysql -u jinzhongxu -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 53</span><br><span class="line">Server version: 8.0.24 MySQL Community Server - GPL</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2021, Oracle and/or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| <span class="built_in">test</span>               |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE DATABASE pytest;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| pytest             |</span><br><span class="line">| sys                |</span><br><span class="line">| <span class="built_in">test</span>               |</span><br><span class="line">+--------------------+</span><br><span class="line">6 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; USE pytest;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; CREATE TABLE user (id VARCHAR(20) primary key, name VARCHAR(20));</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO user (id, name) VALUES (<span class="string">&quot;1&quot;</span>, <span class="string">&quot;JinzhongXu&quot;</span>);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM user WHERE id = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">+----+------------+</span><br><span class="line">| id | name       |</span><br><span class="line">+----+------------+</span><br><span class="line">| 1  | JinzhongXu |</span><br><span class="line">+----+------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="built_in">exit</span></span><br><span class="line">Bye</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 登陆数据库时直接进入指定数据库 pytest</span></span><br><span class="line">$ mysql -h localhost  -u jinzhongxu -p pytest</span><br><span class="line">Enter password: </span><br><span class="line">Reading table information <span class="keyword">for</span> completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 54</span><br><span class="line">Server version: 8.0.24 MySQL Community Server - GPL</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2021, Oracle and/or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW TABLES;</span><br><span class="line">+------------------+</span><br><span class="line">| Tables_in_pytest |</span><br><span class="line">+------------------+</span><br><span class="line">| USER             |</span><br><span class="line">+------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO user (id, name) VALUES (<span class="string">&quot;2&quot;</span>, <span class="string">&quot;WJL&quot;</span>);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM user WHERE id &gt;= <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">+----+------------+</span><br><span class="line">| id | name       |</span><br><span class="line">+----+------------+</span><br><span class="line">| 1  | JinzhongXu |</span><br><span class="line">| 2  | WJL        |</span><br><span class="line">+----+------------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="built_in">exit</span></span><br><span class="line">Bye</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看用户权限</span></span><br><span class="line">$ mysql -u jinzhongxu -p                     </span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 55</span><br><span class="line">Server version: 8.0.24 MySQL Community Server - GPL</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2021, Oracle and/or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW GRANTS FOR <span class="string">&#x27;jinzhongxu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line">+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Grants <span class="keyword">for</span> jinzhongxu@localhost                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |</span><br><span class="line">+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, RELOAD, SHUTDOWN, PROCESS, FILE, REFERENCES, INDEX, ALTER, SHOW DATABASES, SUPER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, REPLICATION SLAVE, REPLICATION CLIENT, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, CREATE USER, EVENT, TRIGGER, CREATE TABLESPACE, CREATE ROLE, DROP ROLE ON *.* TO `jinzhongxu`@`localhost`                                                                                                                                                                                                                    |</span><br><span class="line">| GRANT APPLICATION_PASSWORD_ADMIN,AUDIT_ADMIN,BACKUP_ADMIN,BINLOG_ADMIN,BINLOG_ENCRYPTION_ADMIN,CLONE_ADMIN,CONNECTION_ADMIN,ENCRYPTION_KEY_ADMIN,FLUSH_OPTIMIZER_COSTS,FLUSH_STATUS,FLUSH_TABLES,FLUSH_USER_RESOURCES,GROUP_REPLICATION_ADMIN,INNODB_REDO_LOG_ARCHIVE,INNODB_REDO_LOG_ENABLE,PERSIST_RO_VARIABLES_ADMIN,REPLICATION_APPLIER,REPLICATION_SLAVE_ADMIN,RESOURCE_GROUP_ADMIN,RESOURCE_GROUP_USER,ROLE_ADMIN,SERVICE_CONNECTION_ADMIN,SESSION_VARIABLES_ADMIN,SET_USER_ID,SHOW_ROUTINE,SYSTEM_USER,SYSTEM_VARIABLES_ADMIN,TABLE_ENCRYPTION_ADMIN,XA_RECOVER_ADMIN ON *.* TO `jinzhongxu`@`localhost` |</span><br><span class="line">+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; quit;</span><br><span class="line">Bye</span><br><span class="line">(base) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他常用命令</span></span><br><span class="line"><span class="comment"># 更改用户密码</span></span><br><span class="line">mysqladmin -u jinzhongxu -p password com.xxx</span><br><span class="line"><span class="comment"># 删除用户</span></span><br><span class="line">mysql&gt; DROP USER <span class="string">&#x27;jinzhongxu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="comment"># 删除数据库</span></span><br><span class="line">mysql&gt; DROP DATABASE pytest;</span><br></pre></td></tr></table></figure>

<h1 id="重启-MySQL-SERVER"><a href="#重启-MySQL-SERVER" class="headerlink" title="重启 MySQL SERVER"></a>重启 MySQL SERVER</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里不用sudo，使用sudo报错：The server quit without updating PID file</span></span><br><span class="line">/usr/<span class="built_in">local</span>/mysql/support-files/mysql.server restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:/usr/local/mysql/support-files&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加环境变量后启动 mysql server</span></span><br><span class="line">mysql.server status</span><br><span class="line">mysql.server start</span><br><span class="line">mysql.server restart</span><br></pre></td></tr></table></figure>



<h1 id="Python-连接-MySQL-数据库"><a href="#Python-连接-MySQL-数据库" class="headerlink" title="Python 连接 MySQL 数据库"></a>Python 连接 MySQL 数据库</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装包</span></span><br><span class="line">pip install mysql-connector-python</span><br><span class="line">pip install sqlalchemy</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, String, create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysql_</span>(<span class="params">check_id, create_p=False, insert_p=False, ids=<span class="number">1</span>, name=<span class="string">&quot;JinzhongXu&quot;</span></span>):</span></span><br><span class="line">    conn = mysql.connector.connect(user=<span class="string">&#x27;jinzhongxu&#x27;</span>, host=<span class="string">&quot;localhost&quot;</span>, password=<span class="string">&#x27;yourpassword&#x27;</span>,</span><br><span class="line">                                   auth_plugin=<span class="string">&#x27;mysql_native_password&#x27;</span>,</span><br><span class="line">                                   database=<span class="string">&#x27;pytest&#x27;</span>)</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    <span class="comment"># 创建 table</span></span><br><span class="line">    <span class="keyword">if</span> create_p:</span><br><span class="line">        cursor.execute(<span class="string">&#x27;create table user (id varchar(20) primary key, name varchar(20))&#x27;</span>)</span><br><span class="line">    <span class="comment"># 添加数据</span></span><br><span class="line">    <span class="comment"># cursor.execute(&#x27;insert into user (id, name) values (%s, %s)&#x27;, [&#x27;1&#x27;, &#x27;JinzhongXu&#x27;])</span></span><br><span class="line">    <span class="keyword">if</span> insert_p:</span><br><span class="line">        cursor.execute(<span class="string">&#x27;insert into user (id, name) values (%s, %s)&#x27;</span>, [str(ids), name])</span><br><span class="line">    <span class="comment"># cursor.rowcount</span></span><br><span class="line">    conn.commit()</span><br><span class="line">    cursor.close()</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    cursor.execute(<span class="string">&#x27;select * from user where id = %s&#x27;</span>, (str(check_id),))</span><br><span class="line">    values = cursor.fetchall()</span><br><span class="line">    print(values)</span><br><span class="line">    cursor.close()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义User对象:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">declarative_base(<span class="params"></span>)</span>):</span></span><br><span class="line">    <span class="comment"># 表的名字:</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;user&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 表的结构:</span></span><br><span class="line">    id = Column(String(<span class="number">20</span>), primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">20</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqlalchemy_</span>(<span class="params">check_id, insert_p=False, ids=<span class="number">1</span>, name=<span class="string">&#x27;Jinzhongxu&#x27;</span></span>):</span></span><br><span class="line">    <span class="comment"># 初始化数据库连接:</span></span><br><span class="line">    engine = create_engine(<span class="string">&#x27;mysql+mysqlconnector://jinzhongxu:yourpassword@localhost:3306/pytest&#x27;</span>)</span><br><span class="line">    <span class="comment"># 创建DBSession类型:</span></span><br><span class="line">    DBSession = sessionmaker(bind=engine)</span><br><span class="line">    <span class="comment"># 创建session对象:</span></span><br><span class="line">    session = DBSession()</span><br><span class="line">    <span class="keyword">if</span> insert_p:</span><br><span class="line">        <span class="comment"># 创建新User对象:</span></span><br><span class="line">        new_user = User(id=str(ids), name=name)</span><br><span class="line">        <span class="comment"># 添加到session:</span></span><br><span class="line">        session.add(new_user)</span><br><span class="line">        <span class="comment"># 提交即保存到数据库:</span></span><br><span class="line">        session.commit()</span><br><span class="line">    <span class="comment"># 关闭session:</span></span><br><span class="line">    session.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建Session:</span></span><br><span class="line">    session = DBSession()</span><br><span class="line">    <span class="comment"># 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:</span></span><br><span class="line">    user = session.query(User).filter(User.id == str(check_id)).one()</span><br><span class="line">    <span class="comment"># 打印类型和对象的name属性:</span></span><br><span class="line">    print(<span class="string">&#x27;type:&#x27;</span>, type(user))</span><br><span class="line">    print(<span class="string">&#x27;name:&#x27;</span>, user.name)</span><br><span class="line">    <span class="comment"># 关闭Session:</span></span><br><span class="line">    session.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># mysql_(check_id=1)</span></span><br><span class="line">    sqlalchemy_(check_id=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><p><a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-new-user-and-grant-permissions-in-mysql">How To Create a New User and Grant Permissions in MySQL</a></p>
</li>
<li><p><a href="https://phoenixnap.com/kb/how-to-create-new-mysql-user-account-grant-privileges">How to Create New MySQL User</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/creating-database.html">Creating and Selecting a Database</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Mac 上使用 caffeinate 保持进程运行</title>
    <url>/2021/08/31/mac-pid-keep-runing-caffeinate/</url>
    <content><![CDATA[<p>当把 Mac Book Pro 的显示器盖合上后，有些进程会无法继续运行。下面介绍一种方法能让进程一直运行下去。</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该命令能让进程一直保持运行</span></span><br><span class="line">caffeinate -w &lt;进程号&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只保持3600秒</span></span><br><span class="line">caffeinate -t 3600</span><br></pre></td></tr></table></figure>

<p>如何获取进程号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 -v grep是为了避免匹配到 grep 进程</span></span><br><span class="line">ps -ef | grep <span class="string">&quot;ssh -L&quot;</span> | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 名称首字母加[]的目的是为了避免匹配到 awk 自身的进程</span></span><br><span class="line">ps -ef | awk <span class="string">&#x27;/[n]ame/&#123;print $2&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只使用 x 参数，则 pid 位于第一位</span></span><br><span class="line">ps x | awk <span class="string">&#x27;/[n]ame/&#123;print $1&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单获取 pid</span></span><br><span class="line">pgrep -f name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀掉 pid</span></span><br><span class="line">pkill -f name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是可执行程序</span></span><br><span class="line">pidof name</span><br></pre></td></tr></table></figure>

<p>实例，保持 ssh 合盖不断开</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pgrep -f <span class="string">&#x27;ssh -L&#x27;</span> | xargs caffeinate -w</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者在后台运行</span></span><br><span class="line">nohup pgrep -f <span class="string">&#x27;ssh -L&#x27;</span> | xargs caffeinate -w &amp;</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://www.zhihu.com/question/312052061">caffeinate 知乎</a></li>
<li><a href="https://blog.csdn.net/baidu_33850454/article/details/78568392">linux shell 根据进程名获取pid</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>caffeinate</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 电脑重设密码</title>
    <url>/2021/05/29/mac-resetpassword/</url>
    <content><![CDATA[<p>当某天突然 Mac 电脑无法通过输入密码正常进入系统，但密码正确无误，不知什么原因，可通过如下方式重设密码。</p>
<a id="more"></a>

<h1 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h1><p>按住开机键3秒，电脑强制关机</p>
<h1 id="进入恢复模式"><a href="#进入恢复模式" class="headerlink" title="进入恢复模式"></a>进入恢复模式</h1><p>按住 command + r 键保持住，然后按开机键开机，进入恢复模式</p>
<h1 id="通过终端命令重设密码"><a href="#通过终端命令重设密码" class="headerlink" title="通过终端命令重设密码"></a>通过终端命令重设密码</h1><p>在左上角菜单栏找到 <code>实用程序</code>，选择 <code>Terminal</code>，输入 <code>resetpassword</code> 回车</p>
<p>此时会弹出一个界面，请同时设定所有用户的密码，可以重设管理员密码。</p>
<p>重设确认后，重启电脑即可。</p>
<h1 id="其他重设密码方法"><a href="#其他重设密码方法" class="headerlink" title="其他重设密码方法"></a>其他重设密码方法</h1><p>如果能够正常进入 Mac 系统，可以使用如下方法重设密码</p>
<p>打开 <code>系统便好设置</code> 找到 <code>用户和群组</code> 打开小锁, 点击更改密码</p>
<p>如果勾选了<code>运行用户使用Apple ID重设密码</code>，那么开无法登陆系统时可尝试 Apple ID 找回密码。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>1.<a href="https://www.cnblogs.com/cdfive2018/p/12441500.html">mac系统登录密码对的但无法登录</a></p>
]]></content>
      <categories>
        <category>technology</category>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>mbp</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 电脑设置 shell 脚本开机自启</title>
    <url>/2021/01/10/mac-startup-shell/</url>
    <content><![CDATA[<p>苹果电脑 Mac 无论是运行流畅度，还是界面都给用户一种非常完美的感受。在 Linux 系统上设置开机自启脚本有很多教程，在 Mac 上如何开机自启 shell 脚本呢，这里介绍一种方法。</p>
<a id="more"></a>

<h1 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h1><p>这里以脚本 test.sh 为例，该脚本具体如下，即在开机时在用户桌面创建 success 空文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Desktop</span><br><span class="line">touch success</span><br></pre></td></tr></table></figure>

<p>写入上面内容后，保存为 test.sh，把脚本文件放在用户桌面。</p>
<h1 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 test.sh</span><br></pre></td></tr></table></figure>

<h1 id="修改文件打开方式"><a href="#修改文件打开方式" class="headerlink" title="修改文件打开方式"></a>修改文件打开方式</h1><p>在桌面找到 test.sh 文件，右键找到‘显示简介’， 将打开方式修改为‘终端’，共享和权限将所有权限打开，即设置 staff 和 everyone 的权限为读与写。</p>
<h1 id="配置开机启动"><a href="#配置开机启动" class="headerlink" title="配置开机启动"></a>配置开机启动</h1><p>进入系统偏好设置，找到用户与群组，打开小锁，找到当前用户的登录项，将 test.sh 添加到登录项，并把隐藏选型卡勾选。重启系统即可。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/linhai1028/article/details/80220423">mac设置shell脚本开机自启动</a></p>
]]></content>
      <categories>
        <category>technology</category>
        <category>mac</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>流形</title>
    <url>/2020/12/03/manifolds/</url>
    <content><![CDATA[<p><strong>流形</strong>（Manifolds）是可以局部欧几里得空间的一个拓扑空间，是欧几里得空间中的曲线、曲面等概念的推广。欧几里得空间就是最简单的流形的实例。地球表面这样的球面则是一个稍微复杂的例子。一般的流形可以通过把许多平直的片折弯并粘连而成。</p>
<a id="more"></a>

<p>一般可以把几何形体的拓扑结构看作是完全“柔软”的，因为所有变形（同胚）会保持拓扑结构不变；而把解析几何结构看作是“硬”的，因为整体的结构都是固定的。例如，当一个多项式在 $(0, 1)$ 区间的取值确定了，则其在整个实数范围的值都被固定，可见局部的变动会导致全局的变化。光滑流形可以看作是介于两者之间的模型：其无穷小的结构是“硬”的，而整体结构则是“柔软”的。这也许是中文译名“流形”的原因（整体的形态可以流动）。该译名由著名数学家和数学教育学家江泽涵引入。这样，流形的硬度使它能够容纳微分结构，而它的软度使得它可以作为很多需要独立的局部扰动的数学和物理的模型。</p>
<h1 id="流形"><a href="#流形" class="headerlink" title="流形"></a>流形</h1><p>流形可以视为近看起来像欧几里得空间或其他相对简单的空间的物体。例如，人们曾经以为地球是平的。这是因为相对于地球来说人类实在太小，平常看到的地面是地球表面微小的一部分。所以，尽管知道地球实际上差不多是一个圆球，如果只需要考虑其中微小的一部分上发生的事情，比如测量操场跑道的长度或进行房地产交易时，仍然把地面看成一个平面。一个理想的数学上的球面在足够小的区域上的特性就像一个平面，这表明它是一个流形。但是球面和平面的整体结构是完全不同的：如果在球面上沿一个固定方向走，最终会回到起点，而在一个平面上，可以一直走下去。</p>
<p>回到地球的例子。像旅行的时候，会用平面的地图来指示方位。如果将整个地球的各个地区的地图合订成一本地图集，那么在观看各个地区的地图后，就可以在脑海中“拼接”出整个地球的景貌。为了能让阅读者顺利从一张地图接到下一张，相邻的地图之间会有重叠的部分，以便在脑海里“粘合”两张图。类似地，在数学中，也可以用一系列“地图”（称为<strong>坐标图</strong>或<strong>坐标卡</strong>）组成的“地图集”（atlas, 亦称为<strong>图册</strong>）来描述一个流形。而“地图”之间重叠的部分在不同的地图里如何变换，则描述了不同“地图”的相互关系。</p>
<p>描述一个流形往往需要不止一个“地图”，因为一般来说流形并不是真正的欧几里得空间。举例来说，地球就没法用一张平面的地图来合适地描绘。</p>
<p>流形要求局部“看起来像”简单的空间，这不是一个简单的要求。例如，在球上吊一根线，这个整体就不是一个流形。包含了线和球连接的那一点的附近区域一定不是简单的：既不是线也不是面，无论这个区域有多小。</p>
<p>流形有很多种。最简单的是拓扑流形，它们局部看来像欧几里得空间。其他的种类包含了它们在使用中所需要的额外的结构。例如，一个微分流形不仅支持拓扑，而且要支持微积分。黎曼流形的思想导致了广义相对论的数学基础，使得人们能够用曲率来描述时空。</p>
<h1 id="拓扑流形"><a href="#拓扑流形" class="headerlink" title="拓扑流形"></a>拓扑流形</h1><p>最容易定义的流形是拓扑流形，它局部看起来像一些“普通”的欧几里得空间 $\mathbb{R}^n$。形式化地讲，一个拓扑流形是一个局部同胚于一个欧几里得空间的拓扑空间。这表示每个点有一个邻域，它有一个同胚（连续双射其逆也连续）将它映射到 $\mathbb{R}^n$。 这些同胚是流形的坐标图。</p>
<p>通常附加的技术性假设被加在该拓扑空间上，以排除病态的情形。可以根据需要要求空间是豪斯多夫的并且第二可数。这表示下面所述的有两个原点的直线不是拓扑流形，因为它不是豪斯多夫的。</p>
<p>流形在某一点的<em>维数</em>就是该点映射到的欧几里得空间的维数（定义中的数字 $n$）。连通流形中的所有点有相同的维数。有些作者要求拓扑流形的所有的图映射到同一欧几里得空间。这种情况下，拓扑空间有一个拓扑不变量，也就是它的维数。其他作者允许拓扑流形的不交并有不同的维数。</p>
<h1 id="微分流形"><a href="#微分流形" class="headerlink" title="微分流形"></a>微分流形</h1><p>很容易定义拓扑流形，但是很难在它们上面工作。对于多数应用，拓扑流形的一种，<strong>微分流形</strong>比较好用。如果流形上的局部坐标图以某种形式相容，就可以在该流形上讨论方向，切空间和可微函数。特别是，可以在微分流形上应用“微积分”。</p>
<h1 id="黎曼流形"><a href="#黎曼流形" class="headerlink" title="黎曼流形"></a>黎曼流形</h1><p><strong>黎曼流形</strong>（Riemannian manifold）是一个微分流形，其中每点<em>p</em>的切空间都定义了点积，而且其数值随 $p$ 平滑地改变。它容许我们定义弧线长度、角度、面积、体积、曲率、函数梯度及向量域的散度。</p>
<p>每个 $\mathbb{R}^n$ 的平滑子流形可以导出黎曼度量：把 $\mathbb{R}^n$ 的点积都限制于切空间内。实际上，根据<strong>纳什嵌入定理</strong>，所有黎曼流形都可以这样产生。</p>
<p>我们可以<em>定义</em>黎曼流形为和 $\mathbb{R}^n$ 的平滑子流形是等距同构的度量空间，<strong>等距</strong>是指其内蕴度量（intrinsic metric）和上述从 $\mathbb{R}^n$ 导出的度量是相同的。这对建立黎曼几何是很有用的。</p>
<p>黎曼流形可以定义为平滑流形，其中给出了一个切丛的正定二次形的光滑截面。它可产生度量空间：</p>
<p>如果$\gamma: [a, b] \to M$ 是黎曼流形 $M$ 中一段连续可微分的弧线，我们可以定义它的长度 $L(\gamma)$ 为<br>$$<br>L(\gamma) = \int_a^b \left \Vert \gamma^{\prime}(t) \right \Vert \mathrm{d}t.<br>$$<br>（注意：$\gamma^{\prime}(t)$ 是切空间 $M$ 在 $\gamma(t)$ 点的元素；$\left \Vert \cdot \right \Vert$ 是切空间的内积所得出的范数。）</p>
<p>使用这个长度的定义，每个连通的黎曼流形 $M$ 很自然的成为一个度量空间（甚至是长度度量空间）：在 $x$ 与 $y$ 两点之间的距离$d(x,y)$ 定义为：<br>$$<br>d(x,y) = \inf \lbrace L(\gamma): \gamma 是连接 x 和 y 的一条光滑曲线 \rbrace.<br>$$<br>虽然黎曼流形通常是弯曲的，“直线”的概念依然存在：那就是测地线。</p>
<p>在黎曼流形中，测地线完备的概念，和拓扑完备及度量完备是等价的：每个完备性都可以推出其他的完备性，这就是 Hopf-Rinow 定理的内容。</p>
]]></content>
      <categories>
        <category>maths</category>
        <category>topology</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>manifolds</tag>
        <tag>topology</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 设置字体大小颜色和背景色</title>
    <url>/2021/04/27/markdown-font-size-color/</url>
    <content><![CDATA[<p>Markdown 非常方便撰写，其中不仅能够书写代码，$\LaTeX{}$ 文档，而且还能够自定义字体大小，颜色和背景色。</p>
<a id="more"></a>

<h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;宋体&quot;</span>&gt;</span></span>宋体<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;楷书&quot;</span>&gt;</span></span>楷书<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;草书&quot;</span>&gt;</span></span>草书<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;隶书&quot;</span>&gt;</span></span>隶书<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;行书&quot;</span>&gt;</span></span>行书<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;仿宋&quot;</span>&gt;</span></span>仿宋<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;篆书&quot;</span>&gt;</span></span>篆书<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;仿宋_GB2312&quot;</span>&gt;</span></span>仿宋<span class="emphasis">_GB2312<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;微软雅黑&quot;</span>&gt;</span></span>微软雅黑<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;Times New Roman&quot;</span>&gt;</span></span>Times New Roman<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure>

<p><font face="宋体">宋体</font><br><font face="楷书">楷书</font><br><font face="草书">草书</font><br><font face="隶书">隶书</font><br><font face="行书">行书</font><br><font face="黑体">黑体</font><br><font face="仿宋">仿宋</font><br><font face="篆书">篆书</font><br><font face="仿宋_GB2312">仿宋_GB2312</font><br><font face="微软雅黑">微软雅黑</font><br><font face="Times New Roman">Times New Roman</font></p>
<h1 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span></span> 红色 <span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">orange</span>&gt;</span></span> 橙色 <span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">yellow</span>&gt;</span></span> 黄色 <span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">green</span>&gt;</span></span> 绿色 <span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">cyan</span>&gt;</span></span> 青色 <span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span> 蓝色 <span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">violet</span>&gt;</span></span> 紫罗兰色 <span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">gray</span>&gt;</span></span> 灰色 <span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">purple</span>&gt;</span></span> 紫色 <span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#FF0000</span> &gt;</span></span>红色<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#008000</span> &gt;</span></span>绿色<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#0000FF</span> &gt;</span></span>蓝色<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><font color=red> 红色 </font><br><font color=orange> 橙色 </font><br><font color=yellow> 黄色 </font><br><font color=green> 绿色 </font><br><font color=cyan> 青色 </font><br><font color=blue> 蓝色 </font><br><font color=violet> 紫罗兰色 </font></p>
<p><font color=gray> 灰色 </font><br><font color=purple> 紫色 </font></p>
<p><font color=#FF0000 >红色</font> </p>
<p><font color=#008000 >绿色</font></p>
<p> <font color=#0000FF >蓝色</font></p>
<h1 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">1</span>&gt;</span></span> 小字体 <span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">6</span>&gt;</span></span> 中字体 <span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">10</span>&gt;</span></span> 大字体 <span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><font size=1> 小字体 </font></p>
<p><font size=6> 中字体 </font></p>
<p><font size=10> 大字体 </font></p>
<h1 id="背景色"><a href="#背景色" class="headerlink" title="背景色"></a>背景色</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">red</span>&gt;</span></span> 红色背景 <span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">orange</span>&gt;</span></span> 橙色背景 <span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">yellow</span>&gt;</span></span> 黄色背景 <span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">green</span>&gt;</span></span> 绿色背景 <span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">cyan</span>&gt;</span></span> 青色背景 <span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">blue</span>&gt;</span></span> 蓝色背景 <span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">violet</span>&gt;</span></span> 紫罗兰色背景 <span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">gray</span>&gt;</span></span> 灰色背景 <span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">purple</span>&gt;</span></span> 紫色背景 <span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<table><tr><td bgcolor=red> 红色背景 </td></tr></table>
<table><tr><td bgcolor=orange> 橙色背景 </td></tr></table>
<table><tr><td bgcolor=yellow> 黄色背景 </td></tr></table>
<table><tr><td bgcolor=green> 绿色背景 </td></tr></table>
<table><tr><td bgcolor=cyan> 青色背景 </td></tr></table>
<table><tr><td bgcolor=blue> 蓝色背景 </td></tr></table>
<table><tr><td bgcolor=violet> 紫罗兰色背景 </td></tr></table>

<table><tr><td bgcolor=gray> 灰色背景 </td></tr></table>
<table><tr><td bgcolor=purple> 紫色背景 </td></tr></table>



<h1 id="混合字体大小颜色和背景色"><a href="#混合字体大小颜色和背景色" class="headerlink" title="混合字体大小颜色和背景色"></a>混合字体大小颜色和背景色</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">orange</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;篆书&quot;</span> <span class="attr">color</span>=<span class="string">red</span> <span class="attr">size</span>=<span class="string">9</span>&gt;</span></span> 红色篆书9号字体背景色橘色<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<table><tr><td bgcolor=orange><font face="篆书" color=red size=9> 红色篆书9号字体背景色橘色</font> </td></tr></table>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><p><a href="https://blog.csdn.net/The_Best_Hacker/article/details/82987796?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control">css font-family常用的字体中英文对照表</a></p>
</li>
<li><p><a href="http://www.voidcn.com/article/p-firwkkkw-vc.html">CSDN-markdown编辑器语法——背景色</a></p>
</li>
<li><p><a href="https://blog.csdn.net/lunhui1994_/article/details/80507970">字体和font-family对照表</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_43827595/article/details/102949185">markdown语法进阶——字体、字号与颜色设置</a></p>
</li>
<li><p><a href="https://blog.csdn.net/heimu24/article/details/81189700">Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>color</tag>
        <tag>markdonw</tag>
      </tags>
  </entry>
  <entry>
    <title>在 markdown 中书写矩阵</title>
    <url>/2020/11/24/markdown-matrix/</url>
    <content><![CDATA[<p>使用 markdown 写文章非常方便，简洁。对于数学符号书写也是非常的高效，本篇主要介绍如何在 markdown 中书写矩阵。</p>
<a id="more"></a>

<h1 id="不带括号的矩阵"><a href="#不带括号的矩阵" class="headerlink" title="不带括号的矩阵"></a>不带括号的矩阵</h1><p>代码之后的 tag 实现了后标</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line"><span class="code">    1 &amp; 2 &amp; 3 \\\\</span></span><br><span class="line"><span class="code">    4 &amp; 5 &amp; 6 \\\\</span></span><br><span class="line"><span class="code">    7 &amp; 8 &amp; 9</span></span><br><span class="line"><span class="code">\end&#123;matrix&#125; \tag&#123;1&#125;</span></span><br><span class="line"><span class="code">$$</span></span><br></pre></td></tr></table></figure>

<p>效果如下：<br>$$<br>\begin{matrix}<br>    1 &amp; 2 &amp; 3 \\<br>    4 &amp; 5 &amp; 6 \\<br>    7 &amp; 8 &amp; 9<br>\end{matrix} \tag{1}<br>$$</p>
<h1 id="带括号-​-的矩阵"><a href="#带括号-​-的矩阵" class="headerlink" title="带括号 { }​ 的矩阵"></a>带括号 { }​ 的矩阵</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;Bmatrix&#125;</span><br><span class="line"><span class="code">    1 &amp; 2 &amp; 3 \\\\</span></span><br><span class="line"><span class="code">    4 &amp; 5 &amp; 6 \\\\</span></span><br><span class="line"><span class="code">    7 &amp; 8 &amp; 9</span></span><br><span class="line"><span class="code">\end&#123;Bmatrix&#125; \tag&#123;2&#125;</span></span><br><span class="line"><span class="code">$$</span></span><br></pre></td></tr></table></figure>

<p>效果如下<br>$$<br>\begin{Bmatrix}<br>    1 &amp; 2 &amp; 3 \\<br>    4 &amp; 5 &amp; 6 \\<br>    7 &amp; 8 &amp; 9<br>\end{Bmatrix} \tag{2}<br>$$</p>
<h1 id="带括号-的矩阵"><a href="#带括号-的矩阵" class="headerlink" title="带括号 $[]$ 的矩阵"></a>带括号 $[]$ 的矩阵</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\left[</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line"><span class="code">    1 &amp; 2 &amp; 3 \\\\</span></span><br><span class="line"><span class="code">    4 &amp; 5 &amp; 6 \\\\</span></span><br><span class="line"><span class="code">    7 &amp; 8 &amp; 9</span></span><br><span class="line"><span class="code">\end&#123;matrix&#125;</span></span><br><span class="line"><span class="code">\right] \tag&#123;3&#125;</span></span><br><span class="line"><span class="code">$$</span></span><br></pre></td></tr></table></figure>

<p>效果如下：<br>$$<br>\left [<br>\begin{matrix}<br>    1 &amp; 2 &amp; 3 \\<br>    4 &amp; 5 &amp; 6 \\<br>    7 &amp; 8 &amp; 9<br>\end{matrix}<br>\right ] \tag{3}<br>$$</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;bmatrix&#125;</span><br><span class="line"><span class="code">    1 &amp; 2 &amp; 3 \\\\</span></span><br><span class="line"><span class="code">    4 &amp; 5 &amp; 6 \\\\</span></span><br><span class="line"><span class="code">    7 &amp; 8 &amp; 9</span></span><br><span class="line"><span class="code">\end&#123;bmatrix&#125; \tag&#123;4&#125;</span></span><br><span class="line"><span class="code">$$</span></span><br></pre></td></tr></table></figure>

<p>效果：<br>$$<br>\begin{bmatrix}<br>    1 &amp; 2 &amp; 3 \\<br>    4 &amp; 5 &amp; 6 \\<br>    7 &amp; 8 &amp; 9<br>\end{bmatrix} \tag{4}<br>$$</p>
<h1 id="带省略号的矩阵"><a href="#带省略号的矩阵" class="headerlink" title="带省略号的矩阵"></a>带省略号的矩阵</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\left[</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line"><span class="code">    1      &amp; 2      &amp; \cdots &amp; 4      \\\\</span></span><br><span class="line"><span class="code">    7      &amp; 6      &amp; \cdots &amp; 5      \\\\</span></span><br><span class="line"><span class="code">    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\\</span></span><br><span class="line"><span class="code">    8      &amp; 9      &amp; \cdots &amp; 0      \\\\</span></span><br><span class="line"><span class="code">\end&#123;matrix&#125;</span></span><br><span class="line"><span class="code">\right] \tag&#123;5&#125;</span></span><br><span class="line"><span class="code">$$</span></span><br></pre></td></tr></table></figure>

<p>效果如下：<br>$$<br>\left[<br>\begin{matrix}<br>    1      &amp; 2      &amp; \cdots &amp; 4      \\<br>    7      &amp; 6      &amp; \cdots &amp; 5      \\<br>    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>    8      &amp; 9      &amp; \cdots &amp; 0      \\<br>\end{matrix}<br>\right] \tag{5}<br>$$</p>
<h1 id="带参数的矩阵"><a href="#带参数的矩阵" class="headerlink" title="带参数的矩阵"></a>带参数的矩阵</h1><p>这里笔者希望在矩阵中画出一条分割线，以强调最右侧一列的特殊性。<br>其中<code>\begin&#123;array&#125;&#123;cc|c&#125;</code>中的c表示居中对齐元素；</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$ </span><br><span class="line">\left[</span><br><span class="line">\begin&#123;array&#125;&#123;cc|c&#125;</span><br><span class="line"><span class="code">    1 &amp; 2 &amp; 3 \\\\</span></span><br><span class="line"><span class="code">    4 &amp; 5 &amp; 6</span></span><br><span class="line"><span class="code">\end&#123;array&#125;</span></span><br><span class="line"><span class="code">\right] \tag&#123;6&#125;</span></span><br><span class="line"><span class="code">$$</span></span><br></pre></td></tr></table></figure>

<p>效果如下：<br>$$<br>\left[<br>\begin{array}{cc|c}<br>    1 &amp; 2 &amp; 3 \\<br>    4 &amp; 5 &amp; 6<br>\end{array}<br>\right] \tag{6}<br>$$</p>
<h1 id="行间矩阵"><a href="#行间矩阵" class="headerlink" title="行间矩阵"></a>行间矩阵</h1><p>表示将矩阵写在一行文本之中，这样不会占用太多的篇幅</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">二维矩阵</span><br><span class="line">$\bigl(</span><br><span class="line">\begin&#123;smallmatrix&#125;</span><br><span class="line">l&amp;l\\j&amp;z</span><br><span class="line">\end&#123;smallmatrix&#125;</span><br><span class="line">\bigr)$</span><br><span class="line">的行列式</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p>二维矩阵 $\bigl(<br>    \begin{smallmatrix}<br>        l&amp;l\\j&amp;z<br>    \end{smallmatrix}<br>\bigr)$ 的行列式</p>
<h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;vmatrix&#125;</span><br><span class="line"><span class="code">    1 &amp; 2 &amp; 3	\\\\</span></span><br><span class="line"><span class="code">    4 &amp; 5 &amp; 6	\\\\</span></span><br><span class="line"><span class="code">    7 &amp; 8 &amp; 9</span></span><br><span class="line"><span class="code">\end&#123;vmatrix&#125; \tag&#123;7&#125;</span></span><br><span class="line"><span class="code">$$</span></span><br></pre></td></tr></table></figure>

<p>效果如下：<br>$$<br>\begin{vmatrix}<br>    1 &amp; 2 &amp; 3    \\<br>    4 &amp; 5 &amp; 6    \\<br>    7 &amp; 8 &amp; 9<br>\end{vmatrix} \tag{7}<br>$$</p>
<h1 id="矩阵范数"><a href="#矩阵范数" class="headerlink" title="矩阵范数"></a>矩阵范数</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;Vmatrix&#125;</span><br><span class="line"><span class="code">    1 &amp; 2 &amp; 3	\\\\</span></span><br><span class="line"><span class="code">    4 &amp; 5 &amp; 6	\\\\</span></span><br><span class="line"><span class="code">    7 &amp; 8 &amp; 9</span></span><br><span class="line"><span class="code">\end&#123;Vmatrix&#125; \tag&#123;8&#125;</span></span><br><span class="line"><span class="code">$$</span></span><br></pre></td></tr></table></figure>

<p>效果如下：<br>$$<br>\begin{Vmatrix}<br>    1 &amp; 2 &amp; 3    \\<br>    4 &amp; 5 &amp; 6    \\<br>    7 &amp; 8 &amp; 9<br>\end{Vmatrix} \tag{8}<br>$$</p>
<h1 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">P(x|Pa<span class="emphasis">_x)=\begin&#123;cases&#125; </span></span><br><span class="line"><span class="emphasis">    1, &amp; x=f(Pa_</span>&#123;x&#125;)	\\\\ </span><br><span class="line"><span class="code">    0, &amp; \text&#123;other values&#125;</span></span><br><span class="line"><span class="code">\end&#123;cases&#125; \tag&#123;9&#125;</span></span><br><span class="line"><span class="code">$$</span></span><br></pre></td></tr></table></figure>

<p>效果如下：<br>$$<br>P(x|Pa_x)=\begin{cases}<br>    1, &amp; x=f(Pa_{x})    \\<br>    0, &amp; \text{other values}<br>\end{cases} \tag{9}<br>$$</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://blog.csdn.net/qq_38228254/article/details/79469727">使用Markdown写矩阵</a></li>
<li><a href="https://blog.csdn.net/nuoyanli/article/details/96179976">使用Markdown写矩阵、表格和一些数学公式(实用)</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>matrix</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>数学家伯努利家族</title>
    <url>/2020/03/21/mathematician-bernoulli-family/</url>
    <content><![CDATA[<p>伯努利家族可谓是数学智团一族，特别是雅各布$\cdot$伯努利、约翰$\cdot$伯努利、丹尼尔$\cdot$伯努利。下面分别对他们三个进行介绍。</p>
<a id="more"></a>

<h1 id="约翰-cdot-伯努利"><a href="#约翰-cdot-伯努利" class="headerlink" title="约翰$\cdot$伯努利"></a>约翰$\cdot$伯努利</h1><p>这里首先介绍约翰$\cdot$伯努利，是因为他不仅是雅各布$\cdot$伯努利的弟弟，而且还是丹尼尔$\cdot$伯努利的父亲。同时，他的导师是大名鼎鼎的德国数学家戈特弗里德$\cdot$<strong>莱布尼茨</strong>，他的学生包括旧瑞士的莱昂哈德$\cdot$<strong>欧拉</strong>、法国的纪尧姆$\cdot$弗朗索瓦$\cdot$安托万$\cdot$<strong>洛必达</strong>。数学分析中非常有名的洛必达法则其实是出自其导师约翰$\cdot$伯努利的意念。约翰$\cdot$伯努利最早学习医学，后对数学感兴趣改投数学研究。</p>
<p><strong><em>约翰$\cdot$伯努利与牛顿的故事。</em></strong>莱布尼茨与英国的<strong>牛顿</strong>为同时代的大数学家，他们同时创立了微积分。虽然牛顿被评为是最伟大的三位数学家（美国数学史学家E.T.贝尔在其《数学大师(Men of Mathematics)》一书中提出）之一，称为“数学之神”，其他两名分别是“数学界的莎士比亚”的阿基米德、“数学王子”的高斯（出生贫寒，受到资助后一路开挂）。但是，现在微积分的数学符号基本沿用于莱布尼茨，并且，莱布尼茨还对二进制的发展作出了重要贡献。约翰$\cdot$伯努利提出著名的<font color='dd0000'>最速降线问题</font>，并且给与其恩师争夺微积分发明权的牛顿写信，让其解答，牛顿花费一个晚上之后于凌晨4点利用微积分给出了解答。该问题还有四个人给出了解答，分别是约翰$\cdot$伯努利本人（利用费马原理：两点间光线传播的路径是所需时间最少的路径）、莱布尼茨（利用微积分）、洛必达（利用微积分）、雅各布$\cdot$伯努利（利用欧拉提出的变分法），都得出该路径是摆线。</p>
<p><strong><em>约翰$\cdot$伯努利与哥哥雅各布$\cdot$伯努利，以及儿子丹尼尔$\cdot$伯努利的故事。</em></strong>虽然在约翰毕业之前，雅各布曾与约翰一起共事，毕业后不久，两兄弟逐渐产生了一种嫉妒与竞争的关系。约翰嫉妒雅各布在大学里崇高的位置。在大庭广众下或私底下，两兄弟时常互相较劲。雅各布过世后，约翰的忌妒又转移到丹尼尔，他的天才儿子身上。1738年，父子俩几乎同时地发表了各自在<strong>流体力学</strong>的研究成果。约翰故意将自己作品的完成日期提前，使它比儿子的日期还早两年，这样他便能获得优先的荣誉。</p>
<p><strong><em>约翰$\cdot$伯努利与哥哥雅各布$\cdot$伯努利的故事，关系越来越紧张。</em></strong>1691年，约翰成功地解答了雅各布著名的悬链线（答案为双曲余弦线，不是抛物线）问题，这使兄弟俩之间的紧张关系更犹如火上浇油。1696年，约翰提出了自己已解出的最速降线问题。在短短的两年内，他接到五个解答，其中一个是雅各布给予的。约翰也曾经建议了一个流体永动机。</p>
<p><strong><em>约翰$\cdot$伯努利与学生洛必达的故事。</em></strong>有一段时间，约翰$\cdot$伯努利被洛必达聘请为私人数学老师。约翰$\cdot$伯努利签了一纸合约。这合约给予洛必达特殊的权力，准许洛必达发表约翰$\cdot$伯努利所有的研究。洛必达最先地写成了一本的微积分教科书，其内容大多是约翰$\cdot$伯努利的杰作，包括现世知名的<font color='dd0000'>洛必达法则</font>。</p>
<p><strong><em>约翰$\cdot$伯努利与欧拉的故事。</em></strong>起初约翰$\cdot$伯努利请欧拉为其儿子丹尼尔$\cdot$伯努利做家庭辅导，最后，欧拉成为一代数学大师。欧拉晚年双目失明，但仍靠记忆力口述书写了大量数学文稿。欧拉的学生之一就是大数学家<strong>朗格朗日</strong>。</p>
<h1 id="雅各布-cdot-伯努利"><a href="#雅各布-cdot-伯努利" class="headerlink" title="雅各布$\cdot$伯努利"></a>雅各布$\cdot$伯努利</h1><p>雅各布$\cdot$伯努利是最早使用“积分”这个术语的人，也是较早使用极坐标系的数学家之一。概率论中的<font color='dd0000'>伯努利试验</font>和<font color='dd0000'>大数定律</font>就是其提出来的。他最初遵从父亲的意见学习神学，当他读了笛卡尔和沃利斯的书后， 顿受启发，兴趣转向数学。</p>
<p>雅各布关于对数螺线深有研究，他发现对数螺线经过各种变换后，结果还是<font color='dd0000'>对数螺线</font>。在惊叹这曲线的奇妙之余，遗言要将这曲线刻在墓碑上，并附以颂词：“纵使变化，依然故我”。可惜雕刻师误将阿基米德螺线（等速螺线）刻了上去。</p>
<p>其知名于伯努利微分方程、伯努利数、伯努利多项式、伯努利试验、伯努利过程、伯努利分布、伯努利不等式、伯努利双纽线。</p>
<h1 id="丹尼尔-cdot-伯努利"><a href="#丹尼尔-cdot-伯努利" class="headerlink" title="丹尼尔$\cdot$伯努利"></a>丹尼尔$\cdot$伯努利</h1><p>丹尼尔·伯努利（Daniel Bernoulli，1700年2月8日－1782年3月17日），生于荷兰格罗宁根，著名数学家，约翰·伯努利之子，雅各布·伯努利的侄子，伯努利家族代表人物之一。其伯努利定律适用于沿着一条流线的稳定、非粘滞、不可压缩流，在流体力学和空气动力学中有关键性的作用。</p>
<p>约翰·伯努利希望他经商，但是他仍然从事数学。据说他和他父亲关系不好。在他们同时参加并试图获得巴黎大学的科学竞赛的第一名时，约翰因为不能承受和他的后代做比较的“羞耻”，把丹尼尔逐出他的家族。约翰还曾试图盗窃丹尼尔的著作《Hydrodynamica》（流体力学）并把它重新命名为《Hydraulica》。虽然丹尼尔试图妥协，他父亲至死不愿和解。</p>
<p>他是欧拉的同时代人，也是密友。和欧拉在欧拉-伯努力栋梁方程上有过合作。他于1724年前往圣彼得堡出任数学教授，但不喜欢那里。1733年一场短暂的病给了他离开那里的理由。他回到巴塞尔大学，在那里他曾陆续担任医学、形而上学和自然哲学的教授直至去世。</p>
<p>他的主要著作是《<font color='dd0000'>流体力学</font>》，发表于1738年。知名于<font color='dd0000'>伯努利原理</font>，即，在流体动力学，伯努利原理指出，无黏性的流体的速度增加时，流体的压力能或位能（势能）总和将减少。</p>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematician</category>
      </categories>
      <tags>
        <tag>mathematician</tag>
        <tag>bernoulli</tag>
      </tags>
  </entry>
  <entry>
    <title>数学家拉格朗日</title>
    <url>/2020/03/21/mathematician-lagrange/</url>
    <content><![CDATA[<p><font color='dd00dd' size=5>Joseph Lagrange(约瑟夫$\cdot$拉格朗日)</font></p>
<a id="more"></a>

<table>
<thead>
<tr>
<th align="center">姓名</th>
<th>Joseph Lagrange(约瑟夫$\cdot$拉格朗日)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">出生</td>
<td>1736年1月25日 意大利都灵</td>
</tr>
<tr>
<td align="center">逝世</td>
<td>1813年4月10日（77岁）法国巴黎</td>
</tr>
<tr>
<td align="center">国籍</td>
<td>法国籍意大利裔</td>
</tr>
<tr>
<td align="center">居住地</td>
<td>皮埃蒙特，法国，普鲁士</td>
</tr>
<tr>
<td align="center">研究领域</td>
<td>数学，数学物理</td>
</tr>
<tr>
<td align="center">知名于</td>
<td>分析力学，天体力学，数学分析，数论</td>
</tr>
<tr>
<td align="center">机构</td>
<td>巴黎综合理工大学</td>
</tr>
<tr>
<td align="center">博士导师</td>
<td>莱昂哈德·欧拉（注意他没有博士导师，而是由学术谱系权威将其划到了具有同等作用的欧拉身上）</td>
</tr>
<tr>
<td align="center">博士生</td>
<td>约瑟夫·傅里叶，西莫恩·德尼·泊松</td>
</tr>
<tr>
<td align="center">贡献</td>
<td><font color='dd0000'>代数</font><br> 1. 群的阶是子集的阶的倍数；<br> 2. 消去理论;<br> 3.将行列式的概念应用到非消去理论的范畴;<br> 4.拉格朗日插值多项式;<br><font color='dd0000'>数论</font><br> 1. 四平方和定理；<br> 2. 证明配尔方程必存在解;<br> 3. 证明威尔逊定理;<br> 4. 创立二次型论;<br> 5. 证明循环连分数均为二次无理数;<br><font color='dd0000'>微积分</font><br> 1. 拉格朗日乘子法;<br> 2. 拉格朗日中值定理;<br><font color='dd0000'>力学</font><br> 1. 在1772年至1788年，他简化了经典力学中的一些公式和运算，并创建了自己的分支，称为拉格朗日力学。<br><font color='dd0000'>天文</font><br> 1. 1764年，拉格朗日成功解释了为什么月球总是一面朝向地球;<br> 2. 1772年，发现拉格朗日点.</td>
</tr>
<tr>
<td align="center">荣誉</td>
<td>1. 月球上的拉格朗日撞击坑;<br>2. 小行星1006;<br>3. 1808年获得法国荣誉军团勋章并封为伯爵;<br>4. 他是名字被刻在艾菲尔铁塔的七十二位法国科学家与工程师其中一位.</td>
</tr>
<tr>
<td align="center">三L之一</td>
<td>法国18世纪后期到19世纪初数学界著名的三个人物：拉格朗日、拉普拉斯（Pierre-Simon marquis de Laplace）和勒让德（Adrien-Marie Legendre）。因为他们三位的姓氏的第一个字母为“L”，又生活在同一时代，所以人们称他们为“三L”</td>
</tr>
<tr>
<td align="center">格言</td>
<td>1. 如果我继承可观的财产，可能就不会投身于数学之中了;<br>2. 我把数学看成是一件有意思的工作，而不是想为自己建立什么纪念碑。可以肯定地说，我对别人的工作比自己的更喜欢。我对自己的工作总是不满意.<br>3. 一个人的贡献和他的自负严格地成反比，这似乎是品行上的一个公理.</td>
</tr>
</tbody></table>
<p>拉格朗日早年并没有表现出数学天赋，受哈雷论文影响开始开挂。与欧拉交流频繁，共同建立欧拉-拉格朗日方程，开创了变分法（研究泛函的极值问题，如最速降线问题等。变分法可能是从约翰·伯努利（1696）提出最速曲线（brachistochrone curve）问题开始出现的。它立即引起了雅各布·伯努利和洛必达（Marquis de l’Hôpital）的注意。但欧拉首先详尽的阐述了这个问题。他的贡献始于1733年，他的《变分原理》（Elementa Calculi Variationum）寄予了这门科学这个名字。欧拉对这个理论的贡献非常大。）后欧拉将柏林物理数学所长职务让给拉格朗日。晚年失去了数学兴趣，类似于牛顿，开始研究神学。但，他有幸能看到年青的柯西、阿贝尔、高斯将数学推向新的高度。</p>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematician</category>
      </categories>
      <tags>
        <tag>mathematician</tag>
        <tag>lagrange</tag>
      </tags>
  </entry>
  <entry>
    <title>数学公式显示</title>
    <url>/2020/03/17/maths-formula-display/</url>
    <content><![CDATA[<p>Hexo + Github + Next搭建博客后，有时候需要写一些带有公式的博文。而默认情况下是不能显示数学公式的。这里介绍一种如何在博文上显示数学公式的方法。</p>
<a id="more"></a>

<h1 id="Typora-本地数学公式编辑"><a href="#Typora-本地数学公式编辑" class="headerlink" title="Typora 本地数学公式编辑"></a>Typora 本地数学公式编辑</h1><p>在本地下文章想显示数学公式，推荐使用typora这个软件，可以非常简单的配置后显示数学公式。</p>
<h2 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h2><p>首先设置行内公式编辑功能</p>
<p>文件—偏好设置—Markdown—Markdown扩展语法—内联公式</p>
<p>设置后重启typora</p>
<p>行内公式编辑方法，直接在需要编写数学公式的地方写如下类似内容</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$\sin(x) = x - \frac&#123;x^3&#125;&#123;3!&#125; + \cdots$ </span><br></pre></td></tr></table></figure>

<p>即，将公式写在**$**包括的里面就行，跟Latex语法一样。</p>
<h2 id="居中显示公式"><a href="#居中显示公式" class="headerlink" title="居中显示公式"></a>居中显示公式</h2><p>居中显示公式跟Latex语言一样，首先输入**$$**，然后回车，即可进入编辑模式。</p>
<p>或者使用快捷键：Ctrl + Shift + M</p>
<p>或者点击段落—公式块</p>
<h1 id="网页显示数学公式"><a href="#网页显示数学公式" class="headerlink" title="网页显示数学公式"></a>网页显示数学公式</h1><h2 id="开启mathjax"><a href="#开启mathjax" class="headerlink" title="开启mathjax"></a>开启mathjax</h2><p>进入目录 <strong>~\themes\next</strong>，编辑<strong>_config.yml</strong> ，修改如下内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cdn:</span> <span class="string">//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure>

<h2 id="post模板添加mathjax"><a href="#post模板添加mathjax" class="headerlink" title="post模板添加mathjax"></a>post模板添加mathjax</h2><p>进入目录**~\scaffolds** ，编辑<strong>post.md</strong>，添加<strong>mathjax: true</strong> ，类似于如下内容</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">author: Jinzhong Xu</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">mathjax: true</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br></pre></td></tr></table></figure>

<p>这样，使用命令hexo new maths-formula创建新博文时就会自动加载上mathjax，使得数学公式正常显示。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>如果不想设置那么复杂，可以直接在想要写的博文前面添加如下内容，使得本博文可以显示数学公式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-mathjax-config&quot;</span>&gt;</span></span><br><span class="line">        MathJax.Hub.Config(&#123;</span><br><span class="line">            tex2jax: &#123;</span><br><span class="line"><span class="javascript">            skipTags: [<span class="string">&#x27;script&#x27;</span>, <span class="string">&#x27;noscript&#x27;</span>, <span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;textarea&#x27;</span>, <span class="string">&#x27;pre&#x27;</span>],</span></span><br><span class="line"><span class="javascript">            inlineMath: [[<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;$&#x27;</span>]]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>maths</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Pages 数学公式显示</title>
    <url>/2019/12/22/maths-formula-format/</url>
    <content><![CDATA[<p>使用GitHub Pages发布博文时，数学公式不能正常显示，有一种方法可以解决，具体的是，添加如下代码到markdown文件的开头，这样发布的博文就可以正常显示了。</p>
<a id="more"></a>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-mathjax-config&quot;</span>&gt;</span></span><br><span class="line">        MathJax.Hub.Config(&#123;</span><br><span class="line">            tex2jax: &#123;</span><br><span class="line"><span class="javascript">            skipTags: [<span class="string">&#x27;script&#x27;</span>, <span class="string">&#x27;noscript&#x27;</span>, <span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;textarea&#x27;</span>, <span class="string">&#x27;pre&#x27;</span>],</span></span><br><span class="line"><span class="javascript">            inlineMath: [[<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;$&#x27;</span>]]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>数学中集合在 Python 中的操作</title>
    <url>/2021/10/25/maths-set-python/</url>
    <content><![CDATA[<p>在数学中，集合（Set）是一个基本概念，指具有某种特定性质的事物的总体，集合里的事物称作元素。元素 $x$ 和集合 $A$ 之间有属于（$x \in A$）和不属于（$x \notin A$）关系，集合有势（#$A$, $Card(A)$, $|A|$）的概念，集合有子集和包含关系（$B \subset A$），两集合 $A, B$ 间有并（$A\cup B$）、交（$A \cap B$）、差（$A - B$）、对称差（$A \triangle B$）运算。在 Python 中，对于该数学概念进行了定义，下面我们进行介绍。</p>
<a id="more"></a>

<h1 id="集合定义"><a href="#集合定义" class="headerlink" title="集合定义"></a>集合定义</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = set(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">B = set([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">C = &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">A</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">B</span><br><span class="line">&#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">C</span><br><span class="line">&#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h1 id="集合关系"><a href="#集合关系" class="headerlink" title="集合关系"></a>集合关系</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = set(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">B = set([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">C = &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># A 是否包含于 B</span></span><br><span class="line">A.issubset(B)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A 是否包含 B</span></span><br><span class="line">A.issuperset(B)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A 和 B之间是否没有交。如果不交返回True，相交返回False</span></span><br><span class="line">A.isdisjoint(B)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h1 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = set(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">B = set([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">C = &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># A 并 B</span></span><br><span class="line">A | B</span><br><span class="line">A.union(B)</span><br><span class="line">set.union(A, B)</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">C.union(A, B)</span><br><span class="line">A | B | C</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># A 交 B</span></span><br><span class="line">A &amp; B</span><br><span class="line">A.intersection(B)</span><br><span class="line">&#123;<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># A 减 B</span></span><br><span class="line">A - B</span><br><span class="line">A.difference(B)</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># A 和 B 的对称差</span></span><br><span class="line">A ^ B</span><br><span class="line">A.symmetric_difference(B)</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h1 id="集合增删"><a href="#集合增删" class="headerlink" title="集合增删"></a>集合增删</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = set(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">B = set([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">C = &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># A = A | B</span></span><br><span class="line">A.update(B)</span><br><span class="line">A</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># A = A &amp; B</span></span><br><span class="line">A = set(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">A.intersection_update(B)</span><br><span class="line">A</span><br><span class="line">&#123;<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># A = A - B</span></span><br><span class="line">A = set(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">A.difference_update(B)</span><br><span class="line">A</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># A = (A - B) | (B - A)</span></span><br><span class="line">A = set(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">A.symmetric_difference_update(B)</span><br><span class="line">A</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># A = A | set(&#x27;p&#x27;)</span></span><br><span class="line">A = set(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">A.add(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">A</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;p&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 A 中移除 &#x27;p&#x27;，当 &#x27;p&#x27; 不在 A 中时将报错</span></span><br><span class="line">A.remove(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">A</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 A 中移除 &#x27;p&#x27;，当 &#x27;p&#x27; 不在 A 中时不会报错</span></span><br><span class="line">A.discard(<span class="string">&#x27;p&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="集合元素"><a href="#集合元素" class="headerlink" title="集合元素"></a>集合元素</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合的势，即集合中元素的个数</span></span><br><span class="line">len(A)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断元素是否在集合中</span></span><br><span class="line"><span class="string">&#x27;p&#x27;</span> <span class="keyword">in</span> A</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断元素是否不在集合中</span></span><br><span class="line"><span class="string">&#x27;p&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> A</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h1 id="集合应用-去重"><a href="#集合应用-去重" class="headerlink" title="集合应用-去重"></a>集合应用-去重</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = list(set(a))</span><br><span class="line">b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h1 id="集合拷贝与清除"><a href="#集合拷贝与清除" class="headerlink" title="集合拷贝与清除"></a>集合拷贝与清除</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">D = A.copy()</span><br><span class="line">id(A), id(D)</span><br><span class="line">(<span class="number">139951109280704</span>, <span class="number">139951109280256</span>)</span><br><span class="line"></span><br><span class="line">D</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">D.discard(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">D</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">A</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">A.clear()</span><br><span class="line">A</span><br><span class="line">set()</span><br></pre></td></tr></table></figure>

<h1 id="冻结集合"><a href="#冻结集合" class="headerlink" title="冻结集合"></a>冻结集合</h1><p>冻结的集合元素无法改变</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Numbers = frozenset(<span class="string">&#x27;0123456789&#x27;</span>)</span><br><span class="line">Numbers</span><br><span class="line">frozenset(&#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://blog.csdn.net/isoleo/article/details/13000975">python 集合比较（交集、并集，差集）</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>python</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac Book Pro 更改 bash 为 zsh</title>
    <url>/2019/12/21/mbp-bash-to-zsh/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br><span class="line"><span class="comment"># 有时 Centos 上没有自动安装工具 chsh，可使用如下方法安装</span></span><br><span class="line">sudo yum install util-linux-user</span><br></pre></td></tr></table></figure>

<p>安装 oh-my-zsh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget -O- https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>mbp</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令 more 和 less</title>
    <url>/2020/03/13/more-or-less/</url>
    <content><![CDATA[<p>Linux系统有命令more和less来在终端查看文件内容，但是，两者有什么区别呢？总的来说，less比more更有效率更快，因为less不会立即加载整个文件，而more命令会一次加载整个文件内容。</p>
<a id="more"></a>

<h1 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">more test.log</span><br><span class="line">cat test.log | more</span><br></pre></td></tr></table></figure>

<p>查看test.log文件内容，同时显示剩余内容百分比，可以使用 <strong>Enter</strong>（一次一行）和<strong>Spacebar</strong>（一次一页）来翻页，使用<strong>q</strong>退出查看。此时，文件内容会保留在终端上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">more -5 test.log</span><br></pre></td></tr></table></figure>

<p>只显示文件test.log的前5行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">more +6 test.log</span><br></pre></td></tr></table></figure>

<p>从文件test.log的第6行开始显示，内容铺满整个屏幕，具体看屏幕大小</p>
<h1 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">less test.log</span><br><span class="line">cat test.log | less</span><br></pre></td></tr></table></figure>

<p>查看test.log文件内容，可以使用<strong>Enter</strong>（一次一行）和<strong>Spacebar</strong>（一次一页）来翻页，另外，也可以使用<strong>pageup</strong>和<strong>pagedown</strong>来上翻页和下翻页。使用<strong>q</strong>退出查看。此时，文件内容不会保留在终端上，而是退回命令行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">less +5 test.log</span><br></pre></td></tr></table></figure>

<p>从文件test.log的第5行开始显示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">less -N test.log</span><br></pre></td></tr></table></figure>

<p>显示文件内容的同时显示行号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">less -e test.log</span><br><span class="line">less -E test.log</span><br></pre></td></tr></table></figure>

<p>当查看到最后页面时自动退出，不需要再按<strong>q</strong>键</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">less +/ssh test.log</span><br></pre></td></tr></table></figure>

<p>显示第一次出现ssh的地方在最顶部</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.tecmint.com/linux-more-command-and-less-command-examples/">Learn Why ‘less’ is Faster Than ‘more’ Command for Effective File Navigation</a></li>
</ul>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习神经网络模型loss和accuracy的理解</title>
    <url>/2020/03/26/ml-nn-loss-accuracy/</url>
    <content><![CDATA[<p>训练机器学习模型时，特别是使用 TensorFlow 进行训练神经网络模型时，在每一步（epoch，表示一个周期，即训练完所有训练集样本。假设训练集包含100000个样本，而batch_size设置为100，即一次输入100个训练样本，那么需要1000次迭代后就完成一次epoch，将所有训练样本训练一次）总是会出现loss是多少，accuracy是多少。</p>
<a id="more"></a>

<p>loss越低，模型越好（当模型没有过拟合时）。它不是一个百分比，而是一次epoch中训练集样本或验证集样本所有error的和。比如，在神经网络中，loss值一般是 negative log likelihood(分类问题)和 residual sum of squares(回归问题)。因此，模型的训练是通过减少loss为目的的，即最小化loss function，如神经网络中采用反向传播对模型参数求导。loss隐含着每一次优化迭代后模型表现的好坏。</p>
<p>accuracy是当模型的参数学习得到并固定后来计算得到的。通过比较真实标签和预测标签来确定的0-1损失。它是一个百分比值。</p>
<p>优化训练的目标是loss值，而不是accuracy，因为loss function可以求导优化，而accuracy不能够求导。</p>
]]></content>
      <categories>
        <category>research</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>neural network</tag>
      </tags>
  </entry>
  <entry>
    <title>牛顿方法求解方程根</title>
    <url>/2020/07/26/newton-method-optimization/</url>
    <content><![CDATA[<p>牛顿法求极小值和方程根</p>
<a id="more"></a>

<p>牛顿法求解函数的极小值，用二阶泰勒展开近似目标函数：<br>$$<br>f(x) \approx f(x_0) + f^{\prime}(x_0)(x - x_0) + \frac{1}{2} f^{\prime\prime}(x_0)(x - x_0)^2 \triangleq g(x)<br>$$<br>要求原函数 $f(x)$ 的极小值，可以用求近似函数 $g(x)$ 的极小值来近似。因为 $g(x)$ 是关于 $x$ 的二次函数，所以令 $ g(x) = 0$ 求极小值点：<br>$$<br>f^{\prime}(x_0) + f^{\prime\prime}(x_0)(x - x_0) = 0<br>$$<br>即<br>$$<br>x = x_0 - \frac{f^{\prime}(x_0)}{f^{\prime\prime}(x_0)}<br>$$<br>得到迭代公式：<br>$$<br>x_n = x_{n - 1} - \frac{f^{\prime}(x_{n - 1})}{f^{\prime\prime}(x_{n - 1})}<br>$$<br><strong>对此公式的解释</strong>：</p>
<p>求解函数 $f(x)$ 的极小值，相当于求解导函数 $f^{\prime}$ 的零点。对于求函数的零点可以用切线的与 $x$ 轴的交点来迭代计算。首先，选择一个接近函数 $f^{\prime}(x_0)$ 零点的 $x_0$ ，计算相应的 $f^{\prime}(x_0)$ 和切线斜率 $f^{\prime\prime}(x_0)$ 。然后我们计算穿过点 $(x_0, f^{\prime}(x_0))$ 并且斜率为 $f^{\prime\prime}(x_0)$ 的直线和 $x$ 轴的交点的横坐标，也就是求如下方程的解：<br>$$<br>f^{\prime}(x_0) - 0 = f^{\prime\prime}(x_0)(x - x_0)<br>$$<br>我们将求得的点的 $x$ 坐标命名为 $x_1$ ，通常 $x_1$ 会比 $x_0$ 更接近方程 $f^{\prime}(x) = 0$ 的解。因此我们现在可以利用 $x_1$ 开始下一轮迭代。迭代公式可以化简为如下所示：<br>$$<br>x_n = x_{n-1} - \frac{f^{\prime}(x_{n-1})}{f^{\prime\prime}(x_{n-1})}<br>$$<br>转化成求极值点就是上面的导数形式。</p>
<p><strong>对于多元函数的牛顿法：</strong></p>
<p><strong>基本牛顿法</strong>（还有阻尼牛顿法以及修正牛顿法）</p>
<p>设 $f(\boldsymbol{x})$ 具有连续的二阶偏导数，当前迭代点是 $\boldsymbol{x}_k$ 。 $f(\boldsymbol{x})$ 在 $\boldsymbol{x}_k$ 处的Taylor展开为<br>$$<br>f(\boldsymbol{x}_k + \boldsymbol{d}) = f_k + \boldsymbol{g}^T_k \boldsymbol{d} + \frac{1}{2}\boldsymbol{d}^T \boldsymbol{G}_k \boldsymbol{d} + o(|\boldsymbol{d}|^2)<br>$$<br>其中 $ \boldsymbol{d} = \boldsymbol{x} - \boldsymbol{x}_k, f_k = f(\boldsymbol{x}_k)$，$\boldsymbol{g}_k$ 是梯度方向，$\boldsymbol{G}_k$ 是黑塞矩阵。. 在点 $\boldsymbol{x}_k$ 的邻域内，用二次函数<br>$$<br>q_k(\boldsymbol{d}) \triangleq f_k + \boldsymbol{g}^T_k \boldsymbol{d} +<br>\frac{1}{2} \boldsymbol{d}^T \boldsymbol{G}_k \boldsymbol{d}<br>$$<br>近似$f(\boldsymbol{x}_k + \boldsymbol{d})$，求解问题<br>$$<br>\min q_k(\boldsymbol{d}) = f_k + \boldsymbol{g}^T_k \boldsymbol{d} + \frac{1}{2} \boldsymbol{d}^T \boldsymbol{G}_k \boldsymbol{d}<br>$$<br>若 $\boldsymbol{G}_k$ 正定，对向量 $\boldsymbol{d}$ 求导，则方程组<br>$$<br>\boldsymbol{G}_k \boldsymbol{d} = - \boldsymbol{g}_k<br>$$<br>的解 $\boldsymbol{d}_k = - \boldsymbol{G}^{-1}_k \boldsymbol{g}_k$ 为上式的唯一解，我们称上式为Newton方程， $\boldsymbol{d}_k$ 为牛顿方向。用牛顿方向作为迭代方向的最优化方法称为牛顿方法。</p>
<p>基本牛顿方法指取步长 $\alpha_k = 1$ 的牛顿方法。在不引起混淆的情况下，基本牛顿方法简称为牛顿方法。在牛顿方法中，只要黑塞矩阵（Hessian Matrix）$\boldsymbol{G}_k$ 正定，牛顿方向 $\boldsymbol{d}_k$ 就是下降方向，因为<br>$$<br>\boldsymbol{g}^T_k \boldsymbol{d}_k = -\boldsymbol{g}^T_k\boldsymbol{G}^{-1}_k \boldsymbol{g}_k &lt; 0<br>$$<br>算法（基本牛顿法）</p>
<p>步1 给出 $ \boldsymbol{x}_0 \in \mathbb{R}^n, \varepsilon &gt; 0, k = 0$ ;</p>
<p>步2 若终止准则满足，则输出有关信息，停止迭代；</p>
<p>步3 由牛顿方程计算 $\boldsymbol{d}_k$ ；</p>
<p>步4 $\boldsymbol{x}_{k + 1} = \boldsymbol{x}_k + \boldsymbol{d}_k, k = k + 1$，转步2.</p>
<p><strong>牛顿方法的优缺点：</strong></p>
<p>牛顿方法的收敛性依赖于初始点的选择。当初始点接近极小点时，迭代序列收敛于极小点，并且收敛很快；否则就会出现迭代序列收敛到铵点或极大点的情形，或者在迭代过程中出现矩阵奇异或病态的情形，使线性方程组不能求解或不能很好地求解，导致迭代失败。</p>
<p>定理（基本牛顿方法的收敛性）设 $f(x) \in \mathbb{C}^2$, $f(x)$   的黑塞矩阵 $G(x)$ 满足 Lipschitz 条件，即存在$\beta &gt; 0$ ，对任给的 $x$ 与 $y$ ，有 $|G(x) - G(y)| \leq \beta |x - y|$ 若 $x_0$ 充分接近 $f(x)$ 的局部极小点 $x^{\star}$ ，且 $G^{\star}$ 正定，则牛顿方法对所有的 $k$ 有定义，并以二阶收敛速度收敛。</p>
<p>该定理说，只有当迭代点充分接近 $x^\star$ 时，基本牛顿方法的收敛性才能保证。</p>
<p><strong>优点</strong>：</p>
<p>1， 当 $x_0$ 充分接近问题的极小点 $x^\star$ 时，方法以二阶收敛速度收敛；</p>
<p>2， 方法具有二次终止性。</p>
<p><strong>缺点：</strong></p>
<p>1， 当 $x_0$ 没有充分接近问题的极小点 $x^\star$ 时，$G_k$ 会出现不正定或奇异的情形，使 ${x_k}$ 不能收敛到 $x^\star$ ，或使迭代无法进行；即使 $G_k$ 正定，也不能保证 ${f_k}$ 单调下降；</p>
<p>2， 每步迭代需要计算黑塞矩阵，即计算 $\frac{n(n+1)}{2}$ 个二阶偏导数；</p>
<p>3， 每步迭代需要解一个线性方程组，计算量为 $O(n^3)$ .</p>
<p>阻尼牛顿方法</p>
<p>为了改善牛顿方法的局部收敛性，我们可以采用带一维搜索的牛顿方法，即<br>$$<br>x_k = x_{k-1} + \alpha_{k-1}d_{k-1}<br>$$<br>其中，$\alpha_{k-1}$是一维搜索的结果。该方法称为阻尼牛顿方法，此方法能够保证对正定的$G_k$，${f_k}$ 单调下降，即使$x_k$离$x^\star$稍远，该方法产生的点列${x_k}$仍可能收敛至 $x^\star$。 对严格凸函数，采用 Wolfe 准则的阻尼牛顿方法具有全局收敛性。</p>
]]></content>
      <categories>
        <category>maths</category>
        <category>optimization</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>Newton</tag>
      </tags>
  </entry>
  <entry>
    <title>国自然申请书的一些建议</title>
    <url>/2020/01/08/nsfc-suggestion/</url>
    <content><![CDATA[<p>国家自然科学基金对于科研人员是无比重要的，除了补充科研经费，同时在一定程度上也是检验一个科研人员科研能力的试金石，如在研究思想、研究敏锐性、研究方法、同行评议等方面。那如何写出一份高质量的国自然申请书呢，这里给出一些个人建议，供参考。</p>
<a id="more"></a>

<p>写申请书之前需要问自己几个问题，根据这几个问题来撰写</p>
<ol>
<li>（立项依据）为什么要做该项目？提出科学问题</li>
<li>（研究背景）是否为<strong>前沿</strong>和<strong>热点</strong>研究问题？最好列出最近<strong>5年</strong>内国内外研究进展</li>
<li>（研究内容）做哪些事请能够解决提出的科学问题，实现预期目标？研究内容要与立项依据提出的问题一致，且有<strong>创新性</strong></li>
<li>（研究方法）具体如何去做？</li>
<li>（研究可行性）自己在该领域有哪些前期积累？重点介绍曾经做过的相关前期工作，自己是项目的最佳实践者，该项目<strong>能够很好的执行并完成</strong></li>
<li>（研究基础）为什么自己能够做该项目？要列出与研究内容<strong>相关</strong>的学术论文</li>
</ol>
<p>从立项依据到研究内容，从研究内容到研究方法，从研究方法到研究基础，都是一环扣一环，环环相扣，不能错节。申请书中不能出现语言错误、格式错误等。</p>
]]></content>
      <categories>
        <category>research</category>
      </categories>
      <tags>
        <tag>nsfc</tag>
        <tag>application</tag>
      </tags>
  </entry>
  <entry>
    <title>如何查看服务器上的 GPU 信息</title>
    <url>/2021/05/26/nvidia-smi-usage/</url>
    <content><![CDATA[<p>服务器上安装好了 GPU，同时也安装好了 nvidia drivers、cuda-toolkit、cudnn，那么如何查看 GPU 是否可以正常运行，已经如何读懂各参数信息呢？下面以 Ubuntu 18.04 来说明。</p>
<a id="more"></a>

<h1 id="nvcc"><a href="#nvcc" class="headerlink" title="nvcc"></a>nvcc</h1><p>cuda 编译器驱动程序 nvcc 的目的是向开发人员隐藏 cuda 编译的复杂细节。详细介绍请参考<a href="https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html">英伟达官网</a></p>
<p>这里主要是使用该程序查看 cuda 编译器工具的版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 nvcc 路径</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> whereis nvcc</span></span><br><span class="line">nvcc: /usr/local/cuda-10.0/bin/nvcc.profile /usr/local/cuda-10.0/bin/nvcc /usr/share/man/man1/nvcc.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 cuda 编译器工具的版本信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nvcc -V</span></span><br><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2018 NVIDIA Corporation</span><br><span class="line">Built on Sat_Aug_25_21:08:01_CDT_2018</span><br><span class="line">Cuda compilation tools, release 10.0, V10.0.130</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 cuda 编译器工具的版本信息</span></span><br><span class="line">-version</span><br><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2018 NVIDIA Corporation</span><br><span class="line">Built on Sat_Aug_25_21:08:01_CDT_2018</span><br><span class="line">Cuda compilation tools, release 10.0, V10.0.130</span><br></pre></td></tr></table></figure>

<p>可以看到安装的 cuda 版本是 10.0.130</p>
<h1 id="nvidia-smi"><a href="#nvidia-smi" class="headerlink" title="nvidia-smi"></a>nvidia-smi</h1><p>nvidia-smi (NVIDIA System Management Interface) 是一种命令行实用工具，帮助管理和监控 NVIDIA GPU 设备。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nvidia-smi</span></span><br><span class="line">Wed May 26 11:14:18 2021</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 460.73.01    Driver Version: 460.73.01    CUDA Version: 11.2     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                               |                      |               MIG M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  Tesla V100-PCIE...  Off  | 00000000:3B:00.0 Off |                    0 |</span><br><span class="line">| N/A   22C    P0    33W / 250W |      0MiB / 32510MiB |      0%      Default |</span><br><span class="line">|                               |                      |                  N/A |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">|   1  GeForce GTX TIT...  Off  | 00000000:AF:00.0 Off |                  N/A |</span><br><span class="line">| 20%   29C    P0    70W / 250W |      0MiB / 12212MiB |      0%      Default |</span><br><span class="line">|                               |                      |                  N/A |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">|   2  GeForce GTX TIT...  Off  | 00000000:D8:00.0 Off |                  N/A |</span><br><span class="line">| 20%   26C    P0    64W / 250W |      0MiB / 12212MiB |      2%      Default |</span><br><span class="line">|                               |                      |                  N/A |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                                  |</span><br><span class="line">|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |</span><br><span class="line">|        ID   ID                                                   Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|  No running processes found                                                 |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>显示参数解释：</p>
<ol>
<li><strong>Wed May 26 11:14:18 2021</strong> ：表示命令运行时间，也是指代  GPU 运行情况的具体时间</li>
<li><strong>NVIDIA-SMI 460.73.01    Driver Version: 460.73.01    CUDA Version: 11.2</strong> ：表示安装的 cuda 驱动器版本和 cuda 版本</li>
<li><strong>GPU</strong> ：表示 GPU 编号，从0开始</li>
<li><strong>Fan</strong> ：表示 GPU 风扇转速，0-100%，当为 N/A 时表示设备不依赖风扇降温</li>
<li><strong>Name</strong> ：表示 GPU 名称</li>
<li><strong>Temp</strong> ：表示 GPU 当前运行温度</li>
<li><strong>Perf</strong> ：表示 GPU 性能状态，P0 ~ P12，P0 表示性能最大（一般 GPU 未使用状态性能，当使用时性能降低），P12 表示性能最小</li>
<li><strong>Persistence-M</strong> ：表示持续模式的状态，默认关闭。持续模式打开，当新的 GPU 应用启动时，花费时间更少。但持续模式打开耗能大</li>
<li><strong>Pwr:Usage/Cap</strong> ：表示 GPU 能耗情况，包括当前消耗功率和最大功率</li>
<li><strong>Bus-Id</strong> ：表示 GPU 总线信息</li>
<li><strong>Disp.A</strong> ：表示 Display Active 的意思，表示GPU的显示是否初始化</li>
<li><strong>Memory-Usage</strong> ：表示 GPU 显存情况，包括当前消耗显存以及最大显存</li>
<li><strong>GPU-Util</strong> ：表示 GPU 的利用率，当 GPU 没有使用时，显示 0%，当 GPU 使用时，显示大于 0%</li>
<li><strong>Volatile Uncorr. ECC</strong> ：ECC (error correcting code, 错误检查和纠正) 该功能可以提高数据的正确性，随之而来的是可用显存的减少和性能上的损失。</li>
<li><strong>Compute M.</strong> ：表示 GPU 计算模式</li>
<li><strong>MIG M.</strong> ： Multi-Instance GPU （MIG） 模式，创建基于 MIG 的 vGPU 实例需要将 GPU 切换到 MIG 模式，此配置为持久配置，只需执行一次，重启服务器后仍然有效: nvidia-smi -mig 1</li>
<li><strong>Processes</strong> ：表示使用 GPU 的进程信息</li>
</ol>
<h2 id="cuda-版本号不一致？"><a href="#cuda-版本号不一致？" class="headerlink" title="cuda 版本号不一致？"></a>cuda 版本号不一致？</h2><p>细心的同志会发现使用 <code>nvcc -V</code> 和使用 <code>nvidia-smi</code> 查看的 cuda 版本号不一致，这是什么原因呢。</p>
<p>nvcc 是 cuda 编译器，nvidia-smi 是NVIDIA System Management Interface，一种命令行工具。<code>nvcc -V</code> 显示的 cuda 版本对应 runtime api (运行时)，<code>nvidia-smi</code> 对应 driver api；nvcc 是通过 cuda-toolkit 安装，<code>nvidia-smi</code> 是通过 nvidia drivers 安装；nvcc 只知道自身构建是的 cuda runtime 版本，不知道安装的 nvidia drivers 版本，甚至不知道服务器上是否安装了 GPU driver.</p>
<p>通常，driver api 的版本能向下兼容 runtime api 的版本。因此，当 <code>nvidia-smi</code> 显示的 cuda 版本大于 <code>nvcc -V</code> 显示的 cuda 版本时没有问题，但是反过来小于就不行。</p>
<h2 id="pytorch-安装基于哪个-cuda-版本？"><a href="#pytorch-安装基于哪个-cuda-版本？" class="headerlink" title="pytorch 安装基于哪个 cuda 版本？"></a>pytorch 安装基于哪个 cuda 版本？</h2><p>在 pytorch 官网上可以发现，当使用 conda 安装 pytorch 时，指定的版本信息是 cudatoolkit，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio cudatoolkit=10.2 -c pytorch</span><br></pre></td></tr></table></figure>

<p>因此，我们应该选择与 <code>nvcc -V</code> 对应的 cuda 版本来安装 pytorch. 另外，只要大版本对应即可，如 cudatooklit=10.x 对应 Cuda compilation tools, release 10.0, V10.0.130，完全可以使用。</p>
<h1 id="其他-nvidia-smi-参数"><a href="#其他-nvidia-smi-参数" class="headerlink" title="其他 nvidia-smi 参数"></a>其他 nvidia-smi 参数</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 实时刷新显示</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nvidia-smi -l</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每5s刷新一次</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> watch -n 5 nvidia-smi</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有 GPU 名称</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nvidia-smi -L</span></span><br><span class="line">GPU 0: Tesla V100-PCIE-32GB (UUID: GPU-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)</span><br><span class="line">GPU 1: GeForce GTX TITAN X (UUID: GPU-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)</span><br><span class="line">GPU 2: GeForce GTX TITAN X (UUID: GPU-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)</span><br><span class="line"><span class="meta">$</span><span class="bash"> nvidia-smi --list-gpus</span></span><br><span class="line">GPU 0: Tesla V100-PCIE-32GB (UUID: GPU-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)</span><br><span class="line">GPU 1: GeForce GTX TITAN X (UUID: GPU-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)</span><br><span class="line">GPU 2: GeForce GTX TITAN X (UUID: GPU-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看帮助信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nvidia-smi -h</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把信息写入文件中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nvidia-smi -f cuda.log</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只显示指定序号的GPU</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nvidia-smi -i 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 -q 显示更详细的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nvidia-smi -q -i 0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nvidia-smi -q -i 0 -f gpu1.log</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以 xml 格式输出信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nvidia-smi -q -x</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nvidia-smi -q -x -i 0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nvidia-smi -q -x -i 0 -f gpu1.log</span></span><br></pre></td></tr></table></figure>

<h1 id="pytorch-中使用-GPU"><a href="#pytorch-中使用-GPU" class="headerlink" title="pytorch 中使用 GPU"></a>pytorch 中使用 GPU</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定使用的GPU，应放在代码最前面</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;CUDA_VISIBLE_DEVICES&quot;</span>] = <span class="string">&#x27;0,1&#x27;</span>  <span class="comment"># 指定使用第1,2块GPU</span></span><br><span class="line"><span class="comment"># 查看 GPU 是否可以使用</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">print(torch.cuda.is_available())</span><br><span class="line">&gt; <span class="literal">True</span></span><br><span class="line"><span class="comment"># 查看有多少个GPU，注意，当使用 os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &#x27;0,1&#x27; 设定环境后，torch只能发现指定的GPU</span></span><br><span class="line">torch.cuda.device_count()</span><br><span class="line">&gt; <span class="number">2</span></span><br><span class="line"><span class="comment"># 查看指定第1个GPU的属性</span></span><br><span class="line">&gt; _CudaDeviceProperties(name=<span class="string">&#x27;Tesla V100-PCIE-32GB&#x27;</span>, major=<span class="number">7</span>, minor=<span class="number">0</span>, total_memory=<span class="number">32510</span>MB, multi_processor_count=<span class="number">80</span>)</span><br><span class="line"><span class="comment"># 查看当前GPU</span></span><br><span class="line">torch.cuda.current_device()</span><br><span class="line">&gt; <span class="number">0</span></span><br><span class="line"><span class="comment"># 查看第1个GPU的名称</span></span><br><span class="line">torch.cuda.get_device_name(<span class="number">0</span>)</span><br><span class="line">&gt; <span class="string">&#x27;Tesla V100-PCIE-32GB&#x27;</span></span><br><span class="line"><span class="comment"># 查看第1个GPU的算力，与torch.cuda.get_device_properties(0)对应，major=7, minor=0, 表示主算力和次算力，一般只需要看主算力，在NVIDIA官网上有每类GPU算力表</span></span><br><span class="line">torch.cuda.get_device_capability(<span class="number">0</span>)</span><br><span class="line">&gt; (<span class="number">7</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 使用某一个GPU</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span>)</span><br><span class="line"><span class="comment"># 使用GPU计算</span></span><br><span class="line">a = torch.randn(<span class="number">10000</span>, <span class="number">1000</span>)</span><br><span class="line">b = torch.randn(<span class="number">1000</span>, <span class="number">10000</span>)</span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda:0&#x27;</span>)</span><br><span class="line">a = a.to(device)</span><br><span class="line">b = b.to(device)</span><br><span class="line">torch.matmul(a, b)</span><br></pre></td></tr></table></figure>

<h1 id="NVIDIA-SMI-has-failed-because-it-couldn’t-communicate-with-the-NVIDIA-driver-错误"><a href="#NVIDIA-SMI-has-failed-because-it-couldn’t-communicate-with-the-NVIDIA-driver-错误" class="headerlink" title="NVIDIA-SMI has failed because it couldn’t communicate with the NVIDIA driver. 错误"></a>NVIDIA-SMI has failed because it couldn’t communicate with the NVIDIA driver. 错误</h1><p>不知道什么情况，某次运行命令 <code>nvidia-smi</code> 时报上述错误，考虑可能是更新系统或者按照模型软件导致的，也可能是开关机导致的内核版本与安装驱动时的版本不匹配造成。解决方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 nvidia drivers 是否还在</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> whereis nvidia</span></span><br><span class="line">nvidia: /usr/lib/x86_64-linux-gnu/nvidia /usr/lib/nvidia /usr/share/nvidia /usr/src/nvidia-460.73.01/nvidia</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> DKMS(Dynamic Kernel Module Support)维护内核外的驱动程序，内核版本变动之后可以自动重新生成新的模块。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install dkms</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 nvidia drivers 版本 460.73.01，从 whereis nvidia 运行结果中查看</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo dkms install -m nvidia -v 460.73.01</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果报错，缺少linux-headers-5.4.0-73-generic或linux-hwe-5.4-headers，需要手动下载这些DEB文件，然后安装，最后在使用dkms安装对应的 nvidia 驱动就可以了</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg -i linux-hwe-5.4-headers-5.4.0-73_5.4.0-73.82_18.04.1_all.deb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg -i linux-headers-5.4.0-73-generic_5.4.0-73.82_18.04.1_amd64.deb</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者使用如下方法安装 linux-headers</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install linux-headers-$(uname -r)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用nvidia-smi测试一下，成功后可不用使用下面代码；如果不成功请运行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo dkms install -m nvidia -v 460.73.01</span></span><br></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://www.jianshu.com/p/eb5335708f2a">【CUDA】nvcc和nvidia-smi显示的版本不一致？</a></li>
<li><a href="https://blog.csdn.net/ljp1919/article/details/102640512">nvidia-smi 和 nvcc 结果的版本为何不一致</a></li>
<li><a href="https://blog.csdn.net/wumenglu1018/article/details/103057009">nvidia-smi查看GPU的使用信息并分析</a></li>
<li><a href="https://www.jianshu.com/p/f55b86a9cc72">实用的 NVIDIA-SMI 查询示例</a></li>
<li><a href="https://blog.csdn.net/Bruce_0712/article/details/63683787">CUDA之nvidia-smi命令详解</a></li>
<li><a href="https://www.jianshu.com/p/3cedce05a481">ubuntu关机开机后显卡挂了：报错NVIDIA-SMI has failed because it couldn’t communicate with the NVIDIA driver. M…</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>server</tag>
        <tag>gpu</tag>
        <tag>nvidia-smi</tag>
      </tags>
  </entry>
  <entry>
    <title>单目标跟踪数据集</title>
    <url>/2021/12/14/object-tracking-datasets/</url>
    <content><![CDATA[<p>目标跟踪数据集有很多，这里汇集单目标跟踪数据集，给出链接以及数据集说明。</p>
<a id="more"></a>

<h1 id="LaSOT"><a href="#LaSOT" class="headerlink" title="LaSOT"></a>LaSOT</h1><p><strong>La</strong>rge-scale <strong>S</strong>ingle <strong>O</strong>bject <strong>T</strong>racking (<strong>LaSOT</strong>) 是天普大学，华南理工大学，鹏城实验室，美图-亮风台联合实验室等提出，第一作者是 <a href="hefan@cs.stonybrook.edu">Heng Fan</a> ，该数据集数据量大，用于评估长时跟踪性能，特点如下：</p>
<ul>
<li><strong>Large-scale:</strong> 1,550 sequences with more 3.87 millions frames</li>
<li><strong>High-quality:</strong> Manual annotation with careful inspection in each frame</li>
<li><strong>Category balance:</strong> 85 categories with each containing twenty (70 classes) or ten (15 classes) sequences</li>
<li><strong>Long-term tracking:</strong> An average video length of around 2,500 frames (i.e., 83 seconds)</li>
<li><strong>Comprehensive labeling:</strong> Providing both visual and lingual annotation for each sequence</li>
<li><strong>Flexible Evaluation Protocol:</strong> Evaluation under three different protocols: no constraint, full-overlap and one-shot</li>
</ul>
<p>相关文章：</p>
<p><a href="https://arxiv.org/abs/2009.03465">LaSOT: A High-quality Large-scale Single Object Tracking Benchmark</a><br>H. Fan*, H. Bai*, L. Lin, F. Yang, P. Chu, G. Deng, S. Yu, Harshit, M. Huang, J Liu, Y. Xu, C. Liao, L Yuan, and H. Ling<br><em>International Journal of Computer Vision (<strong>IJCV</strong>)</em>, 2020. (accepted)</p>
<p><a href="https://arxiv.org/abs/1809.07845">LaSOT: A High-quality Benchmark for Large-scale Single Object Tracking</a><br>H. Fan*, L. Lin*, F. Yang*, P. Chu*, G. Deng, S. Yu, H. Bai, Y. Xu, C. Liao, and H. Ling<br><em>IEEE Conference on Computer Vision and Pattern Recognition (<strong>CVPR</strong>)</em>, 2019.</p>
<p>相关博客：<a href="https://www.leiphone.com/category/academic/NhOeLVXzIdLVSxyU.html">亮风台</a></p>
<p>官方数据集下载地址：<a href="http://vision.cs.stonybrook.edu/~lasot/download.html">http://vision.cs.stonybrook.edu/~lasot/download.html</a></p>
<p>类别：70</p>
<p>视频：1400</p>
<p>大小：大约227G</p>
<p>注释：边界框、完全遮挡、视野外标志以及语言描述</p>
<p>边界框： <code>[x, y, width, height] </code></p>
<p>评估方法：one-pass evaluation (OPE)</p>
<p>评估度量：<strong>Precision</strong>, <strong>Normalized Precision</strong> and <strong>Success</strong></p>
<p>评估工具集：<a href="https://github.com/HengLan/LaSOT_Evaluation_Toolkit">https://github.com/HengLan/LaSOT_Evaluation_Toolkit</a></p>
<h1 id="GOT-10k"><a href="#GOT-10k" class="headerlink" title="GOT-10k"></a>GOT-10k</h1><p><strong>G</strong>eneric <strong>O</strong>bject <strong>T</strong>racking (GOT-10k) 是有中科院自动化所提出，第一作者是Lianghua Huang，该数据集是一个用于野外通用对象跟踪的大型、高多样性、一次性（one-shot）数据集。</p>
<p>相关文章：</p>
<p>GOT-10k: A Large High-Diversity Benchmark for Generic Object Tracking in the Wild.<br>L. Huang*, X. Zhao*, and K. Huang. <em>( \</em>Equal contribution)*<br><em>IEEE Transactions on Pattern Analysis and Machine Intelligence (TPAMI).</em><br>[<a href="https://arxiv.org/abs/1810.11981">PDF</a>] [<a href="http://got-10k.aitestunion.com/bibtex">BibTex</a>]</p>
<p>官方数据集下载地址：<a href="http://got-10k.aitestunion.com/downloads">http://got-10k.aitestunion.com/downloads</a></p>
<p>类别：563目标类，87运动类</p>
<p>图像：10k</p>
<p>大小：66G</p>
<p>注释：边界框、对象可见率、对象存在与否、对象是否在每帧中被图像切割以及序列的元信息（对象、运动类、URL）；注释采用 txt 文档</p>
<p>边界框： <code>[xmin, ymin, width, height] </code></p>
<p>评估方法：one-shot protocol</p>
<p>评估度量：mAO (mean average overlap)， mSR (mean success rate)</p>
<p>评估工具集：<a href="https://github.com/got-10k/toolkit">https://github.com/got-10k/toolkit</a></p>
<h1 id="COCO"><a href="#COCO" class="headerlink" title="COCO"></a>COCO</h1><p><strong>C</strong>ommon <strong>O</strong>bjects in <strong>Co</strong>ntext (COCO) 是微软提出的，该数据集是一个大规模的对象检测（object detection）、分割（segmentation）和图像标注（captioning，看图说话）数据集。特点如下：</p>
<ul>
<li>图片大多数来源于生活中，背景更复杂</li>
<li>每张图片上的实例目标个数多，平均每张图片7.7个</li>
<li>小目标更多</li>
<li>评估标准更严格</li>
</ul>
<p>相关博客：<a href="https://arleyzhang.github.io/articles/e5b86f16/">目标检测数据集MSCOCO简介</a></p>
<p>相关文章：</p>
<p>Lin, T. Y., Maire, M., Belongie, S., Hays, J., Perona, P., Ramanan, D., … &amp; Zitnick, C. L. (2014, September). Microsoft coco: Common objects in context. In <em>European conference on computer vision</em> (pp. 740-755). Springer, Cham.</p>
<p>[<a href="https://link.springer.com/content/pdf/10.1007/978-3-319-10602-1_48.pdf">PDF</a>]</p>
<p>官方数据集下载地址：<a href="https://cocodataset.org/#download">https://cocodataset.org/#download</a></p>
<p>类别：80目标类，91 stuff categories, 5 captions per image, 250k people with keypoints</p>
<p>图像：330K（&gt;200K 标注）；1.5 million 目标实例；平均每张图片包含的3.5个类别和7.7个目标；小目标占比较ImageNet多；包含大约 41% 的小目标 ($\textbf{area} &lt; 32 \times 32$), 34% 的中等目标 ($ 32 \times 32 &lt; \textbf{area} &lt; 96 \times 96$) 和 24% 的大目标 ($\textbf{area} &gt; 96 \times 96$).</p>
<p>大小：46G（2017）</p>
<p>注释：包含id, image_id, category_id, segmentation, area, iscrowd, bbox；注释采用JSON文件</p>
<p>边界框： <code>[x, y, width, height] </code></p>
<p>评估方法：one-pass evaluation (OPE)</p>
<p>评估度量：mAP (mean average precision)， mAR (mean average recall)</p>
<p>评估工具集：<a href="https://github.com/cocodataset/cocoapi">https://github.com/cocodataset/cocoapi</a></p>
<h1 id="TrackingNet"><a href="#TrackingNet" class="headerlink" title="TrackingNet"></a>TrackingNet</h1><p>TrackingNet 是阿卜杜拉国王科技大学提出的，该数据集是野外目标跟踪的大规模数据集和基准。</p>
<p>相关博客：<a href="https://blog.csdn.net/xwmwanjy666/article/details/98525030">目标跟踪数据集整理（一）—TrackingNet</a></p>
<p>相关文章：</p>
<p>Muller, M., Bibi, A., Giancola, S., Alsubaihi, S., &amp; Ghanem, B. (2018). Trackingnet: A large-scale dataset and benchmark for object tracking in the wild. In <em>Proceedings of the European Conference on Computer Vision (ECCV)</em> (pp. 300-317).</p>
<p>[<a href="https://openaccess.thecvf.com/content_ECCV_2018/papers/Matthias_Muller_TrackingNet_A_Large-Scale_ECCV_2018_paper.pdf">PDF</a>]</p>
<p>官方数据集下载地址：<a href="https://tracking-net.org/">https://tracking-net.org/</a></p>
<p>类别：23目标类，人分为7个详细类别</p>
<p>视频：&gt;30K；平均时长为16.6s，1443,1266 帧</p>
<p>大小：1.1T</p>
<p>注释：scale variation; aspect ratio change; fast motiong; low resolution; out-of-view etc.</p>
<p>边界框： <code>[x, y, width, height] </code></p>
<p>评估方法：one-pass evaluation (OPE)</p>
<p>评估度量：<strong>success S</strong>， <strong>precision P</strong>， <strong>Pnorm</strong></p>
<p>评估工具集：<a href="https://github.com/SilvioGiancola/TrackingNet-devkit">https://github.com/SilvioGiancola/TrackingNet-devkit</a></p>
]]></content>
      <categories>
        <category>research</category>
        <category>object tracking</category>
      </categories>
      <tags>
        <tag>object tracking</tag>
        <tag>datasets</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 OpenCV(Python) 读取网上的图片和视频</title>
    <url>/2021/10/03/opencv-read-image-video-online/</url>
    <content><![CDATA[<p>在进行目标跟踪研究中,有时候需要直接读取网上的图片和视频,这时候利用 OpenCV 再加上 <code>urllib</code>、<code>pafy</code>、<code>numpy</code> 等就可以直接获取互联网上的各种图片和视频资源.</p>
<a id="more"></a>

<h1 id="从网上读取图片"><a href="#从网上读取图片" class="headerlink" title="从网上读取图片"></a>从网上读取图片</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line">url_img = <span class="string">&#x27;https://img0.baidu.com/it/u=1073044967,3931799334&amp;fm=26&amp;fmt=auto&#x27;</span></span><br><span class="line">res = urllib.request.urlopen(url_img)</span><br><span class="line">i = np.asarray(bytearray(res.read()), dtype=<span class="string">&quot;uint8&quot;</span>)</span><br><span class="line">img = cv2.imdecode(i, cv2.IMREAD_COLOR)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 彩色图像</span></span><br><span class="line">plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))</span><br><span class="line">plt.imshow(img[:, :, ::<span class="number">-1</span>])</span><br><span class="line"><span class="comment"># plt.imshow(img[:, :, [2, 1, 0]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 灰度图像</span></span><br><span class="line">imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">plt.imshow(imgray, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时画多幅图</span></span><br><span class="line">plt.imshow(np.hstack((imgray, imgray)), cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不显示坐标轴</span></span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>彩色图片显示如下:</p>
<p><img src="https://img0.baidu.com/it/u=1073044967,3931799334&fm=26&fmt=auto"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># h, w, c 分别是高、宽、通道</span></span><br><span class="line">img.shape</span><br><span class="line"><span class="comment"># (360, 450, 3)</span></span><br></pre></td></tr></table></figure>

<h1 id="从网上读取视频"><a href="#从网上读取视频" class="headerlink" title="从网上读取视频"></a>从网上读取视频</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pafy</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># The YouTube url or 11 character video id of the video</span></span><br><span class="line">url_video = <span class="string">&#x27;https://youtu.be/2kS0T7fwxJo&#x27;</span></span><br><span class="line"><span class="comment"># Preferred type, set to mp4, webm, flv, 3gp or any</span></span><br><span class="line"><span class="comment"># 把分享的视频地址,转化为 .mp4 地址,如何 cv2.VideoCapture() 直接读取</span></span><br><span class="line">v = pafy.new(url_video).getbestvideo(preftype=<span class="string">&#x27;mp4&#x27;</span>)</span><br><span class="line"><span class="comment"># 如果地址是&quot;*.mp4&quot;的,可以直接读取</span></span><br><span class="line">vc = cv2.VideoCapture(v.url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> vc.isOpened():</span><br><span class="line">    open = <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    open = <span class="literal">False</span></span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> open:</span><br><span class="line">    ret, frame = vc.read()</span><br><span class="line">    <span class="keyword">if</span> frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">        flag += <span class="number">1</span></span><br><span class="line">vc.release()</span><br><span class="line"><span class="string">&quot;total frame is &quot;</span>, flag</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>1.<a href="https://pythonhosted.org/pafy/">Pafy Documentation</a></p>
]]></content>
      <categories>
        <category>research</category>
        <category>object tracking</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>opencv</tag>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV (Python) 中 BGR 和 RGB 的转换</title>
    <url>/2021/10/03/opencv-rgb-bgr/</url>
    <content><![CDATA[<p>在目标跟踪中经常会使用到 OpenCV 和 Pillow 库等来处理图像。但是，它们处理图像的方式有所不同，比如 OpenCV 把图像看作一个 <code>ndarray</code> 数组对象，而 Pillow 把图像看作一个自定义的 <code>Image</code> 对象；OpenCV 中图像是以 <code>BGR</code> (blue, green , red) 顺序存储的，而 Pillow 中的图像是以 <code>RGB</code> (red, green , blue) 存储的。因此，如果想要同时使用两种库的函数，需要进行相应的 <code>BGR</code> 和 <code>RGB</code> 的转换。</p>
<a id="more"></a>

<p>OpenCV 中图像的 <code>BGR</code> 和 <code>RGB</code> 的转换可以有两种方法：</p>
<ol>
<li>通过 OpenCV 内置的 <code>cvtColor()</code> 函数;</li>
<li>直接改变 <code>ndarray</code> 的存储顺序。</li>
</ol>
<h1 id="图像读取与写入"><a href="#图像读取与写入" class="headerlink" title="图像读取与写入"></a>图像读取与写入</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入包</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenCV 中以 BGR 的顺序读取图像 ndarray 对象，以同样方式写入。</span></span><br><span class="line"><span class="comment"># 打开时才可正常显示</span></span><br><span class="line">im_bgr_cv = cv2.imread(<span class="string">&#x27;data/lena.jpg&#x27;</span>)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;data/dst/lena_bgr_cv.jpg&#x27;</span>, im_bgr_cv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pillow 以 RGB 的顺序读取图像 Image 对象，以同样方式写入</span></span><br><span class="line"><span class="comment"># 打开时才可正常显示</span></span><br><span class="line">im_rgb_pil = Image.fromarray(im_bgr_cv[:, :, ::<span class="number">-1</span>])</span><br><span class="line">im_rgb_pil = Image.fromarray(im_bgr_cv[:, :, [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">im_rgb_pil = Image.fromarray(cv2.cvtColor(im_bgr_cv, cv2.COLOR_BGR2RGB))</span><br><span class="line">im_rgb_pil.save(<span class="string">&#x27;data/dst/lena_rgb_pil.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="cvtColor-转化-BGR-和-RGB"><a href="#cvtColor-转化-BGR-和-RGB" class="headerlink" title="cvtColor() 转化 BGR 和 RGB"></a>cvtColor() 转化 BGR 和 RGB</h1><p>在 OpenCV 中, 不同的颜色空间(如 <code>RGB, BGR, HSV</code>) 可以利用函数 <code>cvtColor()</code> 函数进行转换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dst = cv2.cvtColor(src, code)</span><br><span class="line"><span class="comment"># src 表示转换前的图像</span></span><br><span class="line"><span class="comment"># dst 表示转换后的图像</span></span><br><span class="line"><span class="comment"># code 表示转换方式, 如 cv2.COLOR_BGR2RGB、cv2.COLOR_RGB2GBR</span></span><br></pre></td></tr></table></figure>

<h2 id="BGR-转换为-RGB"><a href="#BGR-转换为-RGB" class="headerlink" title="BGR 转换为 RGB"></a>BGR 转换为 RGB</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">im_rgb_cv = cv2.cvtColor(im_bgr_cv, cv2.COLOR_BGR2RGB)</span><br><span class="line">im_rgb_pil = Image.fromarray(im_rgb_cv)</span><br><span class="line"><span class="comment"># 在 Pillow 中处理</span></span><br><span class="line">im_rgb_pil.save(<span class="string">&#x27;data/dst/lena_rgb_pillow.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="RGB-转换为-BGR"><a href="#RGB-转换为-BGR" class="headerlink" title="RGB 转换为 BGR"></a>RGB 转换为 BGR</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">im_rgb_pillow = Image.open(<span class="string">&#x27;data/src/lena.jpg&#x27;</span>)</span><br><span class="line">im_bgr = cv2.cvtColor(np.array(im_rgb_pillow), cv2.COLOR_RGB2BGR)</span><br><span class="line"><span class="comment"># 在 OpenCV 中处理</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;data/dst/lena_bgr_cv_2.jpg&#x27;</span>, im_bgr)</span><br></pre></td></tr></table></figure>

<h1 id="直接在-ndarray-中转换"><a href="#直接在-ndarray-中转换" class="headerlink" title="直接在 ndarray 中转换"></a>直接在 ndarray 中转换</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">im_bgr = cv2.imread(<span class="string">&#x27;data/src/lena.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">im_rgb = im_bgr[:, :, [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">Image.fromarray(im_rgb).save(<span class="string">&#x27;data/dst/lena_swap.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">im_rgb = im_bgr[:, :, ::<span class="number">-1</span>]</span><br><span class="line">Image.fromarray(im_rgb).save(<span class="string">&#x27;data/dst/lena_swap_2.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>1.<a href="https://note.nkmk.me/en/python-opencv-bgr-rgb-cvtcolor/">Convert BGR and RGB with Python, OpenCV (cvtColor)</a></p>
]]></content>
      <categories>
        <category>research</category>
        <category>object tracking</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>Python为pip使用其他源来安装包</title>
    <url>/2020/02/19/pip-pypi-tuna/</url>
    <content><![CDATA[<p>Python 是一种非常优秀的编程语言，特别是在人工智能中研发中使用很多，Python包索引（缩写为PyPI，也称为Cheese Shop）是Python的官方第三方软件存储库。其使用pip命令来管理软件安装。</p>
<a id="more"></a>

<p>有时候使用pip安装软件时，会提示链接超时，这时可以采用切换源的方式来安装软件，切换到国内的源能够很快速的成功安装这些软件。</p>
<p>下面列出可用的源</p>
<ol>
<li><a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> 清华源（推荐，该镜像每 5 分钟同步一次。）</li>
<li><a href="https://mirrors.aliyun.com/pypi/simple">https://mirrors.aliyun.com/pypi/simple</a> 阿里云源</li>
<li><a href="https://pypi.doubanio.com/simple">https://pypi.doubanio.com/simple</a> 豆瓣源</li>
<li><a href="https://mirrors.163.com/pypi/simple">https://mirrors.163.com/pypi/simple</a> 网易源 （每24小时更新一次）</li>
<li><a href="https://mirrors.cloud.tencent.com/pypi/simple">https://mirrors.cloud.tencent.com/pypi/simple</a> 腾讯云源</li>
<li><a href="https://mirrors.bfsu.edu.cn/pypi/web/simple">https://mirrors.bfsu.edu.cn/pypi/web/simple</a> 中科大源</li>
</ol>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="临时使用国内源"><a href="#临时使用国内源" class="headerlink" title="临时使用国内源"></a>临时使用国内源</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</span><br></pre></td></tr></table></figure>

<h2 id="永久使用设置默认源"><a href="#永久使用设置默认源" class="headerlink" title="永久使用设置默认源"></a>永久使用设置默认源</h2><h3 id="命令行设置默认源"><a href="#命令行设置默认源" class="headerlink" title="命令行设置默认源"></a>命令行设置默认源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pip -U</span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>如果您到 pip 默认源的网络连接较差，临时使用本镜像站来升级 pip：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U</span><br></pre></td></tr></table></figure>

<h3 id="手动修改配置文件"><a href="#手动修改配置文件" class="headerlink" title="手动修改配置文件"></a>手动修改配置文件</h3><p>Linux 系统配置如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改 pip.conf 文件 (没有就创建一个)</span></span><br><span class="line">vim ~/.config/pip/pip.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加如下内容</span></span><br><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>Mac 系统配置如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改 pip.conf 文件</span></span><br><span class="line">vim ~/Library/Application Support/pip/pip.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有上面的目录, 在如下目录创建 pip.conf 文件</span></span><br><span class="line">vim ~/.config/pip/pip.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加如下内容</span></span><br><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>Windows 系统配置如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改 pip.conf 文件</span></span><br><span class="line">%APPDATA%\pip\pip.ini</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加如下内容</span></span><br><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p><font size=3 color=cyan>修改文件后，执行命令发生错误</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用非 HTTPS 加密源，在执行命令发生错误，在命令最后加上 `--trusted-host pypi.douban.com`</span></span><br><span class="line">pip install django -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</span><br><span class="line"><span class="comment"># 建议使用 HTTPS 加密源</span></span><br></pre></td></tr></table></figure>

<h3 id="使用包管理工具设置"><a href="#使用包管理工具设置" class="headerlink" title="使用包管理工具设置"></a>使用包管理工具设置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pip-setting</span><br><span class="line">pip-setting -s qinghua</span><br></pre></td></tr></table></figure>

<h1 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install pysocks</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装文件里列出的软件</span></span><br><span class="line">pip install -r requirements.txt --proxy=&#x27;socks5://127.0.0.1:1080&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装某一个软件</span></span><br><span class="line">pip install torch --proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<h1 id="更新所有包"><a href="#更新所有包" class="headerlink" title="更新所有包"></a>更新所有包</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip list --outdate --format=freeze | grep -v <span class="string">&#x27;^\-e&#x27;</span> | cut -d = -f 1 | xargs -n1 pip install -U</span><br></pre></td></tr></table></figure>

<h1 id="常用-pip-命令"><a href="#常用-pip-命令" class="headerlink" title="常用  pip 命令"></a>常用  pip 命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出 pip 安装的包</span></span><br><span class="line">pip list</span><br><span class="line"><span class="comment"># 列出过时的包</span></span><br><span class="line">pip list -o</span><br><span class="line">pip list --outdate</span><br><span class="line"><span class="comment"># 显示指定的包</span></span><br><span class="line">pip show numpy scipy</span><br><span class="line"><span class="comment"># 升级指定的包</span></span><br><span class="line">pip install --upgrade numpy scipy</span><br><span class="line">pip install -U numpy scipy</span><br><span class="line"><span class="comment"># 升级到指定版本的包</span></span><br><span class="line">pip install -U numpy==1.21.1</span><br><span class="line"><span class="comment"># 安装指定版本的包</span></span><br><span class="line">pip install numpy==1.21.1</span><br><span class="line"><span class="comment"># 卸载包</span></span><br><span class="line">pip uninstall numpy</span><br></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><p><a href="https://www.activestate.com/resources/quick-reads/how-to-update-all-python-packages/">How To Update All Python Packages</a></p>
</li>
<li><p><a href="https://mirrors.163.com/.help/pypi.html">网易pypi镜像使用帮助</a></p>
</li>
<li><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/">清华镜像使用帮助</a></p>
</li>
<li><p><a href="https://developer.aliyun.com/article/652884">更换（Pypi）pip源到国内镜像</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title>定积分的性质</title>
    <url>/2020/09/12/properties-of-definite-integral/</url>
    <content><![CDATA[<p>了解定积分的性质可以帮助我们方便计算定积分，提高计算的速度。</p>
<a id="more"></a>

<h1 id="定积分的基本性质"><a href="#定积分的基本性质" class="headerlink" title="定积分的基本性质"></a>定积分的基本性质</h1><p><strong>性质1</strong>    若$f$在$[a,b]$上可积，$k$为常数，则$kf$在$[a,b]$上也可积，且<br>$$<br>\int^b_a k f(x) \mathrm{d}x = k \int^b_a f(x) \mathrm{d}x.<br>$$<br><strong>性质2</strong>    若$f,g$都在$[a,b]$上可积，则$f\pm g$在$[a,b]$上也可积，且<br>$$<br>\int^b_a [f(x) \pm g(x)] \mathrm{d}x = \int^b_a f(x) \mathrm{d}x \pm \int^b_a g(x) \mathrm{d}x.<br>$$<br><strong>线性性质</strong><br>$$<br>\int^b_a [\alpha f(x) + \beta g(x)] \mathrm{d}x = \alpha \int^b_a f(x) \mathrm{d}x + \beta \int^b_a g(x) \mathrm{d}x.<br>$$<br>其中$\alpha, \beta$为常数。</p>
<p><strong>性质3</strong>    若$f,g$都在$[a,b]$上可积，则$f\cdot g$在$[a,b]$上也可积。但一般情形下<br>$$<br>\int^b_a f(x)g(x)\mathrm{d}x \neq \int^b_a f(x)\mathrm{d}x \cdot \int^b_a g(x)\mathrm{d}x.<br>$$<br><strong>性质4</strong>    $f$在$[a,b]$上可积的充要条件是任给$c\in (a,b)$，$f$在$[a,c]$与$[c,b]$上都可积。此时又有等式<br>$$<br>\int^b_a f(x) \mathrm{d}x = \int^c_a f(x) \mathrm{d}x + \int^b_c f(x) \mathrm{d}x.<br>$$<br>性质4称为关于积分区间的可加性。当$f(x)\geq 0$时，其几何意义就是曲边梯形面积的可加性。</p>
<p><strong>注意</strong>：按定积分的定义，记号 $\int^b_a f(x) \mathrm{d}x$ 只有当 $a&lt;b$ 时才有意义，而当 $a=b$ 或 $a&gt;b$ 时本来是没有意义的。但为了运用上的方便，对它作如下规定：</p>
<p><strong>规定1</strong>    当$a=b$时，令$\int^a_a f(x) \mathrm{d}x = 0$;</p>
<p><strong>规定2</strong>    当$a&gt;b$时，令$\int^b_a f(x) \mathrm{d}x = -\int^a_b f(x) \mathrm{d}x$.</p>
<p>有了这些规定以后，性质4对于$a,b,c$的任何大小顺序都能成立。</p>
<p><strong>性质5</strong>    设$f$为$[a,b]$上的可积函数。若$f(x)\geq 0, x\in[a,b]$，则<br>$$<br>\int^b_a f(x) \mathrm{d}x \geq 0.<br>$$<br><strong>推理（积分不等式性）</strong>    若$f$与$g$为$[a,b]$上的两个可积函数，且$f(x)\leq g(x), x\in [a,b]$，则有<br>$$<br>\int^b_a f(x) \mathrm{d}x \leq \int^b_a g(x) \mathrm{d}x.<br>$$<br><strong>性质6</strong>    若$f$在$[a,b]$上可积，则$|f|$在$[a,b]$上也可积，且<br>$$<br>\left \vert \int^b_a f(x) \mathrm{d} x \right \vert \leq \int^b_a \left \vert f(x) \right \vert \mathrm{d} x.<br>$$<br><strong>注意：这个性质的逆命题一般不成立</strong>，例如<br>$$<br>f(x) =<br>\begin{cases}<br>1, x \in Q, \\<br>-1, x \in Q^C<br>\end{cases}<br>$$<br>在$[0,1]$上不可及（类似于狄利克雷函数）；但$|f(x)|\equiv 1$，它在$[0,1]$上可积。</p>
<p><strong>命题</strong>    假设$f$为一非负可积函数，只要它在某一点$x_0$处连续，且$f(x_0) &gt; 0$，那么必有$\int^b_a f(x) \mathrm{d}x &gt; 0$.</p>
<p><strong>注意：可积函数必有连续点。</strong></p>
<p>可积等价于几乎处处连续。</p>
<p>连续具有局部保号性：如果$f$在$[a,b]$上连续，在点$x_0 \in (a,b)$处，$f(x_0)&gt;0$，那么存在一个$\delta &gt; 0$，使得$f(x) &gt; 0, x \in [x_0 - \delta, x_0 + \delta]$.</p>
<h1 id="积分中值定理"><a href="#积分中值定理" class="headerlink" title="积分中值定理"></a>积分中值定理</h1><p><strong>定理 9.7 （积分第一中值定理）</strong>    若$f$在$[a,b]$上连续，则至少存在一点$\xi \in [a,b]$，使得<br>$$<br>\int^b_a f(x) \mathrm{d} x = f(\xi) (b - a).<br>$$<br><strong>定理 9.8 （推广的积分第一中值定理）</strong>    若$f$与$g$都在$[a,b]$上连续，且$g(x)$在$[a,b]$上不变号，则至少存在一点$\xi \in [a,b]$，使得<br>$$<br>\int^b_a f(x)g(x) \mathrm{d}x = f(\xi) \int^b_a g(x) \mathrm{d}x.<br>$$</p>
<h1 id="重要习题"><a href="#重要习题" class="headerlink" title="重要习题"></a>重要习题</h1><ul>
<li><p>若$f$与$g$都在$[a,b]$上可积，则<br>$$<br>\lim_{| T | \to 0} \sum^n_{i=1} f(\xi_i)g(\eta_i) \Delta x_i = \int^b_a f(x)g(x) \mathrm{d}x.<br>$$<br>其中$\xi_i, \eta_i$是$T$所属小区间$\Delta_i$中的任意两点，$i=1,2,\cdots,n$.</p>
</li>
<li><p>设$f$与$g$都在$[a,b]$上可积，则<br>$$<br>M(x) = \max_{x\in[a,b]} {f(x), g(x)}, m(x) = \min_{x\in[a,b]}{f(x),g(x)}<br>$$<br>在$[a,b]$上都可积。</p>
</li>
<li><p>设$f$在$[a,b]$上可积，且在$[a,b]$上满足$|f(x)|\geq m &gt; 0$，则$\frac{1}{f}$在$[a,b]$上也可积。</p>
</li>
<li><p>若$f$与$g$都在$[a,b]$上可积，且$g(x)$在$[a,b]$上不变号，$M,m$分别为$f(x)$在$[a,b]$上的上、下确界，则比存在某实数$\mu(m\leq \mu \leq M)$，使得<br>$$<br>\int^b_a f(x)g(x)\mathrm{d}x = \mu \int^b_a g(x) \mathrm{d}x.<br>$$</p>
</li>
</ul>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>integral</tag>
      </tags>
  </entry>
  <entry>
    <title>把本地代码发布到 GitHub 上</title>
    <url>/2020/10/13/publish-local-code-on-github/</url>
    <content><![CDATA[<p>本地写好的代码如何发布到 GitHub 上呢？这里给出一个方法。</p>
<a id="more"></a>

<h1 id="在-GitHub-上创建一个新的仓库"><a href="#在-GitHub-上创建一个新的仓库" class="headerlink" title="在 GitHub 上创建一个新的仓库"></a>在 GitHub 上创建一个新的仓库</h1><ol>
<li>填写自己喜欢的仓库名</li>
<li>填写自己需要的仓库介绍，简短介绍仓库</li>
<li>选择初始化仓库</li>
<li>最好初始化 README file</li>
<li>点选 .gitignore</li>
<li>选择自己需要的代码版权协议</li>
</ol>
<h1 id="克隆仓库到本地"><a href="#克隆仓库到本地" class="headerlink" title="克隆仓库到本地"></a>克隆仓库到本地</h1><p>最好为 GitHub 添加 SSH 认证，这样在提交修改的代码时不需要重复输入用户名和密码，方法参考我的另一篇博文 <a href="https://xu-jinzhong.gitee.io/2020/01/08/ssh-git/">使用SSH连接GitHub</a></p>
<p>克隆代码方法如下（这里以 SSH 为例）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:xujinzh/CSK.git</span><br></pre></td></tr></table></figure>

<h1 id="把本地代码放到克隆的文件夹下"><a href="#把本地代码放到克隆的文件夹下" class="headerlink" title="把本地代码放到克隆的文件夹下"></a>把本地代码放到克隆的文件夹下</h1><p>如我这里本地开发的代码是 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cf-csk</span><br></pre></td></tr></table></figure>

<p>经过上面克隆后，代码放在</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CSK</span><br></pre></td></tr></table></figure>

<p>拷贝 cf-csk 文件到 CSK 里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp -r cf-csk/* CSK/</span><br></pre></td></tr></table></figure>

<h1 id="提交代码到-GitHub"><a href="#提交代码到-GitHub" class="headerlink" title="提交代码到 GitHub"></a>提交代码到 GitHub</h1><p>一般需要完善 README.md 文件以便更好的介绍该仓库，修改后，进行提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;add csk tackers&quot;</span></span><br><span class="line">git push -u origin main:main</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Pycharm 自动文件代码注释说明</title>
    <url>/2020/07/31/pycharm-comments/</url>
    <content><![CDATA[<p>PyCharm 是一款非常优秀的python代码开发工具，功能强大，特别是代码提示功能，非常好用。在我们开发python代码时，常常需要给代码文件添加说明注释，比如，在什么时候创建的代码、有谁开发、作者信息等等，下面给出一个个人喜好的格式</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author   : Jinzhong Xu</span></span><br><span class="line"><span class="comment"># @Contact  : jinzhongxu@csu.ac.cn</span></span><br><span class="line"><span class="comment"># @Time     : $&#123;DATE&#125; $&#123;TIME&#125;</span></span><br><span class="line"><span class="comment"># @File     : $&#123;NAME&#125;.py</span></span><br><span class="line"><span class="comment"># @Software : $&#123;PRODUCT_NAME&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如何在PyCharm中设置呢？</p>
<p>以Windows上为例：</p>
<ol>
<li><p>打开PyCharm -&gt; File -&gt; Settings -&gt; Editor -&gt; File and Code Templates -&gt; Python Script </p>
</li>
<li><p>然后添加上面的格式代码</p>
</li>
<li><p>点击 Apply -&gt; OK</p>
</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>PyCharm 远程解释器配置</title>
    <url>/2020/08/10/pycharm-ssh-sftp-remote-interpreter/</url>
    <content><![CDATA[<p>PyCharm 是一款编写 Python 代码的优秀 IDE，特别是其代码提示功能和自动检查代码功能，当我们想要利用远程服务器的强大计算能力和方便的本地 PyCharm 开发工具时，需要配置 PyCharm 远程解释器，下面进行介绍</p>
<a id="more"></a>

<h1 id="PyCharm-专业版安装"><a href="#PyCharm-专业版安装" class="headerlink" title="PyCharm 专业版安装"></a>PyCharm 专业版安装</h1><p>想使用 PyCharm 远程解释器功能，必须使用专业版，JET BRAINS 官网上可以免费使用30天专业版 PyCharm，到期后，可以购买，价格大概时2000元左右。</p>
<h1 id="远程解释器配置"><a href="#远程解释器配置" class="headerlink" title="远程解释器配置"></a>远程解释器配置</h1><p>顺序如下</p>
<p>File -&gt; Settings -&gt; Project -&gt; Python Interpreter -&gt; 右上角添加 -&gt; SSH Interpreter -&gt; New server configuration -&gt; next -&gt; 配置密码等</p>
<h1 id="上传本地代码"><a href="#上传本地代码" class="headerlink" title="上传本地代码"></a>上传本地代码</h1><p>配置好远程解释器后，需要将本地新建的工程上传到远程服务器的某一个目录下，才能够运行，不然会出现找不到文件或目录，具体配置如下</p>
<p>Tools -&gt; Deployment -&gt; Configuration -&gt; + -&gt; SFTP -&gt; Connection -&gt; 填写自己的内容，一般不用修改 -&gt; Mappings -&gt; Local path(表示本地代码工程目录) -&gt; Deployment path(远程服务器运行时代码工程目录) -&gt; ok</p>
<h1 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h1><p>运行前，一般都需要将本地代码的修改更正到远程服务器上，才能够在远程服务器上运行代码，快捷键是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl + <span class="built_in">shift</span> + alt + x</span><br></pre></td></tr></table></figure>

<p>如果觉得每次运行都要上传比较麻烦，可以如下设置，自动上传：</p>
<ol>
<li>在 Tools -&gt; Deployment -&gt; Configuration 里设置 默认服务器，打对号，也可右键设置</li>
<li>在 Tools -&gt; Deployment -&gt; Options -&gt; Upload changed files automatically to the default server -&gt; 选择 Always</li>
</ol>
<p>上传代码后，就可以运行了，快捷键是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl + <span class="built_in">shift</span> + f10</span><br></pre></td></tr></table></figure>

<h1 id="设置自动同步"><a href="#设置自动同步" class="headerlink" title="设置自动同步"></a>设置自动同步</h1><p>当前面已经设置自动同步 (Always)，但是却没有自动同步或上传代码到服务器，可能是因为 Deployment 中没有设置默认服务器，设置后应该就可以了。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://blog.csdn.net/myt2000/article/details/103288535">Pycharm设置了自动上传文件，为什么还是没有自动上传文件</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>ssh</tag>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 调用 C 语言的函数</title>
    <url>/2020/08/19/python-calling-c-code/</url>
    <content><![CDATA[<p>Python 是一个高级的、解释性的编程语言，其代码比较其他编程语言，如C、C++、Java 等简单，通俗更易懂，开发效率高，但运行效率较弱。其本身是利用C语言（C语言是为了编写Unix操作系统而被开发研究出来）开发的，因此，在Python中调用C函数、代码将是比较自然的。方法很多，这里介绍一个比较简单的方法。在哪些Python代码运行效率低下的地方，调用C语言实现的程序将会加速代码运行。除此之外，加速Python代码的方法还有，利用 numba 的 jit 或 njit 装饰器来加速数学计算比较多或循环比较多的地方。</p>
<a id="more"></a>

<h1 id="编写-C-代码"><a href="#编写-C-代码" class="headerlink" title="编写 C 代码"></a>编写 C 代码</h1><p>打开文本编辑器，敲入如下代码，并命名为 x_maths.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pow</span>(i, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="编译为共享库文件"><a href="#编译为共享库文件" class="headerlink" title="编译为共享库文件"></a>编译为共享库文件</h1><p>利用C编译器将上面的 x_maths.c 编译为共享库文件（shared library）x_maths.so，也可以写成其他名字，但必须以 .so 为扩展名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cc -fPIC -shared -o x_maths.so x_maths.c</span><br></pre></td></tr></table></figure>

<p>注意，我这里在 Ubuntu 18.04 上运行</p>
<h1 id="Python-调用-C-函数"><a href="#Python-调用-C-函数" class="headerlink" title="Python 调用 C 函数"></a>Python 调用 C 函数</h1><p>在 Python 程序中，从共享文件创建一个 ctypes.CDLL 实例，最后，使用 {CDLL_instance}.{function_name}（{function_parameters}） 格式调用 C 函数。我这里在 Jupyter lab 里编写代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">so_file = <span class="string">&quot;./x_maths.so&quot;</span></span><br><span class="line">my_function = CDLL(so_file)</span><br><span class="line">print(type(my_function))</span><br><span class="line">print(my_function.square(<span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">ctypes</span>.<span class="title">CDLL</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">1000000</span></span><br></pre></td></tr></table></figure>

<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ol>
<li>ctype 简单，且是 Python 标准库之一</li>
<li>ctypes 是低级实现，易于实现，但缺乏自动化，对于复杂任务将会变得较为繁琐</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中NotImplementedError的使用</title>
    <url>/2021/12/16/python-class-notImplementedError/</url>
    <content><![CDATA[<p>Python 是一种面向对象的编程语言，子类可以继承父类的方法。父类可以通过某种手段限制子类中必须重写父类的指定方法，否则报错。这种手段就是 NotImplementedError.</p>
<a id="more"></a>

<h1 id="如果子类不重写父类的方法"><a href="#如果子类不重写父类的方法" class="headerlink" title="如果子类不重写父类的方法"></a>如果子类不重写父类的方法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nie_func</span>(<span class="params">self</span>):</span>  <span class="comment"># 要求子类中必须实现该方法，否则在子类实例中不能调用该方法</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;parent class nie methods not implemented&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span>(<span class="params">ParentClass</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cc = ChildClass()</span><br><span class="line">cc.nie_func()</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------------------------</span><br><span class="line">NotImplementedError                       Traceback (most recent call last)</span><br><span class="line">/tmp/ipykernel_46111/<span class="number">872110974.</span>py <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">      <span class="number">9</span> </span><br><span class="line">     <span class="number">10</span> cc = ChildClass()</span><br><span class="line">---&gt; 11 cc.nie_func()</span><br><span class="line"></span><br><span class="line">/tmp/ipykernel_46111/<span class="number">872110974.</span>py <span class="keyword">in</span> nie_func(self)</span><br><span class="line">      <span class="number">1</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span>:</span></span><br><span class="line">      <span class="number">2</span>     <span class="function"><span class="keyword">def</span> <span class="title">nie_func</span>(<span class="params">self</span>):</span>  <span class="comment"># 要求子类中必须实现该方法，否则在子类实例中不能调用该方法</span></span><br><span class="line">----&gt; 3         raise NotImplementedError(&quot;parent class nie methods not implemented&quot;)</span><br><span class="line">      <span class="number">4</span> </span><br><span class="line">      <span class="number">5</span> </span><br><span class="line"></span><br><span class="line">NotImplementedError: parent <span class="class"><span class="keyword">class</span> <span class="title">nie</span> <span class="title">methods</span> <span class="title">not</span> <span class="title">implemented</span></span></span><br></pre></td></tr></table></figure>

<p>发现报错 NotImplementedError，即没有实现方法的错误。在下面示例中进行修复，在子类中实现父类的方法。</p>
<h1 id="子类重写父类的方法"><a href="#子类重写父类的方法" class="headerlink" title="子类重写父类的方法"></a>子类重写父类的方法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nie_func</span>(<span class="params">self</span>):</span>  <span class="comment"># 要求子类中必须实现该方法，否则在子类实例中不能调用该方法</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;parent class nie methods not implemented&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span>(<span class="params">ParentClass</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nie_func</span>(<span class="params">self</span>):</span>  <span class="comment"># 子类中重新父类方法</span></span><br><span class="line">        print(<span class="string">&quot;child implement tdemo methods&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cc = ChildClass()</span><br><span class="line">cc.nie_func()</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">child implement tdemo methods</span><br></pre></td></tr></table></figure>

<p>发现不再报 NotImplementedError.</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>1.<a href="https://blog.csdn.net/grey_csdn/article/details/77074707">Python编程中NotImplementedError的使用</a></p>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Python 中导入自己编写的模块</title>
    <url>/2021/04/10/python-import-mymodule/</url>
    <content><![CDATA[<p>在 Python 中导入包可以直接使用 import，非常简便。但是，对于自己编写的 Python 模块不能简单的使用该方法导入，特别是想在任意目录下使用自己编写的模块时。如何实现向 Python 安装的第三方包一样直接使用 import 在任意目录下导入自己的模块呢？下面介绍几个方法。假设自己模块的目录为：/home/jinzhongxu/mymodule</p>
<a id="more"></a>

<h1 id="使用-module-pth"><a href="#使用-module-pth" class="headerlink" title="使用 module.pth"></a>使用 module.pth</h1><p>按照下面的顺序执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 Python 包目录</span></span><br><span class="line">ipython</span><br><span class="line">In [1]: import site</span><br><span class="line"></span><br><span class="line">In [2]: site.getsitepackages()</span><br><span class="line">Out[2]: [<span class="string">&#x27;/usr/local/miniconda/lib/python3.8/site-packages&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建 module.pth, 注意以 pth 结尾</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;/home/jinzhongxu/mymodule&#x27;</span> &gt;&gt; module.pth </span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 module.pth 放入 Python 包目录</span></span><br><span class="line">mv module.pth /usr/<span class="built_in">local</span>/miniconda/lib/python3.8/site-packages/.</span><br></pre></td></tr></table></figure>

<p>这样就可以使用了。</p>
<h1 id="使用-sys"><a href="#使用-sys" class="headerlink" title="使用 sys"></a>使用 sys</h1><p>这种方法是在每次调用自己写的模块时，把模块的路径添加的代码运行环境中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&quot;/home/jinzhongxu/mymodule&quot;</span>)  //设置自定义模块路径</span><br></pre></td></tr></table></figure>

<p>这样就可以使用了。</p>
<h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><ol>
<li><a href="https://www.jianshu.com/p/6692b48c7295">python导入自定义模块方法</a></li>
<li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p09_add_directories_to_sys_path.html">将文件夹加入到sys.path</a> </li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>import</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Python 中使用 importlib 和 getattr 动态调用函数</title>
    <url>/2021/12/17/python-importlib-getattr/</url>
    <content><![CDATA[<p>Python 是一种动态编程语言。在编写 Python 代码时利用 importlib 能够动态的导入需要的模块，利用 getattr 能够获取模块的属性或方法，返回属性值和函数。本篇对它们进行介绍，并给出一个例子展示如何使用它们。</p>
<a id="more"></a>

<h1 id="importlib"><a href="#importlib" class="headerlink" title="importlib"></a>importlib</h1><p>importlib 是一个模块，使用时需要首先导入该模块。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> importlib</span><br></pre></td></tr></table></figure>

<p>导入模块的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">expr_module = importlib.import_module(<span class="string">&quot;mymodule.test&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="getattr"><a href="#getattr" class="headerlink" title="getattr"></a>getattr</h1><p>getattr 是内置函数，用于返回一个对象属性值。</p>
<p>如，编写一个类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&#x27;test&#x27;</span></span><br></pre></td></tr></table></figure>

<p>获取实例的属性值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = Test()</span><br><span class="line">getattr(t, <span class="string">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;test&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p>编写模块 primes.py，放到当前目录的 pyscripts 文件夹下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@jit(nopython=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span>(<span class="params">n: int</span>) -&gt; str:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    判断给定的n是否为素数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 只需要用n除以2 ~ n/2 + 1 是否能整除</span></span><br><span class="line">    <span class="comment"># 如果有整数整除n，则n不是素数</span></span><br><span class="line">    <span class="comment"># 如果所有的都不能整数n，则n是素数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 如果余数是0，则表示整除，不是素数，直接返回0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (n % i):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;n&#125;</span>不是素数，是合数&quot;</span></span><br><span class="line">    <span class="comment"># 如果所有的数都不能整除n，则说明n是素数，则返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;n&#125;</span>是素数&quot;</span></span><br></pre></td></tr></table></figure>

<p>调用模块，并使用模块的方法（在 notebook 中演示）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line">expr_module = importlib.import_module(<span class="string">&#x27;pyscripts.primes&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取模块的方法</span></span><br><span class="line">expr_func = getattr(expr_module, <span class="string">&quot;isPrime&quot;</span>)</span><br><span class="line"><span class="comment"># 使用该方法，判断数值 158963 是否是素数</span></span><br><span class="line">expr_func(<span class="number">158963</span>), expr_func(<span class="number">158863</span>)</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;158963不是素数，是合数&#x27;</span>, <span class="string">&#x27;158863是素数&#x27;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 逻辑运算</title>
    <url>/2021/05/29/python-logic-operation/</url>
    <content><![CDATA[<p>Python 的逻辑运算符包括 and, or, not，但位运算符 &amp; (按位与运算符), | (按位或运算符) 有时也可以达到 and, or 的效果，有时，只有位运算符才能完成，如 pandas 中。下面进行总结，主要介绍 and, or 和 &amp;, |.</p>
<a id="more"></a>

<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>离散数学中，假设 p 和 q 都是命题，那么</p>
<p>p 且 q: 当 p 和 q 都取值为真时结果才为真；</p>
<p>p 或 q:    当 p 和 q 都取值为假时结果才为假；</p>
<h1 id="Python-逻辑运算"><a href="#Python-逻辑运算" class="headerlink" title="Python 逻辑运算"></a>Python 逻辑运算</h1><h2 id="命题为逻辑变量时"><a href="#命题为逻辑变量时" class="headerlink" title="命题为逻辑变量时"></a>命题为逻辑变量时</h2><p>当命题为逻辑变量时，即取值为 True, False 布尔值时，and, or 和 &amp;, | 相对应的运算符用法基本一致，除了在pandas中。</p>
<p>也就是说，以下的表达式结果都为 True</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="literal">True</span> &amp; <span class="literal">True</span>) == (<span class="literal">True</span> <span class="keyword">and</span> <span class="literal">True</span>)</span><br><span class="line">(<span class="literal">True</span> &amp; <span class="literal">False</span>) == (<span class="literal">True</span> <span class="keyword">and</span> <span class="literal">False</span>)</span><br><span class="line">(<span class="literal">False</span> &amp; <span class="literal">True</span>) == (<span class="literal">False</span> <span class="keyword">and</span> <span class="literal">True</span>)</span><br><span class="line">(<span class="literal">False</span> &amp; <span class="literal">False</span>) == (<span class="literal">False</span> <span class="keyword">and</span> <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">(<span class="literal">True</span> | <span class="literal">True</span>) == (<span class="literal">True</span> <span class="keyword">or</span> <span class="literal">True</span>)</span><br><span class="line">(<span class="literal">True</span> | <span class="literal">False</span>) == (<span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span>)</span><br><span class="line">(<span class="literal">False</span> | <span class="literal">True</span>) == (<span class="literal">False</span> <span class="keyword">or</span> <span class="literal">True</span>)</span><br><span class="line">(<span class="literal">False</span> | <span class="literal">False</span>) == (<span class="literal">False</span> <span class="keyword">or</span> <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p><font size=4 color=cyan>但在 pandas 中，下面情况只能使用 &amp; 和 ｜，注意不能使用 and 或 or</font>，不然报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&quot;a&quot;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&quot;b&quot;</span>: [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]&#125;)</span><br><span class="line">df[(df.a &gt; <span class="number">1</span>) &amp; (df.a &lt; <span class="number">3</span>)]</span><br><span class="line">&gt; 	a	b</span><br><span class="line"> <span class="number">1</span>	<span class="number">2</span>	<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="命题为数值变量时"><a href="#命题为数值变量时" class="headerlink" title="命题为数值变量时"></a>命题为数值变量时</h2><p>当命题为数值变量时，即命题取值为整数值，如 2， 3 等，此时 &amp; 和 | 是位运算符，如下结果都为 True</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> &amp; <span class="number">4</span> == <span class="number">0</span></span><br><span class="line"><span class="number">2</span> | <span class="number">4</span> == <span class="number">6</span></span><br><span class="line">bin(<span class="number">2</span>) == <span class="string">&quot;0b10&quot;</span></span><br><span class="line">bin(<span class="number">4</span>) == <span class="string">&quot;0b100&quot;</span></span><br></pre></td></tr></table></figure>

<p>但 and 和 or 仍然表示逻辑运算，它把非 0 整数当成真，0 或 False 当假，如下结果都为 True</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">0</span> <span class="keyword">and</span> <span class="number">3</span>) == <span class="number">0</span></span><br><span class="line">(<span class="number">2</span> <span class="keyword">and</span> <span class="number">3</span>) == <span class="number">3</span></span><br><span class="line">(<span class="number">3</span> <span class="keyword">or</span> <span class="number">0</span>) == <span class="number">3</span></span><br><span class="line">(<span class="number">0</span> <span class="keyword">or</span> <span class="number">2</span>) == <span class="number">2</span></span><br><span class="line"><span class="comment"># and 遇到 False或0 就返回</span></span><br><span class="line"><span class="comment"># or 遇到 True或非0 就返回</span></span><br><span class="line"><span class="comment"># 因为 and 和 or 都是短路操作符（short-circuitlogic）或者惰性求值（lazy evaluation）</span></span><br><span class="line"><span class="comment"># 它们的参数从左向右解析，一旦结果可以确定就停止</span></span><br></pre></td></tr></table></figure>

<h2 id="命题中既有逻辑变量又有数值变量"><a href="#命题中既有逻辑变量又有数值变量" class="headerlink" title="命题中既有逻辑变量又有数值变量"></a>命题中既有逻辑变量又有数值变量</h2><p>当左右命题中既有逻辑变量又有数值变量时，逻辑变量自动类型转化为数值变量的  0 或 1，False 转化为 0, True 转化为 1，如下结果都为 True，但注意因为惰性求值，结果可能是第一个命题的类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="literal">False</span> <span class="keyword">and</span> <span class="number">3</span>) == <span class="literal">False</span></span><br><span class="line">(<span class="literal">False</span> <span class="keyword">or</span> <span class="number">3</span>) == <span class="number">3</span></span><br><span class="line">(<span class="literal">True</span> <span class="keyword">and</span> <span class="number">3</span>) == <span class="number">3</span></span><br><span class="line">(<span class="literal">True</span> <span class="keyword">or</span> <span class="number">3</span>) == <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>也可以这样理解：</p>
<ol>
<li><font size=5 color=red> 对于 and 当第一个命题为假时返回第一个命题值；当第一个命题为真时返回第二个命题值</font>；</li>
<li><font size=5 color=orange>对于  or  当第一个命题为真时返回第一个命题值；当第一个命题为假时返回第二个命题值</font>。</li>
</ol>
<h1 id="注意运算优先级"><a href="#注意运算优先级" class="headerlink" title="注意运算优先级"></a>注意运算优先级</h1><p>因为逻辑运算的优先级比较低，因此<font size=4 color=cyan>建议对命题加上小括号</font>，这样逻辑上比较清晰，不易出现意想不到的结果，如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">0</span> <span class="keyword">and</span> <span class="number">3</span>) == <span class="number">0</span></span><br><span class="line">&gt; <span class="literal">True</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">and</span> <span class="number">3</span> == <span class="number">0</span></span><br><span class="line">&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><p><a href="https://blog.csdn.net/weixin_40041218/article/details/80868521">Python 中 （&amp;，|）和（and，or）之间的区别</a></p>
</li>
<li><p><a href="https://blog.csdn.net/lqzdreamer/article/details/77171255">Python中的逻辑运算符‘and’、‘or’和‘not’</a></p>
</li>
<li><p><a href="http://c.biancheng.net/view/2186.html">Python逻辑运算符及其用法</a></p>
</li>
<li><p><a href="https://www.runoob.com/python/python-operators.html#ysf4">Python 运算符</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>logic</tag>
      </tags>
  </entry>
  <entry>
    <title>Python JSON</title>
    <url>/2021/04/14/python-json/</url>
    <content><![CDATA[<p>在该篇将学习如何在 Python 中解析、读取、写入 JSON，同时，将介绍如何把 JSON 转化为字典并格式化打印。</p>
<p>JSON（JavaScript Object Notation）是表示结构化数据的流行数据结构。通常服务器和网络应用之间以 JSON 格式发送和接受数据。</p>
<p>在 Python 中，JSON 以字符串格式存在，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">para = <span class="string">&#x27;&#123;&quot;model&quot;: &quot;VGG&quot;, &quot;optim_kwargs&quot;: &#123;&quot;lr&quot;: 1e-2, &quot;momentum&quot;: 0.9&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通常，JSON 对象保存在文件中。</p>
<a id="more"></a>

<h1 id="把-JSON-字符串转化为字典"><a href="#把-JSON-字符串转化为字典" class="headerlink" title="把 JSON 字符串转化为字典"></a>把 JSON 字符串转化为字典</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">&gt;&gt; para = <span class="string">&#x27;&#123;&quot;model&quot;: &quot;VGG&quot;, &quot;optim_kwargs&quot;: &#123;&quot;lr&quot;: 1e-2, &quot;momentum&quot;: 0.9&#125;&#125;&#x27;</span></span><br><span class="line">&gt;&gt; para_dict = json.loads(para)</span><br><span class="line">&gt;&gt; print(para_dict)</span><br><span class="line">&gt;&gt; print(para_dict[<span class="string">&quot;model&quot;</span>])</span><br><span class="line">&#123;<span class="string">&#x27;model&#x27;</span>: <span class="string">&#x27;VGG&#x27;</span>, <span class="string">&#x27;optim_kwargs&#x27;</span>: &#123;<span class="string">&#x27;lr&#x27;</span>: <span class="number">0.01</span>, <span class="string">&#x27;momentum&#x27;</span>: <span class="number">0.9</span>&#125;&#125;</span><br><span class="line">VGG</span><br></pre></td></tr></table></figure>

<h1 id="把字典保存为JSON文件"><a href="#把字典保存为JSON文件" class="headerlink" title="把字典保存为JSON文件"></a>把字典保存为JSON文件</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">&gt;&gt; para_dict = &#123;<span class="string">&#x27;model&#x27;</span>: <span class="string">&#x27;VGG&#x27;</span>, <span class="string">&#x27;optim_kwargs&#x27;</span>: &#123;<span class="string">&#x27;lr&#x27;</span>: <span class="number">0.01</span>, <span class="string">&#x27;momentum&#x27;</span>: <span class="number">0.9</span>&#125;&#125;</span><br><span class="line">&gt;&gt; <span class="keyword">with</span> open(<span class="string">&#x27;./data/paras.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> jf:</span><br><span class="line"><span class="meta">... </span>   json.dump(para_dict, jf, indent=<span class="number">4</span>, sort_keys=<span class="literal">True</span>, ensure_ascii=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h1 id="从JSON文件中读取数据成字典"><a href="#从JSON文件中读取数据成字典" class="headerlink" title="从JSON文件中读取数据成字典"></a>从JSON文件中读取数据成字典</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="keyword">with</span> open(<span class="string">&quot;./data/paras.json&quot;</span>) <span class="keyword">as</span> jf:</span><br><span class="line">&gt;&gt;     para_dict = json.load(jf)</span><br><span class="line"></span><br><span class="line">&gt;&gt; print(para_dict[<span class="string">&quot;model&quot;</span>])</span><br><span class="line">VGG</span><br></pre></td></tr></table></figure>

<h1 id="把字典转化为JSON字符串"><a href="#把字典转化为JSON字符串" class="headerlink" title="把字典转化为JSON字符串"></a>把字典转化为JSON字符串</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">&gt;&gt; para_dict = &#123;<span class="string">&quot;model&quot;</span>: <span class="string">&quot;VGG&quot;</span>, <span class="string">&quot;optim_kwargs&quot;</span>: &#123;<span class="string">&quot;lr&quot;</span>: <span class="number">0.01</span>, <span class="string">&quot;momentum&quot;</span>: <span class="number">0.9</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt; para = json.dumps(para_dict, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">&gt;&gt; print(para)</span><br><span class="line"><span class="comment"># 注意JSON字符串不同于字典，是不能够直接索引的</span></span><br></pre></td></tr></table></figure>

<h1 id="记忆方法"><a href="#记忆方法" class="headerlink" title="记忆方法"></a>记忆方法</h1><ol>
<li>字典是 JSON 字符串和 JSON 文件的桥梁；</li>
<li>JSON 字符串和字典之间的转化用带 ‘s’ 的方法；</li>
<li>JSON 文件和字典之间的转化用不带 ‘s’ 的方法；</li>
<li>JSON 到字典用 ‘load’;</li>
<li>字典到 JSON 用 ‘dump’；</li>
</ol>
<p>表示为如下：</p>
<p>$JSON 字符串 \overset{dumps}{\longleftarrow} 字典 \overset{dump}{\longrightarrow} JSON 文件$</p>
<p>$JSON 字符串 \overset{loads}{\longrightarrow} 字典 \overset{load}{\longleftarrow} JSON 文件$</p>
<p>合并表示如下：</p>
<p>$JSON 字符串 \underset{loads}{\overset{dumps}{\leftrightarrows}} 字典 \underset{load}{\overset{dump}{\rightleftarrows}} JSON 文件$</p>
<p>保存含有中文的字符，请注意参数 <strong>ensure_ascii=False</strong></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><p><a href="https://www.programiz.com/python-programming/json">Python JSON</a></p>
</li>
<li><p><a href="https://blog.csdn.net/ys_073/article/details/9403039">Python下json中文乱码解决办法</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>json</tag>
        <tag>dict</tag>
      </tags>
  </entry>
  <entry>
    <title>解决使用 Python 的 matplotlib 画图时中文显示为乱码的问题</title>
    <url>/2021/05/06/python-matplotlib-show-Chinese/</url>
    <content><![CDATA[<p>在使用 <code>Python</code> 的 <code>matplotlib</code> 画图时如果设置了标题或者坐标轴名称为中文时，显示图片上中文出现乱码或四边形，不能正常显示我们需要的中文字，体验非常不好。下面给出一个解决方法。本篇以 Linux （Debian）系统为例。</p>
<a id="more"></a>

<h1 id="下载中文字体"><a href="#下载中文字体" class="headerlink" title="下载中文字体"></a>下载中文字体</h1><p>可以在 <a href="https://www.wfonts.com/font/simhei">wfonts</a> 下载，也可以在其他任何能够下载到 <code>SimHei.ttf</code> 的地方下载。</p>
<h1 id="把字体文件放在合适的位置"><a href="#把字体文件放在合适的位置" class="headerlink" title="把字体文件放在合适的位置"></a>把字体文件放在合适的位置</h1><p>把字体放在 <code>matplotlib</code> 能够发现的位置，如何指导正确的位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  ~ ipython</span><br><span class="line">Python <span class="number">3.8</span><span class="number">.5</span> (default, Sep  <span class="number">4</span> <span class="number">2020</span>, <span class="number">07</span>:<span class="number">30</span>:<span class="number">14</span>) </span><br><span class="line">Type <span class="string">&#x27;copyright&#x27;</span>, <span class="string">&#x27;credits&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;license&#x27;</span> <span class="keyword">for</span> more information</span><br><span class="line">IPython <span class="number">7.23</span><span class="number">.0</span> -- An enhanced Interactive Python. Type <span class="string">&#x27;?&#x27;</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> matplotlib</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: matplotlib.matplotlib_fname()</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">&#x27;/usr/local/miniconda/lib/python3.8/site-packages/matplotlib/mpl-data/matplotlibrc&#x27;</span></span><br></pre></td></tr></table></figure>

<p>从上面可以发现一个目录：<code>&#39;/usr/local/miniconda/lib/python3.8/site-packages/matplotlib/mpl-data/&#39;</code>，在该目录下有个文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ ls /usr/<span class="built_in">local</span>/miniconda/lib/python3.8/site-packages/matplotlib/mpl-data</span><br><span class="line">fonts  images  matplotlibrc  plot_directive  sample_data  stylelib</span><br><span class="line">➜  ~ ls /usr/<span class="built_in">local</span>/miniconda/lib/python3.8/site-packages/matplotlib/mpl-data/fonts</span><br><span class="line">afm  pdfcorefonts  ttf</span><br></pre></td></tr></table></figure>

<p>把下载的 <code>SimHei.ttf</code> 拷贝到 <code>ttf</code> 文件夹下</p>
<h1 id="清除旧缓存"><a href="#清除旧缓存" class="headerlink" title="清除旧缓存"></a>清除旧缓存</h1><p>一般需要先清除掉旧的 <code>matplotlib</code> 缓存后才能正常使用，缓存一般在家目录下，可以通过如下方法获得缓存地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  ~ ipython </span><br><span class="line">Python <span class="number">3.8</span><span class="number">.5</span> (default, Sep  <span class="number">4</span> <span class="number">2020</span>, <span class="number">07</span>:<span class="number">30</span>:<span class="number">14</span>) </span><br><span class="line">Type <span class="string">&#x27;copyright&#x27;</span>, <span class="string">&#x27;credits&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;license&#x27;</span> <span class="keyword">for</span> more information</span><br><span class="line">IPython <span class="number">7.23</span><span class="number">.0</span> -- An enhanced Interactive Python. Type <span class="string">&#x27;?&#x27;</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> matplotlib</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: matplotlib.get_cachedir()</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">&#x27;/home/jinzhongxu/.cache/matplotlib&#x27;</span></span><br></pre></td></tr></table></figure>

<p>发现我的确实在家目录下，因此直接去家目录删除即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ ls .cache            </span><br><span class="line">jedi  matplotlib  yarn</span><br><span class="line">➜  ~ ls .cache/matplotlib </span><br><span class="line">fontlist-v330.json</span><br><span class="line">➜  ~ rm -r ~/.cache/matplotlib</span><br></pre></td></tr></table></figure>

<h1 id="画图时使用中文"><a href="#画图时使用中文" class="headerlink" title="画图时使用中文"></a>画图时使用中文</h1><p>配置好中文字体后，只需要在每次画图时指定字体就可以正常显示中文字符了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>] = [<span class="string">&quot;SimHei&quot;</span>]  <span class="comment"># 用来显示中文</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>] = <span class="literal">False</span>  <span class="comment"># 用来显示负号</span></span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">101</span>)</span><br><span class="line">y = np.cos(x)</span><br><span class="line">plt.plot(x, y, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">plt.title(<span class="string">u&quot;余弦&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h1 id="一劳永逸"><a href="#一劳永逸" class="headerlink" title="一劳永逸"></a>一劳永逸</h1><p>从上面可知，每次画图都需要在代码中配置中文字体才能正常显示中文字符，下面通过设置可以直接使用中文字体，那就是修改上面的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/miniconda/lib/python3.8/site-packages/matplotlib/mpl-data/matplotlibrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把前面的注释去掉</span></span><br><span class="line">font.family         : sans-serif</span><br><span class="line"><span class="comment"># 去掉注释，并添加字体名 SimHei 在第一个位置</span></span><br><span class="line">font.sans-serif     : SimHei, Bitstream Vera Sans, ...</span><br><span class="line"><span class="comment"># 去掉注释，并修改 True 为 False</span></span><br><span class="line">axes.unicode_minus  : False</span><br></pre></td></tr></table></figure>

<h1 id="扩展-画图时隐藏图框"><a href="#扩展-画图时隐藏图框" class="headerlink" title="扩展-画图时隐藏图框"></a>扩展-画图时隐藏图框</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画心形线 </span></span><br><span class="line">a = <span class="number">3</span></span><br><span class="line">x = np.linspace(-(a + <span class="number">1</span>) * np.pi / <span class="number">4</span>, (a + <span class="number">1</span>) * np.pi / <span class="number">4</span>, <span class="number">301</span>)</span><br><span class="line">y1 = a * (<span class="number">1</span> + np.cos(x)) * np.cos(x)</span><br><span class="line">y2 = a * (<span class="number">1</span> + np.cos(x)) * np.sin(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 隐藏边框</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"><span class="keyword">for</span> key, spine <span class="keyword">in</span> ax.spines.items():</span><br><span class="line">    <span class="comment"># if key == &quot;left&quot; or key == &quot;right&quot; or key == &quot;top&quot; or key == &quot;bottom&quot;:</span></span><br><span class="line">    <span class="comment">#     spine.set_visible(False)</span></span><br><span class="line">    spine.set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意坐标</span></span><br><span class="line">plt.plot(y2, -y1)</span><br><span class="line">plt.xticks([])</span><br><span class="line">plt.yticks([])</span><br><span class="line">plt.axis(<span class="string">&quot;equal&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><p><a href="https://www.codenong.com/cs106003277/">matplotlib对中文的支持（Font family [‘sans-serif’] not found.Falling back to DejaVu Sans）</a></p>
</li>
<li><p><a href="https://blog.csdn.net/jeff_liu_sky_/article/details/54023745">ubuntu系统下matplotlib中文乱码问题</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
        <tag>Chinese</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 打印颜色设置</title>
    <url>/2021/04/25/python-print-color/</url>
    <content><![CDATA[<p>使用 Python 的 print 方法可以打印输出字符串，通过如下方法可以设置打印字符串的字体颜色和背景颜色。</p>
<a id="more"></a>

<h1 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;\033[1;30m 字体颜色：白色\033[0m&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;\033[1;31m 字体颜色：红色\033[0m&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;\033[1;32m 字体颜色：深黄色\033[0m&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;\033[1;33m 字体颜色：浅黄色\033[0m&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;\033[1;34m 字体颜色：蓝色\033[0m&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;\033[1;35m 字体颜色：淡紫色\033[0m&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;\033[1;36m 字体颜色：青色\033[0m&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;\033[1;37m 字体颜色：灰色\033[0m&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;\033[1;38m 字体颜色：浅灰色\033[0m&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;背景颜色：白色   \033[1;40m    \033[0m&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;背景颜色：红色   \033[1;41m    \033[0m&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;背景颜色：深黄色 \033[1;42m    \033[0m&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;背景颜色：浅黄色 \033[1;43m    \033[0m&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;背景颜色：蓝色   \033[1;44m    \033[0m&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;背景颜色：淡紫色 \033[1;45m    \033[0m&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;背景颜色：青色   \033[1;46m    \033[0m&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;背景颜色：灰色   \033[1;47m    \033[0m&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Windows-CMD-显示颜色方法"><a href="#Windows-CMD-显示颜色方法" class="headerlink" title="Windows CMD 显示颜色方法"></a>Windows CMD 显示颜色方法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"><span class="comment"># 如果平台系统是 &#x27;Linux&#x27;，则不需要此设置</span></span><br><span class="line"><span class="keyword">if</span> platform.system() == <span class="string">&#x27;Windows&#x27;</span>:</span><br><span class="line">    os.system(<span class="string">&#x27;color FF&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://blog.csdn.net/ever_peng/article/details/91492491">python print字体颜色 print背景颜色</a> </li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>color</tag>
        <tag>print</tag>
      </tags>
  </entry>
  <entry>
    <title>把 Python 的 print 函数输出到文件</title>
    <url>/2021/11/28/python-print-to-file/</url>
    <content><![CDATA[<p>利用 Python 的 print 函数可以方便的打印输出，但是，这些输出不能够很好的给别人传看，特别是打印行数较多，又不便更改原模块的代码时。这里，给出一个方法，不动原模块，将打印输出到文件中。</p>
<a id="more"></a>

<h1 id="所有打印都输入文件"><a href="#所有打印都输入文件" class="headerlink" title="所有打印都输入文件"></a>所有打印都输入文件</h1><p>假设，我们打印输出的模块是 main.py 里的 inspect 函数。这里创建 test.py 模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> main <span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line">sys.stdout = open(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">inspect(ids_dir)</span><br><span class="line">sys.stdout.close()</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> main <span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line">original_stdout = sys.stdout</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    sys.stdout = f <span class="comment"># Change the standard output to the file we created.</span></span><br><span class="line">    inspect(ids_dir)</span><br><span class="line">sys.stdout = original_stdout <span class="comment"># Reset the standard output to its original value</span></span><br></pre></td></tr></table></figure>

<h1 id="有选择的打印输出到文件"><a href="#有选择的打印输出到文件" class="headerlink" title="有选择的打印输出到文件"></a>有选择的打印输出到文件</h1><p>如果想要有选择性的把打印内容输出到文件，可以如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;Hello Python!&quot;</span>, file=open(<span class="string">&#x27;output.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">print(<span class="string">&quot;We are printing to file.&quot;</span>, file=open(<span class="string">&#x27;output.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>))</span><br></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://stackabuse.com/writing-to-a-file-with-pythons-print-function/">Writing to a File with Python’s print() Function</a></li>
<li><a href="https://stackoverflow.com/questions/7152762/how-to-redirect-print-output-to-a-file">How to redirect ‘print’ output to a file?</a></li>
<li><a href="https://www.kite.com/python/answers/how-to-redirect-print-output-to-a-text-file-in-python">How to redirect print output to a text file in Python</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 PyQt5 开发 Python 图形用户程序</title>
    <url>/2021/11/28/python-qt-gui/</url>
    <content><![CDATA[<p>Python 作为一种高级编程语言，简洁高效，开发效率高。将 Python 与 JupyterLab 结合使用非常方便，也是我之前常采用的形式。但本篇主要介绍用 Python 开发桌面等应用程序，利用图形界面实现与用户交互。本篇将包含 Miniconda, PyQt5, pyqt5-tools, Qt Designer, pyinstaller 等。</p>
<a id="more"></a>

<h1 id="安装需要的包"><a href="#安装需要的包" class="headerlink" title="安装需要的包"></a>安装需要的包</h1><p>首先，从<a href="https://docs.conda.io/en/latest/miniconda.html">官网</a>下载 Miniconda，配置好开发环境，这时就可以使用 Python 了。</p>
<p>其次，从 <a href="https://pypi.org/">Python packages 官网</a> 安装 PyQt5 和 pyqt5-tools（PyQt6 在 2021年1月份已经发布，截止本篇文章，已经到 6.2.1，大家可以自己选择使用）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install PyQt5</span><br><span class="line">pip install pyqt5-tools</span><br></pre></td></tr></table></figure>

<p>到目前，所安装的包已经足够开发 Python 图形用户程序，但设计图形界面不是那么直观，可利用下面的 Qt Designer  进行图形设计界面。</p>
<p>然后，从网址 <a href="https://build-system.fman.io/qt-designer-download">fman build system</a> 下载 Qt Designer，包含有 Windows 版和 Mac 版。下载需要的版本，并安装。在 Windows 上利用 Miniconda 安装过 PyQt5 和 pyqt5-tools 后，默认会在路径 <code>miniconda\Lib\site-packages\qt5_applications\Qt\bin</code>下包含有 Qt Designer 工具，只需要把它添加到 PyCharm 中即可，方法如下：<font color=cyan>在设置中搜索 external tools， 打开后，添加，主要是把路径设置好即可。这样在工程主目录右键即可看到 external tools 里的 qt designer (添加时自己设置的名字)</font>。</p>
<p>最后，安装打包程序 pyinstaller:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install pyinstaller</span><br></pre></td></tr></table></figure>

<h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>首先，使用 Qt Designer 设计需要的图形界面，然后保存，如 <code>test.ui</code>.</p>
<p>其次，进入该文件的目录，打开 shell 或 cmd，输入如下命令，把其转化为 .py 文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyuic5 -x test.ui -o main.py</span><br></pre></td></tr></table></figure>

<p>只需要把它添加到 PyCharm 中即可，方法如下：<font color=cyan>在设置中搜索 external tools， 打开后，添加，program 选择程序路径，arguments 填写 <code>$FileName$ -o $FileNameWithoutExtension$.py</code>,  working directory 填写 <code>$FileDir$</code>， 设置好点确定即可。这样在工程主目录右键即可看到 external tools 里的 PyUIC5 (添加时自己设置的名字)</font>。</p>
<p>然后，在该文件中开发，增加各按钮等的功能函数。此时，运行程序能够看到程序演示效果。</p>
<p>最后，使用 pyinstaller 将 Python 程序打包成可独立运行的应用程序。因为其将运行该程序的所有依赖环境都打包进一个 .exe 或 .app 文件中，所以可以拷贝或传播到其他电脑上使用。打包方法如下（首先进入工程目录，假设 main.py 是程序主入口）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 常用方法，打包成一个文件夹，该方法比加 -F 打包成一个文件的程序启动速度快3-6倍</span></span><br><span class="line">pyinstaller main.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># -w (--noconsole) 设置程序运行时不显示黑框；-i icon.ico 设置程序图标</span></span><br><span class="line">pyinstaller -w -i icon.ico main.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加额外数据，如图像资源</span></span><br><span class="line"><span class="comment"># pyinstaller x.py --add-data=&quot;源地址;目标地址&quot;。 windows以;分割，linux以:分割</span></span><br><span class="line"><span class="comment"># 如下，会把 main.py 同目录下的 resources 文件夹，打包到 dist/main 文件夹中，命名仍然是 resources</span></span><br><span class="line">pyinstaller main.py --add-data resources;resources</span><br><span class="line"></span><br><span class="line"><span class="comment"># 个人常用方法</span></span><br><span class="line"><span class="comment"># 不显示控制台，清空上次打包痕迹，设置图标，打包到release1.0，添加资源</span></span><br><span class="line">pyinstaller main.py -w --clean -i icon.ico --distpath release1.0 --add-data resources;resources</span><br></pre></td></tr></table></figure>

<p>详细打包方法可参考我的另一篇：<a href="https://xujinzh.github.io/2020/07/21/python-to-exe/">Python 程序编译成 exe 可执行文件</a>.</p>
<p>此时，点击 dist 目录下的 main.exe 或 main.app 就可以运行程序了。</p>
<p><font color=cyan>注意：打包时建议使用 conda 另外创建一个新的虚拟环境，该坏境包含运行程序必须的包即可，其他建议不要安装，这样打包的程序会较小。</font></p>
<p>利用 conda 创建虚拟环境的方法可参考我的另一篇：<a href="https://xujinzh.github.io/2020/03/25/conda-jupyter-env-kernel/">Conda 配置其他虚拟环境 jupyter kernel</a>.</p>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>shell</tag>
        <tag>pyqt5</tag>
        <tag>gui</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行运行 Python 代码时传参数</title>
    <url>/2021/10/25/python-shell-run-with-arguments/</url>
    <content><![CDATA[<p>Python 代码能够以多种形式运行，如在 JupyterLab 中交互式方式、在 PyCharm 中以工程代码形式运行。有时，我们还需要在终端或CMD 以命令行的形式运行。这些运行方式都能够实现 Python 代码的运行。对于需要自定义参数的代码，在 JupyterLab 中我们可以把参数写入单元格内，在 PyCharm 中我们可以将参数写入配置文件内，那么在终端或CMD运行 Python 代码时，如何传入参数呢，下面介绍两种方法。</p>
<a id="more"></a>

<h1 id="利用-sys-包"><a href="#利用-sys-包" class="headerlink" title="利用 sys 包"></a>利用 sys 包</h1><p>编写名为 <code>shellSysArgv.py</code> 的模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试命令行运行 python 代码时传参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;x=<span class="subst">&#123;x&#125;</span>, y=<span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;done!&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    x = sys.argv[<span class="number">1</span>]</span><br><span class="line">    y = sys.argv[<span class="number">2</span>]</span><br><span class="line">    main(x, y)</span><br></pre></td></tr></table></figure>

<p>在 shell 中调用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python shellSysArgv.py 1 2        </span><br><span class="line">x=1, y=2</span><br><span class="line"><span class="keyword">done</span>!</span><br></pre></td></tr></table></figure>

<h1 id="利用-argparse-包"><a href="#利用-argparse-包" class="headerlink" title="利用 argparse 包"></a>利用 argparse 包</h1><p>编写名为 <code>shellArgParse.py</code> 的模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试命令行运行 python 代码时传参数，同时对参数进行限制</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">x_data, y_data</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;x=<span class="subst">&#123;x_data&#125;</span>, y=<span class="subst">&#123;y_data&#125;</span>&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;done!&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    ap = argparse.ArgumentParser()</span><br><span class="line">    ap.add_argument(<span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;--x_data&#x27;</span>, required=<span class="literal">True</span>, type=str, default=<span class="string">&#x27;1&#x27;</span>, help=<span class="string">&#x27;x axis&#x27;</span>)</span><br><span class="line">    ap.add_argument(<span class="string">&#x27;-y&#x27;</span>, <span class="string">&#x27;--y_data&#x27;</span>, required=<span class="literal">True</span>, type=str, default=<span class="string">&#x27;2&#x27;</span>, help=<span class="string">&#x27;y axis&#x27;</span>)</span><br><span class="line">    args = vars(ap.parse_args())</span><br><span class="line">    </span><br><span class="line">    x_data = args[<span class="string">&#x27;x_data&#x27;</span>]</span><br><span class="line">    y_data = args[<span class="string">&#x27;y_data&#x27;</span>]</span><br><span class="line">    main(x_data, y_data)</span><br></pre></td></tr></table></figure>

<p>在 shell 中调用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python shellArgParse.py -x=1 -y=2</span><br><span class="line">x=1, y=2</span><br><span class="line"><span class="keyword">done</span>!</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://blog.csdn.net/weixin_35653315/article/details/72886718">命令行运行Python脚本时传入参数的三种方式</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 加速计算介绍</title>
    <url>/2020/12/02/python-speeded-up/</url>
    <content><![CDATA[<p>Python 编写程序简单高效，但运行效率相比 C 等较慢，不太适合处理计算密集型任务（对 IO 较适用）。如果想要适用 Python 进行密集计算，可以采用某些手段加速计算，一定程度上缓解这种矛盾。</p>
<a id="more"></a>

<h1 id="Numba-模块"><a href="#Numba-模块" class="headerlink" title="Numba 模块"></a>Numba 模块</h1><p>Numba is an open source JIT compiler that translates a subset of Python and NumPy code into fast machine code. </p>
<p>Numba 是开源的 JIT 编译器，它通过 llvmlite Python 包，使用 LLVM 将 Python 的子集和 NumPy 翻译成快速的机器码。它为在 CPU 和 GPU 上并行化 Python 代码提供了大量选项，而经常只需要微小的代码变更。下面给出一个实例介绍 Numba 模块加速计算效果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit, njit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sum1</span>(<span class="params">n=<span class="number">1000</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> sum(range(n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sum2</span>(<span class="params">n=<span class="number">1000</span></span>):</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        sum += i</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@njit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sum3</span>(<span class="params">n=<span class="number">1000</span></span>):</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        sum += i</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    n = <span class="number">100</span></span><br><span class="line">    print(<span class="string">&quot;内置函数优化耗时: &#123;&#125;s&quot;</span>.format(timeit.timeit(<span class="string">&quot;my_sum1(%d)&quot;</span> % n, globals=globals(), number=<span class="number">100</span>_0000)))</span><br><span class="line">    print(<span class="string">&quot;普通循环函数耗时: &#123;&#125;s&quot;</span>.format(timeit.timeit(<span class="string">&quot;my_sum2(%d)&quot;</span> % n, globals=globals(), number=<span class="number">100</span>_0000)))</span><br><span class="line">    print(<span class="string">&quot;jit加速后耗时: &#123;&#125;s&quot;</span>.format(timeit.timeit(<span class="string">&quot;my_sum3(%d)&quot;</span> % n, globals=globals(), number=<span class="number">100</span>_0000)))</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">内置函数优化耗时: 0.9235639999969862s</span><br><span class="line">普通循环函数耗时: 3.137067300005583s</span><br><span class="line">jit加速后耗时: 0.20853160000115167s</span><br></pre></td></tr></table></figure>

<p>使用 Python 内置函数，减少循环能够一定程度上降低运行速度；使用加速模块 numba 在数值循环上能够大大降低运行速度。</p>
<h1 id="Multiprocessing-模块"><a href="#Multiprocessing-模块" class="headerlink" title="Multiprocessing 模块"></a>Multiprocessing 模块</h1><p><a href="https://docs.python.org/zh-cn/3/library/multiprocessing.html#module-multiprocessing"><code>multiprocessing</code></a> 包同时提供了本地和远程并发操作，通过使用子进程而非线程有效地绕过了 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-global-interpreter-lock">全局解释器锁</a>。 因此，<a href="https://docs.python.org/zh-cn/3/library/multiprocessing.html#module-multiprocessing"><code>multiprocessing</code></a> 模块允许程序员充分利用给定机器上的多个处理器。 它在 Unix 和 Windows 上均可运行。</p>
<p>一般使用方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">p1 = Process(target=my_sum1, args=(<span class="number">10000</span>_0000,))</span><br><span class="line">p2 = Process(target=my_sum2, args=(<span class="number">10000</span>_0000,))</span><br><span class="line">p3 = Process(target=my_sum3, args=(<span class="number">10000</span>_0000,))</span><br><span class="line">p1.start()</span><br><span class="line">p2.start()</span><br><span class="line">p3.start()</span><br><span class="line">p1.join()</span><br><span class="line">p2.join()</span><br><span class="line">p3.join()</span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">&quot;总共用时 &#123;&#125; 秒&quot;</span>.format((end - start)))</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">总共用时 4.6657445430755615 秒</span><br></pre></td></tr></table></figure>

<p>不使用多进程时：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">s</span>):</span></span><br><span class="line">    print(s.__name__)</span><br><span class="line">    <span class="keyword">return</span> s(<span class="number">10000</span>_0000)</span><br><span class="line">   </span><br><span class="line">start = time.time()</span><br><span class="line">main(my_sum1)</span><br><span class="line">main(my_sum2)</span><br><span class="line">main(my_sum3)</span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">&quot;总共用时 &#123;&#125; 秒&quot;</span>.format((end - start)))</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_sum1</span><br><span class="line">my_sum2</span><br><span class="line">my_sum3</span><br><span class="line">总共用时 <span class="number">6.19011664390564</span> 秒</span><br></pre></td></tr></table></figure>

<p>可见多进程确实降低了时间。</p>
<p>当调用函数相同，参数变化时，可以使用如下方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">p = Pool(processes=os.cpu_count())</span><br><span class="line">p.map_async(main, [my_sum1, my_sum2, my_sum3])</span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">&quot;总共用时 &#123;&#125; 秒&quot;</span>.format((end - start)))</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">总共用时 0.3504462242126465 秒</span><br><span class="line">my_sum1my_sum2</span><br><span class="line"></span><br><span class="line">my_sum3</span><br></pre></td></tr></table></figure>

<p>可以看出，结果比较混乱，而且计时不对，这是因为采用 map_async 异步非阻塞方式进行的。下面是非异步阻塞式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">p = Pool(processes=os.cpu_count())</span><br><span class="line">p.map(main, [my_sum1, my_sum2, my_sum3])</span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">&quot;总共用时 &#123;&#125; 秒&quot;</span>.format((end - start)))</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">my_sum1my_sum2my_sum3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总共用时 5.382384300231934 秒</span><br></pre></td></tr></table></figure>

<p>无论采用哪种多进程模式，都能够降低运行时间。</p>
<p>还有一种多进程使用方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">result_objs = []</span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">with</span> Pool(processes=os.cpu_count()) <span class="keyword">as</span> p:</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> [my_sum1, my_sum2, my_sum3]:</span><br><span class="line">        result = p.apply_async(main, (f,))</span><br><span class="line">        result_objs.append(result)</span><br><span class="line">    <span class="comment"># 使用get方法获取值</span></span><br><span class="line">    results = [result.get() <span class="keyword">for</span> result <span class="keyword">in</span> result_objs]</span><br><span class="line">    print(results)</span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">&quot;总共用时 &#123;&#125; 秒&quot;</span>.format((end - start)))</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">my_sum2my_sum1my_sum3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[4999999950000000, 4999999950000000, 4999999950000000]</span><br><span class="line">总共用时 5.462852716445923 秒</span><br></pre></td></tr></table></figure>

<p>上面同样属于异步非阻塞方法，非异步方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">result_objs = []</span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">with</span> Pool(processes=os.cpu_count()) <span class="keyword">as</span> p:</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> [my_sum1, my_sum2, my_sum3]:</span><br><span class="line">        result_objs.append(p.apply(main, (f,)))</span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">&quot;总共用时 &#123;&#125; 秒&quot;</span>.format((end - start)))</span><br><span class="line">print(result_objs)</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">my_sum1</span><br><span class="line">my_sum2</span><br><span class="line">my_sum3</span><br><span class="line">总共用时 6.348566055297852 秒</span><br><span class="line">[4999999950000000, 4999999950000000, 4999999950000000]</span><br></pre></td></tr></table></figure>

<p>关于 map, map_async, apply, apply_async 的区别，如下表：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">             Multi-args   Concurrence    Blocking     Ordered-results</span></span><br><span class="line"><span class="code">map          no           yes            yes          yes</span></span><br><span class="line"><span class="code">apply        yes          no             yes          no</span></span><br><span class="line"><span class="code">map_async    no           yes            no           yes</span></span><br><span class="line"><span class="code">apply_async  yes          yes            no           no</span></span><br></pre></td></tr></table></figure>

<p>可以根据需要选择相应的多进程方法。</p>
<p>关于异步非阻塞式和非异步阻塞式：</p>
<ul>
<li>异步非阻塞式是主进程首先运行，碰到子进程不切换，当操作系统进行切换时，再运行子进程。如上面的 async 式的，主进程将首先遍历完整个代码，打印时间，切换后，运行子进程 p.map_async(main, [my_sum1, my_sum2, my_sum3]) 中的 main(my_sum1) 等。</li>
</ul>
<ul>
<li>非异步阻塞式是首先主进程开始运行，碰到子进程，操作系统切换到子进程，等待子进程运行结束后，再切换到另外一个子进程，直到所有子进程运行完毕。然后再切换到主进程，运行剩余的部分。</li>
</ul>
<h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p>求 2 ~ 250001 中所有素数的个数。</p>
<h2 id="使用-C-语言编程"><a href="#使用-C-语言编程" class="headerlink" title="使用 C 语言编程"></a>使用 C 语言编程</h2><p>编程 C 程序，保存为 primes.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(n%i))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numPrimes=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;<span class="number">250001</span>; i++)&#123;</span><br><span class="line">        numPrimes+=isPrime(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, numPrimes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">gcc primes.c -o primes</span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">time ./primes</span><br></pre></td></tr></table></figure>

<p>结果如下，耗时 8秒多</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ time ./primes </span><br><span class="line">22044</span><br><span class="line">./primes  8.52s user 0.00s system 99% cpu 8.522 total</span><br></pre></td></tr></table></figure>

<p>下面，使用python程序测试运行时间。</p>
<h2 id="编写第一个Python程序"><a href="#编写第一个Python程序" class="headerlink" title="编写第一个Python程序"></a>编写第一个Python程序</h2><p>编程 python 程序，保存为 primes.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    判断给定的n是否为素数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 只需要用n除以2 ~ n/2 + 1 是否能整除</span></span><br><span class="line">    <span class="comment"># 如果有整数整除n，则n不是素数</span></span><br><span class="line">    <span class="comment"># 如果所有的都不能整数n，则n是素数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n//<span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 如果余数是0，则表示整除，不是素数，直接返回0</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> (n % i)):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 如果所有的数都不能整除n，则说明n是素数，则返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    numPrimes = <span class="number">0</span>  <span class="comment"># 记录素数的个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 统计2 ~ 250001 中有多少个素数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">250001</span>):</span><br><span class="line">        numPrimes += isPrime(i)</span><br><span class="line">    <span class="comment"># 打印素数的个数</span></span><br><span class="line">    print(numPrimes)</span><br></pre></td></tr></table></figure>

<p>不需要编译，直接运行。结果耗时111秒多</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ time python primes.py </span><br><span class="line">22044</span><br><span class="line">python primes.py  111.71s user 0.02s system 99% cpu 1:51.76 total</span><br></pre></td></tr></table></figure>

<h2 id="编写第二个Python程序"><a href="#编写第二个Python程序" class="headerlink" title="编写第二个Python程序"></a>编写第二个Python程序</h2><p>使用numba加速。编程 python 程序，保存为 primesNumbaSpeed.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit</span><br><span class="line"></span><br><span class="line"><span class="meta">@jit(nopython=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    判断给定的n是否为素数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 只需要用n除以2 ~ n/2 + 1 是否能整除</span></span><br><span class="line">    <span class="comment"># 如果有整数整除n，则n不是素数</span></span><br><span class="line">    <span class="comment"># 如果所有的都不能整数n，则n是素数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n//<span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 如果余数是0，则表示整除，不是素数，直接返回0</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> (n % i)):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 如果所有的数都不能整除n，则说明n是素数，则返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    numPrimes = <span class="number">0</span>  <span class="comment"># 记录素数的个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 统计2 ~ 250001 中有多少个素数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">250001</span>):</span><br><span class="line">        numPrimes += isPrime(i)</span><br><span class="line">    <span class="comment"># 打印素数的个数</span></span><br><span class="line">    print(numPrimes)</span><br></pre></td></tr></table></figure>

<p>不需要编译，直接运行。结果耗时10秒多，比上一版快了10倍多</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ time python primesNumbaSpeed.py </span><br><span class="line">22044</span><br><span class="line">python primesNumbaSpeed.py  10.52s user 3.39s system 140% cpu 9.929 total</span><br></pre></td></tr></table></figure>

<h2 id="编写第三个Python程序"><a href="#编写第三个Python程序" class="headerlink" title="编写第三个Python程序"></a>编写第三个Python程序</h2><p>使用numba 和 multiprocessing 加速。编程 python 程序，保存为 primesNumbaSpeed.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">l, size</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Returns a new list with elements</span></span><br><span class="line"><span class="string">    of which is a list of certain size.</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; partition([1, 2, 3, 4], 3)</span></span><br><span class="line"><span class="string">        [[1, 2, 3], [4]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [l[i : i + size] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(l), size)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@jit(nopython=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    判断给定的n是否为素数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 只需要用n除以2 ~ n/2 + 1 是否能整除</span></span><br><span class="line">    <span class="comment"># 如果有整数整除n，则n不是素数</span></span><br><span class="line">    <span class="comment"># 如果所有的都不能整数n，则n是素数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 如果余数是0，则表示整除，不是素数，直接返回0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (n % i):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 如果所有的数都不能整除n，则说明n是素数，则返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumPrime</span>(<span class="params">l</span>):</span></span><br><span class="line">    <span class="keyword">return</span> sum(list(map(isPrime, l)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    numPrimes = <span class="number">0</span>  <span class="comment"># 记录素数的个数</span></span><br><span class="line">    lp = partition(range(<span class="number">2</span>, <span class="number">250001</span>), <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">with</span> Pool(<span class="number">15</span>) <span class="keyword">as</span> p:</span><br><span class="line">        numPrimes = sum(p.map(sumPrime, lp))</span><br><span class="line">    <span class="comment"># 打印素数的个数</span></span><br><span class="line">    print(numPrimes)</span><br></pre></td></tr></table></figure>

<p>不需要编译，直接运行。显示耗时15 秒多。因为使用多进程，时间显示不准确，实际耗时只有1.4 秒左右。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ time python primeMultiprocessSpeed.py</span><br><span class="line">22044</span><br><span class="line">python primeMultiprocessSpeed.py  15.33s user 9.42s system 1041% cpu 2.375 total</span><br></pre></td></tr></table></figure>

<p>在 notebook 中调用打印真实时间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> primeMultiprocessSpeed <span class="keyword">import</span> sumPrime, partition</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%timeit</span><br><span class="line">numPrimes = <span class="number">0</span>  <span class="comment"># 记录素数的个数</span></span><br><span class="line">lp = partition(range(<span class="number">2</span>, <span class="number">250001</span>), <span class="number">100</span>)</span><br><span class="line"><span class="keyword">with</span> Pool(<span class="number">15</span>) <span class="keyword">as</span> p:</span><br><span class="line">    numPrimes = sum(p.map(sumPrime, lp))</span><br><span class="line"><span class="comment"># 打印素数的个数</span></span><br><span class="line">print(numPrimes)</span><br></pre></td></tr></table></figure>

<p>时间消耗 1.4 秒左右，比 C 语言写的代码还要快 3 倍。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">22044</span><br><span class="line">22044</span><br><span class="line">22044</span><br><span class="line">22044</span><br><span class="line">22044</span><br><span class="line">22044</span><br><span class="line">22044</span><br><span class="line">22044</span><br><span class="line">1.4 s ± 85.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span><br></pre></td></tr></table></figure>

<p>因此，当使用 python 进行快速开发时，如果需要优化运行速度，建议使用 numba 和 multiprocessing 进行加速。</p>
<h1 id="使用-pyinstrument-发现-python-程序中执行耗时的部分"><a href="#使用-pyinstrument-发现-python-程序中执行耗时的部分" class="headerlink" title="使用 pyinstrument 发现 python 程序中执行耗时的部分"></a>使用 pyinstrument 发现 python 程序中执行耗时的部分</h1><p>首先安装包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pyinstrument</span><br></pre></td></tr></table></figure>

<p>使用方法（在 notebook 中运行）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">!/usr/local/miniconda/bin/pyinstrument pyscripts/primeMultiprocessSpeed.py</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">22044</span><br><span class="line"></span><br><span class="line">  <span class="emphasis">_     ._</span>   <span class="strong">__/__</span>   <span class="emphasis">_ _</span>  <span class="emphasis">_  _</span> <span class="emphasis">_/_</span>   Recorded: 11:22:18  Samples:  592</span><br><span class="line"> /<span class="emphasis">_//_</span>/// /<span class="emphasis">_\ / //_</span>// / //<span class="emphasis">_&#x27;/ //     Duration: 2.449     CPU time: 2.772</span></span><br><span class="line"><span class="emphasis">/   _</span>/                      v4.1.1</span><br><span class="line"></span><br><span class="line">Program: pyscripts/primeMultiprocessSpeed.py</span><br><span class="line"></span><br><span class="line">2.448 <span class="xml"><span class="tag">&lt;<span class="name">module</span>&gt;</span></span>  ../<span class="xml"><span class="tag">&lt;<span class="name">string</span>&gt;</span></span>:1</span><br><span class="line">   [4 frames hidden]  .., runpy</span><br><span class="line"><span class="code">      2.448 _run_code  runpy.py:64</span></span><br><span class="line"><span class="code">      └─ 2.448 &lt;module&gt;  primeMultiprocessSpeed.py:1</span></span><br><span class="line"><span class="code">         ├─ 1.639 map  multiprocessing/pool.py:359</span></span><br><span class="line"><span class="code">         │     [7 frames hidden]  multiprocessing, threading, ..</span></span><br><span class="line"><span class="code">         │        1.639 lock.acquire  ../&lt;built-in&gt;:0</span></span><br><span class="line"><span class="code">         ├─ 0.703 &lt;module&gt;  numba/__init__.py:1</span></span><br><span class="line"><span class="code">         │     [1389 frames hidden]  numba, llvmlite, pkg_resources, .., p...</span></span><br><span class="line"><span class="code">         ├─ 0.037 Pool  multiprocessing/context.py:115</span></span><br><span class="line"><span class="code">         │     [28 frames hidden]  multiprocessing, threading, ..</span></span><br><span class="line"><span class="code">         ├─ 0.036 wrapper  numba/core/decorators.py:196</span></span><br><span class="line"><span class="code">         │     [109 frames hidden]  numba, functools, llvmlite, ..</span></span><br><span class="line"><span class="code">         └─ 0.025 __exit__  multiprocessing/pool.py:735</span></span><br><span class="line"><span class="code">               [12 frames hidden]  multiprocessing, ..</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">To view this report with different options, run:</span></span><br><span class="line"><span class="code">    pyinstrument --load-prev 2021-12-17T11-22-18 [options]</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure>

<p>从每行的前面的运行时间，可以看到程序耗时的地方在哪里。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://feelncut.com/2018/05/14/150.html">Python 进程池和线程池的简单使用</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>multiprocess</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 定时任务</title>
    <url>/2021/10/27/python-timed-task/</url>
    <content><![CDATA[<p>利用计算机能够帮助我们执行定时定点或者间隔时间段的任务，特别是对于容易遗忘、重复操作、准点执行等任务非常方便。除了在 Linux 上使用 corntab 等完成之外，在 Python 中也可以编程实现定时定点等任务的执行。本篇介绍 time, threading.Timer, schedule, apscheduler 等四个模块。</p>
<a id="more"></a>

<h1 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h1><p>定时 3 秒后，依次执行相同任务 5 次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showTime</span>(<span class="params">count</span>):</span></span><br><span class="line">    time.sleep(count)</span><br><span class="line">    print(datetime.now().strftime(<span class="string">&quot;%Y/%m/%d %H:%M:%S&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 while 可永久执行</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    showTime(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Threading-Timer"><a href="#Threading-Timer" class="headerlink" title="Threading.Timer"></a>Threading.Timer</h1><p>定时 3 秒后，同时执行相同任务 5 次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showTime</span>():</span></span><br><span class="line">    print(datetime.now().strftime(<span class="string">&quot;%Y/%m/%d %H:%M:%S&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 while 可永久执行</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    count = <span class="number">3</span></span><br><span class="line">    t = Timer(count, showTime)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

<h1 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h1><p>每个 3 秒，执行任务</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> schedule</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showTime</span>():</span></span><br><span class="line">    print(datetime.now().strftime(<span class="string">&quot;%Y/%m/%d %H:%M:%S&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">schedule.every(<span class="number">3</span>).seconds.do(showTime)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    schedule.run_pending()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h1 id="apscheduler"><a href="#apscheduler" class="headerlink" title="apscheduler"></a>apscheduler</h1><p>定时顶点/间隔执行任务</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定制执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showTime</span>():</span></span><br><span class="line">    print(datetime.now().strftime(<span class="string">&quot;%Y/%m/%d %H:%M:%S&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建调度器对象，并设置时区</span></span><br><span class="line">scheduler = BlockingScheduler(timezone=<span class="string">&quot;Asia/Shanghai&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分配任务</span></span><br><span class="line"><span class="comment">## 使用 cron，类似 Linux 中 crontab</span></span><br><span class="line"><span class="comment"># scheduler.add_job(func=showTime, trigger=&quot;cron&quot;, day_of_week=&#x27;0-6&#x27;, hour=14, minute=15, second=1)</span></span><br><span class="line">scheduler.add_job(func=showTime, trigger=<span class="string">&quot;cron&quot;</span>, second=<span class="string">&#x27;*/3&#x27;</span>) <span class="comment"># 每隔 3 秒执行一次</span></span><br><span class="line"><span class="comment">## 固定间隔</span></span><br><span class="line"><span class="comment"># scheduler.add_job(func=showTime, trigger=&quot;interval&quot;, seconds=3)</span></span><br><span class="line"><span class="comment">## 定点执行</span></span><br><span class="line"><span class="comment"># scheduler.add_job(func=showTime, trigger=&#x27;date&#x27;, run_date=&#x27;2021-10-27 15:48:05&#x27;, args=[])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动调度器</span></span><br><span class="line">scheduler.start()</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://www.cnblogs.com/traditional/p/10991231.html">你知道 Python 中的定时任务吗？</a></li>
<li><a href="https://www.coder.work/article/2034431">python - 如何通过APScheduler 3.0的UTC时区？</a></li>
<li><a href="https://www.cnblogs.com/-wenli/p/12790257.html">APScheduler定时框架</a></li>
<li><a href="https://segmentfault.com/a/1190000011084828">Python任务调度模块APScheduler</a></li>
</ol>
<iframe src="//player.bilibili.com/player.html?aid=976240224&bvid=BV1v44y1v7jA&cid=428973248&page=13" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>time</tag>
        <tag>timer</tag>
        <tag>schedule</tag>
        <tag>apscheduler</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 程序编译成 exe 可执行文件</title>
    <url>/2020/07/21/python-to-exe/</url>
    <content><![CDATA[<p>Python 是一种解释型语言，编写的程序只能通过解释器来执行，对于一些想要隐藏源代码或者只想在 Windows, Linux, Mac 上通过鼠标双击直接运行程序的同学，直接给 .py 文件不是一个好的解决方法，下面解释两个软件来方便把python 文件转化为 exe 等程序。</p>
<a id="more"></a>

<h1 id="pyinstaller"><a href="#pyinstaller" class="headerlink" title="pyinstaller"></a>pyinstaller</h1><p>pyinstaller 可以在 Windows, Linux, Mac 等平台上使用。</p>
<p>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pyinstaller</span><br></pre></td></tr></table></figure>

<p>使用（进入主程序文件夹）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\Users\xujin\Downloads\Tetris</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包程序，tetris.py 为整个工程的程序入口，类似于 main</span></span><br><span class="line"><span class="comment"># 打包成一个文件夹，包含很多文件和文件夹；-D, --onedir 为默认选项</span></span><br><span class="line">pyinstaller tetris.py</span><br><span class="line">pyinstaller tetris.py -D </span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认打包到 dist 目录下，可使用如下方法改变目录名为 DIR</span></span><br><span class="line">pyinstaller tetris.py --distpath DIR</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空上次打包时产生的文件，重新打包</span></span><br><span class="line">pyinstaller tetris.py --clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包成一个文件</span></span><br><span class="line">pyinstaller -F tetris.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包成一个文件, 并且不显示黑控制台</span></span><br><span class="line">pyinstaller --onefile -w tetris.py</span><br><span class="line"><span class="comment"># 或者如下简短命令</span></span><br><span class="line">pyinstaller -F -w tetris.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包时添加图标</span></span><br><span class="line">pyinstaller -F -w -i icon.ico tetris.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 个人常用</span></span><br><span class="line">pyinstaller tetris.py -i icon.ico</span><br></pre></td></tr></table></figure>

<p>在 dist 中有编译好的 tetris.exe 文件。这时候，可以删除 build 文件夹，把 dist 里面的 tetris.exe 移动主目录下，删除 dist ，删除 tetris.pym 文件。运行 tetris.exe 就可以了。</p>
<p><font color=cyan>注意：打包时建议使用 conda 另外创建一个新的虚拟环境，该坏境包含运行程序必须的包即可，其他建议不要安装，这样打包的程序会较小。</font></p>
<p>利用 conda 创建虚拟环境的方法可参考我的另一篇：<a href="https://xujinzh.github.io/2020/03/25/conda-jupyter-env-kernel/">Conda 配置其他虚拟环境 jupyter kernel</a>.</p>
<p>当打包 PyQt5 编写的 Python 图形程序时，如主窗口有图片 (background.jpg)， 建议使用相对路径(如，./resources/assets/background.jpg, icon.ico)，然后使用 pyinstaller 打包后，将整个 resources 目录拷贝到 dist 里面，这样与 .exe 文件又形成了正确的相对路径，然后使用 NSIS &amp; HM NIS EDIT 打包安装程序时，将 HM NIS EDIT 里的第5步设置为主目录 dist，这些就会将整个 resources 文件和 .exe 都按照原位置安装。</p>
<h1 id="auto-py-to-exe"><a href="#auto-py-to-exe" class="headerlink" title="auto-py-to-exe"></a>auto-py-to-exe</h1><p>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install auto-py-to-exe</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">auto-py-to-exe</span><br></pre></td></tr></table></figure>

<p>其实，auto-py-to-exe 也是调用 pyinstaller 来编译的，只是提供了一个建议的 GUI 界面，编译的结果在主目录下的 output 文件夹下，类似 dist ，可以把 tetris.exe 移动到上一层文件夹下，即主目录下，删除 output，运行 tetris.exe 就可以了。</p>
<h1 id="NSIS"><a href="#NSIS" class="headerlink" title="NSIS"></a>NSIS</h1><p>这个 NSIS 不是编译 .py 文件撑 exe 可执行文件的，而是把上面的结果打包成一个可在 Windows 上的安装包程序的（即使用其打包的文件可进行程序安装），方法如下：</p>
<ol>
<li>下载安装 <a href="https://nsis.sourceforge.io/Download">NSIS</a>；</li>
<li>运行 NSIS；</li>
<li>打包 Tetris 主目录成 Tetris.zip；</li>
<li>在 NSIS 中点击 Compiler 下的 Installer based on .ZIP file；</li>
<li>检索完毕后，选择右下角的 generate；</li>
<li>generate 结束后，可以选择 test 进行测试，或者直接关闭；</li>
<li>双击 Tetris.exe 进行安装软件。</li>
</ol>
<h1 id="HM-NIS-EDIT"><a href="#HM-NIS-EDIT" class="headerlink" title="HM NIS EDIT"></a>HM NIS EDIT</h1><p>在打包安装包程序时，仅仅使用 NSIS 是不够方便的，比如，不能自己设置 ico 图标、打包的安装包程序安装后没有卸载方法。使用 HM NIS EDIT 可以方便解决这些问题，但需要事先安装好 NSIS，然后安装 HM NIS EDIT，并进行打包，方法如下：</p>
<ol>
<li>下载安装 <a href="http://hmne.sourceforge.net/index.php">HM NIS EDIT</a>；</li>
<li>点击文件 –&gt; 新建脚本：向导，安装个人需要进行想要设置，如程序名、版本号、出版人等；一次点击下一步；</li>
<li>在第3步时，设置安装程序图标和语言；</li>
<li>在第4步时，设置授权文件，根据个人需要，没有可以删除，留空；</li>
<li>在第5步时，比较关键，分别把 pyinstaller 打包的 EXE 程序添加进去，如果有图片资源等，需要添加 AddDir Tree，选择主目录（相对于 EXE 程序的，即 EXE 所在目录）；</li>
<li>最后，保持脚本，如果认为没有问题，可以点编译脚本，建议先不点，打开文件后查看是否都正确，然后再右键编译，此时，就会生成 Setup.exe 安装包程序。</li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/162237978">别再问我怎么Python打包成exe了！</a></li>
<li><a href="https://www.codenong.com/cs105537269/">详细介绍：使用NSIS和VNISEdit制作一个自解压的exe安装包</a></li>
<li><a href="https://www.cxyzjd.com/article/weixin_36356040/112618193">打包之后找不到图标_使用NSIS打包程序_第四张牌的博客-程序员宅基地</a></li>
<li><a href="https://blog.csdn.net/weixin_36356040/article/details/112618193">打包之后找不到图标_使用NSIS打包程序</a></li>
<li><a href="https://clay-atlas.com/blog/2019/11/13/python-chinese-tutorial-packages-pyinstaller-image-exe/">[Python] PyInstaller 製作可夾帶圖片的可執行檔</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pyinstaller</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Python 中调用 Shell 命令</title>
    <url>/2021/05/25/python-with-shell-command/</url>
    <content><![CDATA[<p>使用 Python 调用 Shell 命令能够非常方便的使用原生 Shell 命令，扩大 Python 的使用作用范围。进一步说明了 Python 作为胶水语义的特性。</p>
<a id="more"></a>

<h1 id="Python-中使用-shell-命令"><a href="#Python-中使用-shell-命令" class="headerlink" title="Python 中使用 shell 命令"></a>Python 中使用 shell 命令</h1><h2 id="使用-！号"><a href="#使用-！号" class="headerlink" title="使用 ！号"></a>使用 ！号</h2><p>仅在 Jupyter Notebook 中可以使用。对于一些简单命令，如<code>ls, pwd</code>等其实不使用<code>!</code>也是可以的， 但是稍微复杂的 shell 命令是不行的，建议都使用 <code>!</code> 作为 shell 命令的开头在 Jupyter Notebook 中使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">!ls</span><br><span class="line">&gt;...</span><br><span class="line">username = !whoami</span><br><span class="line">username</span><br><span class="line">&gt; <span class="string">&#x27;jinzhongxu&#x27;</span></span><br><span class="line">username[<span class="number">0</span>]</span><br><span class="line">&gt; <span class="string">&#x27;jinzhongxu&#x27;</span></span><br><span class="line">type(username)</span><br><span class="line">&gt; IPython.utils.text.SList</span><br><span class="line">!ls /home/&#123;username[<span class="number">0</span>]&#125;</span><br><span class="line">&gt; Desktop      examples.desktop	 Music	    Videos</span><br><span class="line">  Documents    Pictures   Templates</span><br><span class="line">list(username)[<span class="number">0</span>]</span><br><span class="line">&gt; <span class="string">&#x27;jinzhongxu&#x27;</span></span><br><span class="line">!ls /home/&#123;list(username)[<span class="number">0</span>]&#125;</span><br><span class="line">&gt; Desktop      examples.desktop	 Music	    Videos</span><br><span class="line">  Documents    Pictures   Templates</span><br></pre></td></tr></table></figure>

<h2 id="使用-os-popen-函数"><a href="#使用-os-popen-函数" class="headerlink" title="使用 os.popen 函数"></a>使用 os.popen 函数</h2><p>即可以在 Jupyter Notebook 中使用，也可以在 Pycharm 中使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">command = <span class="string">&#x27;whoami&#x27;</span></span><br><span class="line">username = os.popen(command).read().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">type(username)</span><br><span class="line">&gt; list</span><br><span class="line">username</span><br><span class="line">&gt; [<span class="string">&#x27;jinzhongxu&#x27;</span>, <span class="string">&#x27;&#x27;</span>]</span><br><span class="line">username[<span class="number">0</span>]</span><br><span class="line">&gt; <span class="string">&#x27;jinzhongxu&#x27;</span></span><br><span class="line">command_ls = <span class="string">f&#x27;ls /home/<span class="subst">&#123;username[<span class="number">0</span>]&#125;</span>&#x27;</span></span><br><span class="line">result = os.popen(command_ls).read().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">result</span><br><span class="line">&gt; [<span class="string">&#x27;Desktop&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Documents&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;examples.desktop&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Music&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Pictures&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Templates&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Videos&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="使用-subprocess-Popen-函数"><a href="#使用-subprocess-Popen-函数" class="headerlink" title="使用 subprocess.Popen 函数"></a>使用 subprocess.Popen 函数</h2><p>即可以在 Jupyter Notebook 中使用，也可以在 Pycharm 中使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">p = subprocess.Popen(<span class="string">&quot;ls .&quot;</span>, shell=<span class="literal">True</span>, stdout=subprocess.PIPE)</span><br><span class="line">[name.decode().split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">0</span>] <span class="keyword">for</span> name <span class="keyword">in</span> p.stdout.readlines()]</span><br></pre></td></tr></table></figure>

<h2 id="使用-os-system-函数"><a href="#使用-os-system-函数" class="headerlink" title="使用 os.system 函数"></a>使用 os.system 函数</h2><p>即可以在 Jupyter Notebook 中使用，也可以在 Pycharm 中使用。</p>
<p>注意，该函数直接运行 shell 命令，但返回值是 0，不像 os.popen 和 subprocess.Popen 返回值是 shell 命令运行后的打印结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.system(<span class="string">&quot;ls&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Python-脚本中使用-shell-命令"><a href="#Python-脚本中使用-shell-命令" class="headerlink" title="Python 脚本中使用 shell 命令"></a>Python 脚本中使用 shell 命令</h1><p>在 Python 脚本使用 shell 命令不能使用 “!” 号，可以使用 os.popen、subprocess.Popen、os.system 函数。</p>
<p>注意，os.popen 返回字符串中每一个条目后面带有 ‘\n’; 而 subprocess.Popen 不仅带有 ‘\n’，还是以字节编码的，需要写解码 decode(); os.system 返回值为 0.</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://cloud.tencent.com/developer/article/1486996">Python os.popen() 方法</a></li>
<li><a href="https://docs.python.org/zh-cn/3/library/subprocess.html"><code>subprocess</code> – 子进程管理</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Python 中使用 yaml 做配置文件</title>
    <url>/2021/12/17/python-yaml-config/</url>
    <content><![CDATA[<p>YAML (YAML Ain’t Markup Language™) 是一种直观的能够被电脑识别的数据序列化格式，容易被人类阅读，并且容易和脚本语言交互。YAML 类似于 XML，但是语法比 XML 简单得多，对于转化成数组或可以 hash 的数据时是很简单有效的。</p>
<a id="more"></a>

<p>yaml 的官方网站是：<a href="https://yaml.org/">https://yaml.org</a></p>
<p>安装 yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install PyYAML</span><br></pre></td></tr></table></figure>

<h1 id="读取-yaml-文档"><a href="#读取-yaml-文档" class="headerlink" title="读取 yaml 文档"></a>读取 yaml 文档</h1><p>有文档 test.yaml，内容如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Tom</span> <span class="string">Smith</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">37</span></span><br><span class="line"><span class="attr">spouse:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Jane</span> <span class="string">Smith</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">25</span></span><br><span class="line"><span class="attr">children:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Jimmy</span> <span class="string">Smith</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">15</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Jenny</span> <span class="string">Smith</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>在 python 中利用 yaml 读取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line">filepath = <span class="string">&quot;data/test.yaml&quot;</span></span><br><span class="line">file = open(file=filepath)</span><br><span class="line">file_str = yaml.load(file, yaml.Loader)</span><br><span class="line">print(file_str)</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&#x27;name&#x27;:</span> <span class="string">&#x27;Tom Smith&#x27;</span>,</span><br><span class="line"> <span class="attr">&#x27;age&#x27;:</span> <span class="number">37</span>,</span><br><span class="line"> <span class="attr">&#x27;spouse&#x27;:</span> &#123;<span class="attr">&#x27;name&#x27;:</span> <span class="string">&#x27;Jane Smith&#x27;</span>, <span class="attr">&#x27;age&#x27;:</span> <span class="number">25</span>&#125;,</span><br><span class="line"> <span class="attr">&#x27;children&#x27;:</span> [&#123;<span class="attr">&#x27;name&#x27;:</span> <span class="string">&#x27;Jimmy Smith&#x27;</span>, <span class="attr">&#x27;age&#x27;:</span> <span class="number">15</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">&#x27;name&#x27;:</span> <span class="string">&#x27;Jenny Smith&#x27;</span>, <span class="attr">&#x27;age&#x27;:</span> <span class="number">12</span>&#125;]&#125;</span><br></pre></td></tr></table></figure>

<h1 id="把字典写入-yaml-文档"><a href="#把字典写入-yaml-文档" class="headerlink" title="把字典写入 yaml 文档"></a>把字典写入 yaml 文档</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">&#x27;data/test2.yaml&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">yaml.dump(file_str, f)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch 中 Dataset 和 DataLoader 类的使用方法</title>
    <url>/2021/10/12/pytorch-dataset-dataloader/</url>
    <content><![CDATA[<p>近年来，在学术界和工业界基于 PyTorch 进行深度学习算法研究及模型部署越来越流行，甚至超过了 TensorFlow. 除了其基于动态图的特性外，最主要的是其语法更贴近 Python，容易开发实现和调试。本篇介绍 PyTorch 中为目标跟踪等视觉领域提供的两个基础类 Dataset 和 DataLoader，给出它们的使用方法。</p>
<a id="more"></a>

<h1 id="利用-PyTorch-进行深度学习训练的一般流程"><a href="#利用-PyTorch-进行深度学习训练的一般流程" class="headerlink" title="利用 PyTorch 进行深度学习训练的一般流程"></a>利用 PyTorch 进行深度学习训练的一般流程</h1><ol>
<li>首先创建自定义的 Dataset 类 和 <strong>Sampler</strong> 类(数据采用策略)；</li>
<li>创建自定义的 DataLoader 类；</li>
<li>DataLoader 依据 Dataset 和 Sampler 迭代产生训练数据提供给模型进行训练。</li>
</ol>
<p>总的来说，DataLoader 负责批次调度数据，Sampler 负责数据调度的采样策略生成索引（默认整数），Dataset 负责通过索引提取数据。</p>
<p>Dataset 封装数据集，通过索引获取元素， Sampler 提供索引次序，DataLoader 是一个调度器，迭代 DataLoaderIter 的过程中，迭代Sampler 获得下一索引，并通过该索引使用 Fetcher（Fetcher 是对 Dataset 的封装，使得 DataLoader 代码与 Iterable-style/Map-style Dataset 解耦）获得对应元素。</p>
<h1 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h1><p>Dataset 负责提供图像和标签索引。</p>
<p>Dataset 包含两类，分别是  Map 式数据集，Iterable 式数据集。Iterable 式数据集处理流式数据类，而 Map 式数据集处理常规数据类。目前 CV 中 Map 式数据集用的较多。</p>
<p>torch.utils.data.Dataset 类是所有数据集的抽象父类，如 torch.utils.data.IterableDataset 抽象类就继承自它。Iterable 式数据集都继承自 torch.utils.data.IterableDataset 抽象类， Map 式数据集都继承自 torch.utils.data.Dataset 抽象类。</p>
<h2 id="内建-Dataset"><a href="#内建-Dataset" class="headerlink" title="内建 Dataset"></a>内建 Dataset</h2><p>PyTorch 提供了现成的 Dataset 子类，如果这些类不能满足个人实际业务需求，可以重写 torch.utils.data.Dataset 或 torch.utils.data.IterableDataset 抽象类，构建自定义子类。现成的子类有：</p>
<ul>
<li>Map 式 (继承自 torch.utils.data.Dataset)</li>
</ul>
<ol>
<li>TensorDataset : 每个样本通过沿第一维索引张量来检索</li>
<li>ConcatDataset : 此类可用于组装不同的现有数据集</li>
<li>Subset : 指定索引区间的数据集子集</li>
</ol>
<ul>
<li>Iterable 式 (继承自 torch.utils.data.IterableDataset)</li>
</ul>
<ol>
<li>ChainDataset : 此类可用于组装不同的现有数据集流。这链接操作是即时完成的，因此连接大规模具有此类的数据集将是有效的</li>
</ol>
<h2 id="常使用的数据集"><a href="#常使用的数据集" class="headerlink" title="常使用的数据集"></a>常使用的数据集</h2><p>写好自定义 Dataset 类后，就可以使用。一般的，在 torchvision 中写好了一些 Dataset，我们可以直接下载常见的数据集并使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line">dataset = datasets.MNIST(<span class="string">&#x27;./images/mnist&#x27;</span>, download=<span class="literal">True</span>, train=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>如果想要利用本地的图像数据集，可以如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line">dataset = datasets.ImageFolder(<span class="string">&#x27;./images/mnist&#x27;</span>, train=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>包含的数据集有</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;CIFAR10&#x27;</span>, <span class="string">&#x27;CIFAR100&#x27;</span>, <span class="string">&#x27;EMNIST&#x27;</span>, <span class="string">&#x27;FashionMNIST&#x27;</span>, <span class="string">&#x27;QMNIST&#x27;</span>, <span class="string">&#x27;MNIST&#x27;</span>, <span class="string">&#x27;KMNIST&#x27;</span>, <span class="string">&#x27;STL10&#x27;</span>, <span class="string">&#x27;SVHN&#x27;</span>, <span class="string">&#x27;PhotoTour&#x27;</span>, <span class="string">&#x27;SEMEION&#x27;</span>, <span class="string">&#x27;Omniglot&#x27;</span>, <span class="string">&#x27;SBU&#x27;</span>, <span class="string">&#x27;Flickr8k&#x27;</span>, <span class="string">&#x27;Flickr30k&#x27;</span>, <span class="string">&#x27;VOCSegmentation&#x27;</span>, <span class="string">&#x27;VOCDetection&#x27;</span>, <span class="string">&#x27;Cityscapes&#x27;</span>, <span class="string">&#x27;ImageNet&#x27;</span>, <span class="string">&#x27;Caltech101&#x27;</span>, <span class="string">&#x27;Caltech256&#x27;</span>, <span class="string">&#x27;CelebA&#x27;</span>, <span class="string">&#x27;WIDERFace&#x27;</span>, <span class="string">&#x27;SBDataset&#x27;</span>, <span class="string">&#x27;VisionDataset&#x27;</span>, <span class="string">&#x27;USPS&#x27;</span>, <span class="string">&#x27;Kinetics400&#x27;</span>, <span class="string">&#x27;HMDB51&#x27;</span>,  <span class="string">&#x27;UCF101&#x27;</span>, <span class="string">&#x27;Places365&#x27;</span>, <span class="string">&#x27;Kitti&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="继承-torch-utils-data-Dataset-抽象类"><a href="#继承-torch-utils-data-Dataset-抽象类" class="headerlink" title="继承 torch.utils.data.Dataset 抽象类"></a>继承 torch.utils.data.Dataset 抽象类</h2><p>对于上面内建的 Map 式 Dataset 不能满足业务需求的，可自定义 Dataset，即构建  torch.utils.data.Dataset 子类。</p>
<p> Map 式数据集类表示从索引（key）到样本数据的映射。如：datasets[9] 表示第 9 个图像样本。</p>
<p>在编写 Map 式数据集类时需要继承 torch.utils.data.Dataset 抽象类，重写方法：</p>
<ol>
<li><strong>__getitem__</strong>(self, index) （必须重写）</li>
<li><strong>__len__</strong>(self) (可选，建议重写)</li>
</ol>
<p>通常，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDataset</span>(<span class="params">data.Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># TODO</span></span><br><span class="line">        <span class="comment"># 实例化文件路径或文件名列表等</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="comment"># TODO</span></span><br><span class="line">        <span class="comment"># 1. 从文件中读取一个图片文件 (e.g. using numpy.fromfile, PIL.Image.open).</span></span><br><span class="line">        <span class="comment"># 2. 预处理图片文件 (e.g. torchvision.Transform).</span></span><br><span class="line">        <span class="comment"># 3. 返回图像数据对 (e.g. image and label).</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># TODO</span></span><br><span class="line">        <span class="comment"># 返回整个图像数据集的大小，即图片的个数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可以参考官方代码中的例子(以下代码在 Jupyter Notebook 中使用)：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line">datasets.MNIST??</span><br></pre></td></tr></table></figure>

<p>或者 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TensorDataset</span>(<span class="params">Dataset[Tuple[Tensor, ...]]</span>):</span></span><br><span class="line">    <span class="string">r&quot;&quot;&quot;Dataset wrapping tensors.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Each sample will be retrieved by indexing tensors along the first dimension.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        *tensors (Tensor): tensors that have the same size of the first dimension.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    tensors: Tuple[Tensor, ...]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *tensors: Tensor</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> all(tensors[<span class="number">0</span>].size(<span class="number">0</span>) == tensor.size(<span class="number">0</span>) <span class="keyword">for</span> tensor <span class="keyword">in</span> tensors), <span class="string">&quot;Size mismatch between tensors&quot;</span></span><br><span class="line">        self.tensors = tensors</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">return</span> tuple(tensor[index] <span class="keyword">for</span> tensor <span class="keyword">in</span> self.tensors)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.tensors[<span class="number">0</span>].size(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<h2 id="继承-torch-utils-data-IterableDataset-抽象类"><a href="#继承-torch-utils-data-IterableDataset-抽象类" class="headerlink" title="继承 torch.utils.data.IterableDataset 抽象类"></a>继承 torch.utils.data.IterableDataset 抽象类</h2><p>Iterable 式数据集类表示在图像数据集上的一个可迭代的对象。适合处理流式数据，不适合随机存取。如：iter(datasets) 获取迭代器，然后使用 next 迭代实现遍历。</p>
<p>在编写 Iterable 式数据集类时需要继承 torch.utils.data.IterableDataset 抽象类，重写方法：</p>
<ol>
<li><strong>__iter__</strong>(self) （必须重写）</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIterableDataset</span>(<span class="params">torch.utils.data.IterableDataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        super(MyIterableDataset).__init__()</span><br><span class="line">        <span class="keyword">assert</span> end &gt; start, <span class="string">&quot;this example code only works with end &gt;= start&quot;</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        worker_info = torch.utils.data.get_worker_info()</span><br><span class="line">        <span class="keyword">if</span> worker_info <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># single-process data loading, return the full iterator</span></span><br><span class="line">            iter_start = self.start</span><br><span class="line">            iter_end = self.end</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># in a worker process</span></span><br><span class="line">            <span class="comment"># split workload</span></span><br><span class="line">            per_worker = int(</span><br><span class="line">                math.ceil((self.end - self.start) / float(worker_info.num_workers))</span><br><span class="line">            )</span><br><span class="line">            worker_id = worker_info.id</span><br><span class="line">            iter_start = self.start + worker_id * per_worker</span><br><span class="line">            iter_end = min(iter_start + per_worker, self.end)</span><br><span class="line">        <span class="keyword">return</span> iter(range(iter_start, iter_end))</span><br></pre></td></tr></table></figure>

<p>可以参考官方代码中的例子(以下代码在 Jupyter Notebook 中使用)：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> IterableDataset</span><br><span class="line"></span><br><span class="line">IterableDataset??</span><br></pre></td></tr></table></figure>

<h1 id="Sampler"><a href="#Sampler" class="headerlink" title="Sampler"></a>Sampler</h1><p>Sampler 负责提供遍历数据集所有图像索引的方式。</p>
<p>PyTorch 实现了如下几类方式：</p>
<ol>
<li>SequentialSampler</li>
<li>RandomSampler</li>
<li>SubsetRandomSampler</li>
<li>WeightedRandomSampler</li>
<li>BatchSampler</li>
<li>DistributedSampler</li>
</ol>
<p>SequentialSampler 是顺序采样器。RandomSampler、SubsetRandomSampler、WeightedRandomSampler 是随机采样器。BatchSampler 是批次采样器，DistributedSampler 是分布式采样器。</p>
<p>如果内建采样器不能满足需求，可以自定义采样器，继承自 torch.utils.data.Sampler，需要重写方法：</p>
<ol>
<li><strong>__iter__</strong>(self) （必须重写）</li>
<li><strong>__len__</strong>(self) (可选重写)</li>
</ol>
<h1 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h1><p>Dataloader 结合数据集 Dataset 和采样器 Sampler，并提供可迭代的给定的数据集。Dataloader 负责加载数据，同时支持 Map 式和 Iterable 式 Dataset，支持单进程/多进程，还可以设置加载顺序(loading order)、批次大小(batch size)、CUDA固定内存(pin memory)等参数。在训练和测试深度学习网络中，我们直接遍历 Dataloader 来获取数据（data、label等），并将数据喂给网络用于前向传播。</p>
<p>常见的模型训练框架</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建 Dateset 和 Sampler</span></span><br><span class="line">dataset = MyDataset()</span><br><span class="line">sampler = SequentialSampler()</span><br><span class="line"><span class="comment"># Dataset 传递给 DataLoader</span></span><br><span class="line">dataloader = torch.utils.data.DataLoader(dataset=dataset, sampler=sampler, batch_size=<span class="number">64</span>, shuffle=<span class="literal">False</span>, num_workers=<span class="number">8</span>)</span><br><span class="line"><span class="comment"># DataLoader 迭代产生训练数据提供给模型</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(epoch):</span><br><span class="line">    <span class="keyword">for</span> index, (img, label) <span class="keyword">in</span> enumerate(dataloader):</span><br><span class="line">        img, label = img.to(device), label.to(device).squeeze()</span><br><span class="line">        opt.zero_grad()</span><br><span class="line">        logits = model(img)</span><br><span class="line">        loss = criterion(logits, label)</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>DataLoader 参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataLoader(dataset, batch_size=<span class="number">1</span>, shuffle=<span class="literal">False</span>, sampler=<span class="literal">None</span>,</span><br><span class="line">           batch_sampler=<span class="literal">None</span>, num_workers=<span class="number">0</span>, collate_fn=<span class="literal">None</span>,</span><br><span class="line">           pin_memory=<span class="literal">False</span>, drop_last=<span class="literal">False</span>, timeout=<span class="number">0</span>,</span><br><span class="line">           worker_init_fn=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>参数介绍： </p>
<p><code>dataset</code> (<em>Dataset</em>) – 定义好的 Map 式或者 Iterable 式数据集</p>
<p><code>batch_size</code> (<em>python:int, optional</em>) 一个 batch 含有多少样本 (default: 1)</p>
<p><code>shuffle</code> (<em>bool, optional</em>) – 每一个 epoch 的 batch 样本是相同还是随机 (default: False)。表示每一个 epoch 中训练样本的顺序是否相同，一般 True</p>
<p><code>sampler</code> (<em>Sampler, optional</em>) – 决定数据集中采样的方法. 如果有，则 shuffle 参数必须为 False </p>
<p><code>batch_sampler</code> (<em>Sampler, optional</em>) 和 sampler 类似，但是一次返回的是一个 batch 内所有样本的 index。和 batch_size, shuffle, sampler, and drop_last 三个参数互斥</p>
<p><code>num_workers</code> (<em>python:int, optional</em>) 多少个子程序同时工作来获取数据，多线程。 (default: 0)</p>
<p><code>collate_fn</code> (<em>callable, optional</em>) 合并样本列表以形成小批量</p>
<p><code>pin_memory</code> (<em>bool, optional</em>) 如果为 True，数据加载器在返回前将张量复制到 CUDA 固定内存中</p>
<p><code>drop_last</code> (<em>bool, optional</em>) – 如果数据集大小不能被 batch_size 整除，设置为 True 可删除最后一个不完整的批处理。如果设为 False 并且数据集的大小不能被 batch_size 整除，则最后一个 batch 将更小。(default: False) </p>
<p><code>timeout</code> (<em>numeric, optional</em>) 如果是正数，表明等待从 worker 进程中收集一个 batch 等待的时间，若超出设定的时间还没有收集到，那就不收集这个内容了。这个 numeric 应总是大于等于0。 (default: 0) </p>
<p><code>worker_init_fn</code> (_callable, optional*) 每个 worker 初始化函数 (default: None)</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://bbs.cvmart.net/articles/5467">一文读懂 PyTorch 中 Dataset 与 DataLoader</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/270028097">PyTorch源码解析与实践（1）：数据加载Dataset，Sampler与DataLoader</a></li>
</ol>
]]></content>
      <categories>
        <category>research</category>
        <category>object tracking</category>
      </categories>
      <tags>
        <tag>dl</tag>
        <tag>python</tag>
        <tag>vot</tag>
        <tag>cv</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch 模型保存和加载</title>
    <url>/2021/06/22/pytorch-model-save-load/</url>
    <content><![CDATA[<p>在训练深度学习模型时，需要定时保存最优模型；当模型训练时间过长，中断训练判断是否继续训练时，需要保存模型；当训练好的模型拿给别人推断时，需要保存模型，等等。模型的保存和加载在深度学习模型的研究和推理时经常使用。本文介绍如何在 PyTorch 中保存和加载模型。建议阅读文献3.</p>
<a id="more"></a>

<h1 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h1><h2 id="torch-save"><a href="#torch-save" class="headerlink" title="torch.save()"></a>torch.save()</h2><p>将序列化对象保存到磁盘。此函数使用 Python 的 pickle 实用程序进行序列化。使用此功能可以保存各种对象的模型、张量和字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.save(obj, f, pickle_module=&lt;module <span class="string">&#x27;pickle&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;/usr/local/miniconda/lib/python3.8/pickle.py&#x27;</span>&gt;, pickle_protocol=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">obj – 保存对象</span><br><span class="line">f － 类文件对象 (返回文件描述符)或一个保存文件名的字符串，一般保存文件的扩展名为 .pth 或者 .pt</span><br><span class="line">pickle_module – 用于 pickling 元数据和对象的模块</span><br><span class="line">pickle_protocol – 指定 pickle protocal 可以覆盖默认参数</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存整个模型</span></span><br><span class="line">torch.save(model,<span class="string">&#x27;best.pth&#x27;</span>)</span><br><span class="line"><span class="comment"># 保存模型参数（训练得到的权重）</span></span><br><span class="line">torch.save(model.state_dict(), <span class="string">&#x27;best.pth&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="torch-load"><a href="#torch-load" class="headerlink" title="torch.load()"></a>torch.load()</h2><p>从磁盘文件中读取一个通过<code>torch.save()</code>保存的对象。 <code>torch.load()</code> 可通过参数<code>map_location</code> 动态地进行内存重映射，使其能从不同设备中读取文件。一般调用时，需两个参数: storage 和 location tag. 返回不同地址中的 storage，或返回 None (此时地址可以通过默认方法进行解析)。如果这个参数是字典的话，意味着其是从文件的地址标记到当前系统的地址标记的映射。 默认情况下， location tags 中 “cpu” 对应 host tensors，‘cuda:device_id’ (e.g. ‘cuda:2’) 对应 cuda tensors。 用户可以通过 register_package 进行扩展，使用自己定义的标记和反序列化方法。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.load(f, map_location=<span class="literal">None</span>, pickle_module=&lt;module <span class="string">&#x27;pickle&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;/usr/local/miniconda/lib/python3.8/pickle.py&#x27;</span>&gt;)</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">f – 类文件对象 (返回文件描述符)或一个保存文件名的字符串</span><br><span class="line">map_location – 一个函数或字典规定如何 remap 存储位置</span><br><span class="line">pickle_module – 用于 unpickling 元数据和对象的模块 (必须匹配序列化文件时的 pickle_module )</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载整个模型</span></span><br><span class="line">torch.load(<span class="string">&#x27;best.pth&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 加载到 CPU</span></span><br><span class="line">torch.load(<span class="string">&#x27;best.pth&#x27;</span>, map_location=torch.device(<span class="string">&#x27;cpu&#x27;</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用函数加载到 CPU</span></span><br><span class="line">torch.load(<span class="string">&#x27;best.pth&#x27;</span>, map_location=<span class="keyword">lambda</span> storage, loc: storage)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 加载到 GPU 1</span></span><br><span class="line">torch.load(<span class="string">&#x27;best.pth&#x27;</span>, map_location=<span class="keyword">lambda</span> storage, loc: storage.cuda(<span class="number">1</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 从 GPU 1 加载到 GPU 0</span></span><br><span class="line">torch.load(<span class="string">&#x27;best.pth&#x27;</span>, map_location=&#123;<span class="string">&#x27;cuda:1&#x27;</span>:<span class="string">&#x27;cuda:0&#x27;</span>&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过 io.BytesIO 对象加载</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;best.pth&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    buffer = io.BytesIO(f.read())</span><br></pre></td></tr></table></figure>

<h2 id="torch-nn-Module-load-state-dict-state-dict"><a href="#torch-nn-Module-load-state-dict-state-dict" class="headerlink" title="torch.nn.Module.load_state_dict(state_dict)"></a>torch.nn.Module.load_state_dict(state_dict)</h2><p>在 PyTorch 中，torch.nn.Module 模型的可学习参数（即权重和偏差）包含在模型的参数中（通过 model.parameters() 访问）。 state_dict 只是一个 Python 字典对象，它将每一层映射到其参数张量。请注意，只有具有可学习参数的层（卷积层、线性层等）和注册缓冲区（batchnorm 的 running_mean）在模型的 state_dict 中有条目。优化器对象 (torch.optim) 也有一个 state_dict，其中包含有关优化器状态的信息，以及使用的超参数。</p>
<p>由于 state_dict 对象是 Python 字典，因此它们可以轻松保存、更新、更改和恢复，从而为 PyTorch 模型和优化器添加了大量模块化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.Module.load_state_dict(state_dict, strict=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">state_dict - 保存 parameters 和 persistent buffers 的字典</span><br><span class="line">strict - 可选，bool型。state_dict 中的 key 是否和 model.state_dict() 返回的 key 一致。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModel</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        super(MyModel, self).__init__()</span><br><span class="line">        self.fully_conv = torch.nn.Sequential(</span><br><span class="line">            torch.nn.Conv2d(<span class="number">3</span>, <span class="number">96</span>, kernel_size=(<span class="number">11</span>, <span class="number">11</span>), stride=(<span class="number">2</span>, <span class="number">2</span>), bias=<span class="literal">True</span>),</span><br><span class="line">            torch.nn.BatchNorm2d(<span class="number">96</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">            torch.nn.Conv2d(</span><br><span class="line">                <span class="number">96</span>, <span class="number">256</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), groups=<span class="number">2</span>, bias=<span class="literal">True</span></span><br><span class="line">            ),</span><br><span class="line">            torch.nn.BatchNorm2d(<span class="number">256</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">1</span>),</span><br><span class="line">            torch.nn.Conv2d(</span><br><span class="line">                <span class="number">256</span>, <span class="number">384</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), groups=<span class="number">1</span>, bias=<span class="literal">True</span></span><br><span class="line">            ),</span><br><span class="line">            torch.nn.BatchNorm2d(<span class="number">384</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.Conv2d(</span><br><span class="line">                <span class="number">384</span>, <span class="number">384</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), groups=<span class="number">2</span>, bias=<span class="literal">True</span></span><br><span class="line">            ),</span><br><span class="line">            torch.nn.BatchNorm2d(<span class="number">384</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.Conv2d(</span><br><span class="line">                <span class="number">384</span>, <span class="number">32</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), groups=<span class="number">2</span>, bias=<span class="literal">True</span></span><br><span class="line">            ),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.fully_conv(x)</span><br><span class="line"><span class="comment"># 初始化模型   </span></span><br><span class="line">model = MyModel()</span><br><span class="line"><span class="comment"># 初始化优化器</span></span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line"><span class="comment"># 打印 model&#x27;s state_dict</span></span><br><span class="line"><span class="keyword">for</span> param_tensor <span class="keyword">in</span> model.state_dict():</span><br><span class="line">    print(param_tensor.ljust(<span class="number">36</span>, <span class="string">&quot;.&quot;</span>), model.state_dict()[param_tensor].size())</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fully_conv<span class="number">.0</span>.weight................. torch.Size([<span class="number">96</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">11</span>])</span><br><span class="line">fully_conv<span class="number">.0</span>.bias................... torch.Size([<span class="number">96</span>])</span><br><span class="line">fully_conv<span class="number">.1</span>.weight................. torch.Size([<span class="number">96</span>])</span><br><span class="line">fully_conv<span class="number">.1</span>.bias................... torch.Size([<span class="number">96</span>])</span><br><span class="line">fully_conv<span class="number">.1</span>.running_mean........... torch.Size([<span class="number">96</span>])</span><br><span class="line">fully_conv<span class="number">.1</span>.running_var............ torch.Size([<span class="number">96</span>])</span><br><span class="line">fully_conv<span class="number">.1</span>.num_batches_tracked.... torch.Size([])</span><br><span class="line">fully_conv<span class="number">.4</span>.weight................. torch.Size([<span class="number">256</span>, <span class="number">48</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">fully_conv<span class="number">.4</span>.bias................... torch.Size([<span class="number">256</span>])</span><br><span class="line">fully_conv<span class="number">.5</span>.weight................. torch.Size([<span class="number">256</span>])</span><br><span class="line">fully_conv<span class="number">.5</span>.bias................... torch.Size([<span class="number">256</span>])</span><br><span class="line">fully_conv<span class="number">.5</span>.running_mean........... torch.Size([<span class="number">256</span>])</span><br><span class="line">fully_conv<span class="number">.5</span>.running_var............ torch.Size([<span class="number">256</span>])</span><br><span class="line">fully_conv<span class="number">.5</span>.num_batches_tracked.... torch.Size([])</span><br><span class="line">fully_conv<span class="number">.8</span>.weight................. torch.Size([<span class="number">384</span>, <span class="number">256</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line">fully_conv<span class="number">.8</span>.bias................... torch.Size([<span class="number">384</span>])</span><br><span class="line">fully_conv<span class="number">.9</span>.weight................. torch.Size([<span class="number">384</span>])</span><br><span class="line">fully_conv<span class="number">.9</span>.bias................... torch.Size([<span class="number">384</span>])</span><br><span class="line">fully_conv<span class="number">.9</span>.running_mean........... torch.Size([<span class="number">384</span>])</span><br><span class="line">fully_conv<span class="number">.9</span>.running_var............ torch.Size([<span class="number">384</span>])</span><br><span class="line">fully_conv<span class="number">.9</span>.num_batches_tracked.... torch.Size([])</span><br><span class="line">fully_conv<span class="number">.11</span>.weight................ torch.Size([<span class="number">384</span>, <span class="number">192</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line">fully_conv<span class="number">.11</span>.bias.................. torch.Size([<span class="number">384</span>])</span><br><span class="line">fully_conv<span class="number">.12</span>.weight................ torch.Size([<span class="number">384</span>])</span><br><span class="line">fully_conv<span class="number">.12</span>.bias.................. torch.Size([<span class="number">384</span>])</span><br><span class="line">fully_conv<span class="number">.12</span>.running_mean.......... torch.Size([<span class="number">384</span>])</span><br><span class="line">fully_conv<span class="number">.12</span>.running_var........... torch.Size([<span class="number">384</span>])</span><br><span class="line">fully_conv<span class="number">.12</span>.num_batches_tracked... torch.Size([])</span><br><span class="line">fully_conv<span class="number">.14</span>.weight................ torch.Size([<span class="number">32</span>, <span class="number">192</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line">fully_conv<span class="number">.14</span>.bias.................. torch.Size([<span class="number">32</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印 optimizer&#x27;s state_dict</span></span><br><span class="line"><span class="keyword">for</span> var_name <span class="keyword">in</span> optimizer.state_dict():</span><br><span class="line">    print(var_name.ljust(<span class="number">15</span>, <span class="string">&quot;.&quot;</span>), optimizer.state_dict()[var_name])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">state.......... &#123;&#125;</span><br><span class="line">param_groups... [&#123;<span class="string">&#x27;lr&#x27;</span>: <span class="number">0.001</span>, <span class="string">&#x27;momentum&#x27;</span>: <span class="number">0.9</span>, <span class="string">&#x27;dampening&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;weight_decay&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;nesterov&#x27;</span>: <span class="literal">False</span>, <span class="string">&#x27;params&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>]&#125;]</span><br></pre></td></tr></table></figure>

<h1 id="保存和加载模型进行推断-推荐"><a href="#保存和加载模型进行推断-推荐" class="headerlink" title="保存和加载模型进行推断(推荐)"></a>保存和加载模型进行推断(<font size=6 color=orange>推荐</font>)</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存模型参数字典</span></span><br><span class="line">torch.save(model.state_dict(), PATH)</span><br><span class="line"><span class="comment"># 加载模型</span></span><br><span class="line">model = TheModelClass(*args, **kwargs)</span><br><span class="line">model.load_state_dict(torch.load(PATH))</span><br><span class="line">model.eval()</span><br></pre></td></tr></table></figure>

<p>PyTorch 的 1.6 版本将 torch.save 切换为使用新的基于 zipfile 的文件格式。 torch.load 仍然保留了以旧格式加载文件的能力。如果出于任何原因您希望 torch.save 使用旧格式，请传递 kwarg _use_new_zipfile_serialization=False。</p>
<p>保存模型进行推理时，只需保存训练模型的学习参数即可。使用 torch.save() 函数保存模型的 state_dict 将为您以后恢复模型提供最大的灵活性，这就是为什么它是保存模型的推荐方法。</p>
<p>一个常见的 PyTorch 约定是使用 .pt 或 .pth 文件扩展名保存模型。</p>
<p><font size=3 color=red>请记住，在运行推理之前，您必须调用 model.eval() 将 dropout 和批量归一化层设置为评估模式。不这样做会产生不一致的推理结果。</font></p>
<p>请注意， load_state_dict() 函数采用字典对象，而不是保存对象的路径。这意味着在将保存的 state_dict 传递给 load_state_dict() 函数之前，您必须对其进行反序列化。例如，您不能使用 model.load_state_dict(PATH) 加载。</p>
<p><font size=3 color=orange> 如果您只打算保留性能最佳的模型（根据获得的验证损失），请不要忘记 best_model_state = model.state_dict() 返回对状态的引用而不是其副本！您必须序列化 best_model_state 或使用 best_model_state = deepcopy(model.state_dict()) 否则您的最佳 best_model_state 将通过后续训练迭代不断更新。因此，最终的模型状态将是过拟合模型的状态。</font></p>
<h1 id="保存和加载整个模型"><a href="#保存和加载整个模型" class="headerlink" title="保存和加载整个模型"></a>保存和加载整个模型</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存模型</span></span><br><span class="line">torch.save(model, PATH)</span><br><span class="line"><span class="comment"># Model class must be defined somewhere</span></span><br><span class="line">model = torch.load(PATH)</span><br><span class="line">model.eval()</span><br></pre></td></tr></table></figure>

<p>这个保存/加载过程使用最直观的语法并且涉及最少的代码。以这种方式保存模型将使用 Python 的 pickle 模块保存整个模块。这种方法的缺点是序列化的数据绑定到特定的类和保存模型时使用的确切目录结构。这样做的原因是 pickle 不保存模型类本身。相反，它保存包含类的文件的路径，该路径在加载时使用。因此，您的代码在其他项目中使用或在重构后可能会以各种方式中断。</p>
<p><font size=3 color=red>请记住，在运行推理之前，您必须调用 model.eval() 将 dropout 和批量归一化层设置为评估模式。不这样做会产生不一致的推理结果。</font></p>
<h1 id="保存和加载用于推理和-或恢复训练的通用检查点-Checkpoint"><a href="#保存和加载用于推理和-或恢复训练的通用检查点-Checkpoint" class="headerlink" title="保存和加载用于推理和/或恢复训练的通用检查点(Checkpoint)"></a>保存和加载用于推理和/或恢复训练的通用检查点(Checkpoint)</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存</span></span><br><span class="line">torch.save(&#123;</span><br><span class="line">            <span class="string">&#x27;epoch&#x27;</span>: epoch,</span><br><span class="line">            <span class="string">&#x27;model_state_dict&#x27;</span>: model.state_dict(),</span><br><span class="line">            <span class="string">&#x27;optimizer_state_dict&#x27;</span>: optimizer.state_dict(),</span><br><span class="line">            <span class="string">&#x27;loss&#x27;</span>: loss,</span><br><span class="line">            ...</span><br><span class="line">            &#125;, PATH)</span><br><span class="line"><span class="comment"># 加载            </span></span><br><span class="line">model = TheModelClass(*args, **kwargs)</span><br><span class="line">optimizer = TheOptimizerClass(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">checkpoint = torch.load(PATH)</span><br><span class="line">model.load_state_dict(checkpoint[<span class="string">&#x27;model_state_dict&#x27;</span>])</span><br><span class="line">optimizer.load_state_dict(checkpoint[<span class="string">&#x27;optimizer_state_dict&#x27;</span>])</span><br><span class="line">epoch = checkpoint[<span class="string">&#x27;epoch&#x27;</span>]</span><br><span class="line">loss = checkpoint[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">model.eval()</span><br><span class="line"><span class="comment"># - or -</span></span><br><span class="line">model.train()  </span><br></pre></td></tr></table></figure>

<p>保存一般检查点以用于推理或恢复训练时，您必须保存的不仅仅是模型的 state_dict。保存优化器的 state_dict 也很重要，因为它包含在模型训练时更新的缓冲区和参数。您可能想要保存的其他项目是您离开的 epoch、最新记录的训练损失、外部 torch.nn.Embedding 层等。因此，这样的检查点通常比单独的模型大 2~3 倍.</p>
<p>要保存多个组件，请将它们组织在字典中并使用 torch.save() 序列化字典。一个常见的 PyTorch 约定是使用 .tar 文件扩展名保存这些检查点。</p>
<p>要加载项目，首先初始化模型和优化器，然后使用 torch.load() 在本地加载字典。从这里，您可以通过简单地按预期查询字典来轻松访问保存的项目。</p>
<p><font size=3 color=red>请记住，在运行推理之前，您必须调用 model.eval() 将 dropout 和批量归一化层设置为评估模式。不这样做会产生不一致的推理结果。如果您希望恢复训练，请调用 model.train() 以确保这些层处于训练模式。</font></p>
<h1 id="保存多个模型为一个文件"><a href="#保存多个模型为一个文件" class="headerlink" title="保存多个模型为一个文件"></a>保存多个模型为一个文件</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存</span></span><br><span class="line">torch.save(&#123;</span><br><span class="line">            <span class="string">&#x27;modelA_state_dict&#x27;</span>: modelA.state_dict(),</span><br><span class="line">            <span class="string">&#x27;modelB_state_dict&#x27;</span>: modelB.state_dict(),</span><br><span class="line">            <span class="string">&#x27;optimizerA_state_dict&#x27;</span>: optimizerA.state_dict(),</span><br><span class="line">            <span class="string">&#x27;optimizerB_state_dict&#x27;</span>: optimizerB.state_dict(),</span><br><span class="line">            ...</span><br><span class="line">            &#125;, PATH)</span><br><span class="line"><span class="comment"># 加载</span></span><br><span class="line">modelA = TheModelAClass(*args, **kwargs)</span><br><span class="line">modelB = TheModelBClass(*args, **kwargs)</span><br><span class="line">optimizerA = TheOptimizerAClass(*args, **kwargs)</span><br><span class="line">optimizerB = TheOptimizerBClass(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">checkpoint = torch.load(PATH)</span><br><span class="line">modelA.load_state_dict(checkpoint[<span class="string">&#x27;modelA_state_dict&#x27;</span>])</span><br><span class="line">modelB.load_state_dict(checkpoint[<span class="string">&#x27;modelB_state_dict&#x27;</span>])</span><br><span class="line">optimizerA.load_state_dict(checkpoint[<span class="string">&#x27;optimizerA_state_dict&#x27;</span>])</span><br><span class="line">optimizerB.load_state_dict(checkpoint[<span class="string">&#x27;optimizerB_state_dict&#x27;</span>])</span><br><span class="line"></span><br><span class="line">modelA.eval()</span><br><span class="line">modelB.eval()</span><br><span class="line"><span class="comment"># - or -</span></span><br><span class="line">modelA.train()</span><br><span class="line">modelB.train()</span><br></pre></td></tr></table></figure>

<p>保存由多个 torch.nn.Modules 组成的模型（例如 GAN、序列到序列模型或模型集合）时，您遵循与保存常规检查点时相同的方法。换句话说，保存每个模型的 state_dict 和相应优化器的字典。如前所述，您可以通过简单地将任何其他项目附加到字典中来保存可能有助于您恢复训练的任何其他项目。</p>
<p>一个常见的 PyTorch 约定是使用 .tar 文件扩展名保存这些检查点。</p>
<p>要加载模型，首先初始化模型和优化器，然后使用 torch.load() 在本地加载字典。从这里，您可以通过简单地按预期查询字典来轻松访问保存的项目。</p>
<p><font size=3 color=red>请记住，在运行推理之前，您必须调用 model.eval() 将 dropout 和批量归一化层设置为评估模式。不这样做会产生不一致的推理结果。如果您希望恢复训练，请调用 model.train() 将这些层设置为训练模式。</font></p>
<h1 id="使用来自不同模型的参数的热启动模型"><a href="#使用来自不同模型的参数的热启动模型" class="headerlink" title="使用来自不同模型的参数的热启动模型"></a>使用来自不同模型的参数的热启动模型</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存A模型的参数</span></span><br><span class="line">torch.save(modelA.state_dict(), PATH)</span><br><span class="line"><span class="comment"># 加班到B模型</span></span><br><span class="line">modelB = TheModelBClass(*args, **kwargs)</span><br><span class="line">modelB.load_state_dict(torch.load(PATH), strict=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>部分加载模型或加载部分模型是迁移学习或训练新的复杂模型时的常见场景。利用经过训练的参数，即使只有少数可用，也将有助于热启动训练过程，并有望帮助您的模型比从头开始训练更快地收敛。</p>
<p>无论您是从缺少一些键的部分 state_dict 加载，还是加载比您加载的模型更多键的 state_dict，您都可以在 load_state_dict() 函数中将严格参数设置为 False 以忽略不匹配键。</p>
<p>如果要将参数从一层加载到另一层，但某些键不匹配，只需更改要加载的 state_dict 中参数键的名称，以匹配要加载到的模型中的键。</p>
<h1 id="跨设备保存和加载模型"><a href="#跨设备保存和加载模型" class="headerlink" title="跨设备保存和加载模型"></a>跨设备保存和加载模型</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存模型</span></span><br><span class="line">torch.save(model.state_dict(), PATH)</span><br><span class="line"><span class="comment"># 加载模型到CPU</span></span><br><span class="line">device = torch.device(<span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line">model = TheModelClass(*args, **kwargs)</span><br><span class="line">model.load_state_dict(torch.load(PATH, map_location=device))</span><br></pre></td></tr></table></figure>

<p>在使用 GPU 训练的 CPU 上加载模型时，将 torch.device(‘cpu’) 传递给 torch.load() 函数中的 map_location 参数。在这种情况下，张量底层的存储使用 map_location 参数动态重新映射到 CPU 设备。</p>
<h1 id="Save-on-GPU-Load-on-GPU"><a href="#Save-on-GPU-Load-on-GPU" class="headerlink" title="Save on GPU, Load on GPU"></a>Save on GPU, Load on GPU</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存</span></span><br><span class="line">torch.save(model.state_dict(), PATH)</span><br><span class="line"><span class="comment"># 加载</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">model = TheModelClass(*args, **kwargs)</span><br><span class="line">model.load_state_dict(torch.load(PATH))</span><br><span class="line">model.to(device)</span><br><span class="line"><span class="comment"># Make sure to call input = input.to(device) on any input tensors that you feed to the model</span></span><br></pre></td></tr></table></figure>

<p>在 GPU 上加载经过训练并保存在 GPU 上的模型时，只需使用 model.to(torch.device(‘cuda’)) 将初始化模型转换为 CUDA 优化模型。此外，请务必在所有模型输入上使用 .to(torch.device(‘cuda’)) 函数来为模型准备数据。请注意，调用 my_tensor.to(device) 会在 GPU 上返回 my_tensor 的新副本。它不会覆盖 my_tensor。因此，请记住手动覆盖张量：my_tensor = my_tensor.to(torch.device(‘cuda’))。</p>
<h1 id="Save-on-CPU-Load-on-GPU"><a href="#Save-on-CPU-Load-on-GPU" class="headerlink" title="Save on CPU, Load on GPU"></a>Save on CPU, Load on GPU</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存</span></span><br><span class="line">torch.save(model.state_dict(), PATH)</span><br><span class="line"><span class="comment"># 加载</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">model = TheModelClass(*args, **kwargs)</span><br><span class="line">model.load_state_dict(torch.load(PATH, map_location=<span class="string">&quot;cuda:0&quot;</span>))  <span class="comment"># Choose whatever GPU device number you want</span></span><br><span class="line">model.to(device)</span><br><span class="line"><span class="comment"># Make sure to call input = input.to(device) on any input tensors that you feed to the model</span></span><br></pre></td></tr></table></figure>

<p>在 GPU 上加载经过训练并保存在 CPU 上的模型时，将 torch.load() 函数中的 map_location 参数设置为 cuda:device_id。这会将模型加载到给定的 GPU 设备。接下来，一定要调用 model.to(torch.device(‘cuda’)) 将模型的参数张量转换为 CUDA 张量。最后，确保在所有模型输入上使用 .to(torch.device(‘cuda’)) 函数来为 CUDA 优化模型准备数据。请注意，调用 my_tensor.to(device) 会在 GPU 上返回 my_tensor 的新副本。它不会覆盖 my_tensor。因此，请记住手动覆盖张量：my_tensor = my_tensor.to(torch.device(‘cuda’))。</p>
<h1 id="Saving-torch-nn-DataParallel-Models"><a href="#Saving-torch-nn-DataParallel-Models" class="headerlink" title="Saving torch.nn.DataParallel Models"></a>Saving <code>torch.nn.DataParallel</code> Models</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存</span></span><br><span class="line">torch.save(model.module.state_dict(), PATH)</span><br><span class="line"><span class="comment"># 加载</span></span><br><span class="line"><span class="comment"># Load to whatever device you want</span></span><br></pre></td></tr></table></figure>

<p>torch.nn.DataParallel 是一个支持并行 GPU 使用的模型包装器。要一般地保存 DataParallel 模型，请保存 model.module.state_dict()。这样，您就可以灵活地以任何方式将模型加载到您想要的任何设备上。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://pytorch.org/tutorials/beginner/saving_loading_models.html">SAVING AND LOADING MODELS</a></li>
<li><a href="https://blog.csdn.net/weixin_40522801/article/details/106563354">Pytorch：模型的保存与加载 torch.save()、torch.load()、torch.nn.Module.load_state_dict()</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/419940503">Pytorch中模型的保存与迁移</a></li>
</ol>
]]></content>
      <categories>
        <category>research</category>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>dl</tag>
        <tag>python</tag>
        <tag>ml</tag>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title>有理函数的不定积分</title>
    <url>/2020/04/18/rational-functions-indefinite-integrals/</url>
    <content><![CDATA[<h1 id="有理函数的不定积分"><a href="#有理函数的不定积分" class="headerlink" title="有理函数的不定积分"></a>有理函数的不定积分</h1><p>有理函数是指由两个多项式函数的商所表示的函数，其一般形式为</p>
<a id="more"></a>
<p>$$<br>R(x) = \frac{P(x)}{Q(x)} = \frac{\alpha_0 x^n + \alpha_1 x^{n-1} + \cdots + \alpha_n}{\beta_0 x^m + \beta_1 x^{m-1} + \cdots + \beta_m},<br>$$<br>其中$n,m$为非负整数，$\alpha_0, \alpha_1,\cdots, \alpha_n$与$\beta_0,\beta_1, \cdots, \beta_m$都是常数，且$\alpha_0 \neq 0, \beta_0 \neq 0$.若$m &gt; n$，则称它为真分式；若$m \leq n$，则称它为假分式。由多项式的除法可知，假分式总能化为一个多项式与一个真分式之和。多项式的不定积分容易求得，只需要关注真分式的不定积分。</p>
<p>根据代数知识，有理真分式必定可以表示成若干个部分分式之和（称为部分分式分解）。因而问题归结为求那些部分分式的不定积分。为此，先把如何分解部分分式的方法简述如下：</p>
<p>第一步    对分母$Q(x)$在实系数内作标准因式分解：<br>$$<br>Q(x) = (x - a_1)^{\lambda_1}\cdots(x - a_k)^{\lambda_k}(x^2 + p_1 x + q_1)^{\mu_1}\cdots(x^2 + p_l x + q_l)^{\mu_l},<br>$$<br>其中$\beta_0 = 1, \lambda_i, \mu_j(i = 1, 2, \cdots, k; j = 1, 2, \cdots, l)$均为自然数，而且<br>$$<br>\sum^k_{i=1}\lambda_i + 2\sum^l_{j=1}\mu_j = m; \\<br>p^2_j - 4q_j &lt; 0, j = 1, 2, \cdots, l.<br>$$<br>第二步    根据分母的各个因式分别写出与之相应的部分分式：对于每个形如$(x-a)^k$的因式，它所对应的部分分式是<br>$$<br>\frac{A_1}{x-a} + \frac{A_2}{(x-a)J^2} + \cdots + \frac{A_k}{(x-a)^k};<br>$$<br>对每个形如$(x^2 + px + q)^k$的因式，它所对应的部分分式是<br>$$<br>\frac{B_1 x + C_1}{x^2 + px + q} + \frac{B_2 x + C_2}{(x^2 + px + q)^2} + \cdots + \frac{B_k x + C_k}{(x^2 + px + q)^k}.<br>$$<br>把所有部分分式加起来，使之等于$R(x)$. 其中的$A_i, B_i, C_i$为待定的。</p>
<p>第三步    确定待定系数：一般方法是将所有部分分式同分相加，所得分式的分母即为原分母$Q(x)$，而其分子也应与原分子$P(x)$恒等。于是，按同幂项系数必定相等，得到一组关于待定系数的线性方程，这组方程的解就是需要确定的系数。</p>
<p><strong>例子</strong>    对$R(x) = \frac{2x^4 - x^3 + 4x^2 + 9x - 10}{x^5 + x^4 - 5x^3 - 2x^2 + 4x - 8}$作部分分式分解。</p>
<p>解    首先对分母$Q(x) = x^5 + x^4 - 5x^3 - 2x^2 + 4x - 8$作因式分解。因$Q(x)$首项系数为1，且常数项-8的整数因子有$\pm 1, \pm 2, \pm 4, \pm8$，分别带入这8个因子到$Q(x)$发现$\pm 2$为其整数根。</p>
<p>其次利用综合除法对$Q(x)$按照整数根进行因式分解。</p>
<table>
<thead>
<tr>
<th>整因子</th>
<th>最高次项系数</th>
<th>次高次项系数</th>
<th>更低一次项系数</th>
<th>更低一次项系数</th>
<th>更低一次项系数</th>
<th>更低一次项系数</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>1</td>
<td>1</td>
<td>-5</td>
<td>-2</td>
<td>4</td>
<td>-8</td>
</tr>
<tr>
<td></td>
<td></td>
<td>2（左下角值1乘2）</td>
<td>6（左下角值3乘2）</td>
<td>2（左下角值1乘2）</td>
<td>0（左下角值0乘2）</td>
<td>8（左下角值4乘2）</td>
</tr>
<tr>
<td>-2</td>
<td>1（从上上格值1拉下）</td>
<td>3（上上格1值加上格值2）</td>
<td>1（上上格-5值加上格值6）</td>
<td>0（上上格-2值加上格值2）</td>
<td>4（上上格4值加上格值0）</td>
<td>0（上上格-8值加上格值8，如果该值为0，说明$x-2$整除$Q(x)$）</td>
</tr>
<tr>
<td></td>
<td></td>
<td>-2</td>
<td>-2</td>
<td>2</td>
<td>-4</td>
<td></td>
</tr>
<tr>
<td></td>
<td>1</td>
<td>1</td>
<td>-1</td>
<td>2</td>
<td>0（说明$x-(-2) = x+2$整除$\frac{Q(x)}{x-2} = x^4 + 3x^3 + 1x^2 + 4$</td>
<td></td>
</tr>
</tbody></table>
<p>得到$Q(x) = (x-2)(x+2)(x^3 + x^2 - x + 2)$</p>
<p>对于$x^3 + x^2 - x + 2$可检验常数项4的整数分解因子$\pm 1, \pm 2$，发现只有$-2$是其整数根，即$x + 2$能够整除$x^3 + x^2 - x + 2$，利用如上表的综合除法，可以分解如下<br>$$<br>x^3 + x^2 - x + 2 = (x + 2)(x^2 - x + 1).<br>$$<br>因此，对$R(x)$的分母$Q(x)$可以因式分解为如下<br>$$<br>Q(x) = (x - 2)(x + 2)^2(x^2 - x + 1).<br>$$<br>然后，按照本节的有理函数因式分解方法，可写出部分分式分解的待定形式为<br>$$<br>R(x) = \frac{A_0}{x - 2} + \frac{A_1}{x + 2} + \frac{A_2}{(x + 2)^2} + \frac{Bx + C}{x^2 - x + 1}.<br>$$<br>通分后，比较分子与$2x^4 - x^3 + 4x^2 + 9x - 10$的各次项系数，可求得参数$A_0, A_1, A_2, B, C$.</p>
<p>最后，代入待定形式记得$R(x)$的部分分式分解<br>$$<br>R(x) = \frac{1}{x - 2} + \frac{2}{x + 2} - \frac{1}{(x + 2)^2} - \frac{x - 1}{x^2 - x + 1}.<br>$$<br>一旦完成了部分分式分解，最后归结为求如下两类有理真分式的不定积分：</p>
<p>(1)  $\int \frac{1}{(x - a)^k} \mathrm{d}x$;    (2) $\int \frac{Lx + M}{(x^2 + ps + q)^k} \mathrm{d}x( p^2 - 4q &lt; 0)$.</p>
<p>对于（1），<br>$$<br>\int \frac{1}{(x - a)^k} \mathrm{d}x =<br>\begin{cases}<br>\ln |x - a| + C, k = 1, \\<br>\frac{1}{(1 - k)(x - a)^{k - 1}} + C, k &gt; 1.<br>\end{cases}<br>$$<br>对于（2），只要作适当换元（令$t = x + \frac{p}{2}$），便化为<br>$$<br>\int \frac{Lx + M}{(x^2 + px + q)^k} \mathrm{d}x = \int \frac{Lt + N}{(t^2 + r^2)^k}\mathrm{d}t \\<br>= L\int\frac{t}{(t^2 + r^2)^k} \mathrm{d}t + N\int \frac{dt}{(t^2 + r^2)^k},<br>$$<br>其中$r^2 = q - \frac{p^2}{4}, N = M - \frac{p}{2}L.$</p>
<p>当$k = 1$时，上式右边两个不定积分分别为<br>$$<br>\int \frac{t}{t^2 + r^2}\mathrm{d}t = \frac{1}{2}\ln (t^2 + r^2) + C, \\<br>\int \frac{\mathrm{d}t}{t^2 + r^2} = \frac{1}{r} \arctan \frac{t}{r} + C.<br>$$<br>当$k \geq 2$时，上式右边第一个不定积分为<br>$$<br>\int \frac{t}{t^2 + r^2} \mathrm{d}t = \frac{1}{2(1 - k)(t^2 + r^2)^{k - 1}} + C.<br>$$<br>对于第二个不定积分，记<br>$$<br>I_k = \int \frac{\mathrm{d}t}{(t^2 + r^2)^k},<br>$$<br>可用分部积分法导出递推公式如下:<br>$$<br>I_k = \frac{1}{r^2} \int \frac{(t^2 + r^2) - t^2}{(t^2 + r^2)^k}\mathrm{d}t \\<br>\quad = \frac{1}{r^2}I_{k-1} - \frac{1}{r^2}\int \frac{t^2}{(t^2 + r^2)^k}\mathrm{d}t \\<br>\quad = \frac{1}{r^2}I_{k-1} + \frac{1}{2r^2(k-1)}\int t \mathrm{d}(\frac{1}{(t^2 + r^2)^{k-1}}) \\<br>\quad = \frac{1}{r^2}I_{k-1} + \frac{1}{2r^2(k-1)}[\frac{t}{(t^2 + r^2)^{k-1}} - I_{k-1}].<br>$$<br>经整理得到<br>$$<br>I_k = \frac{t}{2r^2(k-1)(t^2+r^2)^{k-1}} + \frac{2k-3}{2r^2}(k-1)I_{k-1}.<br>$$<br>重复使用上面的递推公式，最终归为计算$I_1$，$I_1$已经上面计算出。把所有这些局部结果代回，并令$t = x + \frac{p}{2}$就完成了对不定积分（2）的计算。</p>
<h1 id="三角函数有理式的不定积分"><a href="#三角函数有理式的不定积分" class="headerlink" title="三角函数有理式的不定积分"></a>三角函数有理式的不定积分</h1><p>由$u(x), v(x)$及常数经过有限次四则运算所得到的函数称为关于$u(x), v(x)$的有理式，并用$R(u(x), v(x))$表示。</p>
<p>$\int R(\sin x, \cos x) \mathrm{d}x$ 是三角函数有理式的不定积分。一般使用如下的万能公式，令$t = \tan \frac{x}{2}$,有<br>$$<br>\sin x = \frac{2\sin \frac{x}{2}\cos \frac{x}{2}}{\sin^2\frac{x}{2} + \cos^2 \frac{x}{2}} = \frac{2\tan \frac{x}{2}}{1 + \tan^2 \frac{x}{2}} = \frac{2t}{1 + t^2}, \\<br>\cos x = \frac{\cos^2 \frac{x}{2} - \sin^2\frac{x}{2}}{\sin^2\frac{x}{2} + \cos^2\frac{x}{2}} = \frac{1-\tan^2\frac{x}{2}}{1+\tan^2\frac{x}{2}} = \frac{1-t^2}{1+t^2}, \\<br>\tan x = \frac{\sin x}{\cos x} = \frac{2t}{1-t^2}.<br>$$<br>又<br>$$<br>\mathrm{d}x = \frac{2}{1 + t^2} \mathrm{d}t,<br>$$<br>所以，$\int R(\sin x, \cos x) \mathrm{d}x = \int R(\frac{2t}{1+t^2}, \frac{1-t^2}{1+t^2})\frac{2}{1+t^2} \mathrm{d}t$. 这就是上面的有理函数的不定积分。</p>
<p>虽然万能公式适用性比较广，但是在某些情况下却不是简便的方法。如在如下类型中<br>$$<br>\int \frac{a \sin^2 x + b\cos^2 x}{c \sin^2 x + d \cos^2 x} \mathrm{d}x,<br>$$<br>（分子分母同除以$\cos^2 x$后令$t = \tan x$）</p>
<p><strong>通常被积函数是$\sin^2 x, \cos^2 x, \sin x \cos x$的有理式时，采用变换$t = \tan x$往往简便</strong><br>$$<br>\int \frac{a \sin x + b \cos x}{c \sin x + d \cos x} \mathrm{d}x,<br>$$<br>（把分子形式的写为<br>$$<br>a \sin x + b \cos x = A(c \sin x + d \cos x) + B(c \sin x + d \cos x)^{\prime}<br>$$<br>然后，比较系数求出$A, B$，即可化为<br>$$<br>A\int \mathrm{d}x + B\int \frac{\mathrm{d}(c \sin x + d \cos x)}{c \sin x + d \cos x}.<br>$$</p>
<h1 id="某些无理根式的不定积分"><a href="#某些无理根式的不定积分" class="headerlink" title="某些无理根式的不定积分"></a>某些无理根式的不定积分</h1><h2 id="第一种无理根式"><a href="#第一种无理根式" class="headerlink" title="第一种无理根式"></a>第一种无理根式</h2><p>$\int R(x, \sqrt[n]{\frac{ax + b}{cx + d}}) \mathrm{d}x$ 型不定积分$(ad - bc \neq 0)$。对此只需令$t = \sqrt[n]{\frac{ax + b}{cx + d}}$, 就可化为有理函数的不定积分。</p>
<h2 id="第二种无理根式"><a href="#第二种无理根式" class="headerlink" title="第二种无理根式"></a>第二种无理根式</h2><p>$\int R(x, \sqrt{ax^2 + bx + c}) \mathrm{d}x$型不定积分（$a &gt; 0$时$b^2 - 4ac \neq 0,\ a &lt; 0$时$b^2 - 4ac &gt; 0$）。由于<br>$$<br>ax^2 + bx + c = a[(x + \frac{b}{2a})^2 + \frac{4ac - b^2}{4a^2}],<br>$$<br>若记$u = x + \frac{b}{2a}, k^2 = |\frac{4ac - b^2}{4a^2}|$，则此二次三项式必属于以下三种情形之一：<br>$$<br>|a|(u^2 + k^2), \quad |a|(u^2 - k^2), \quad |a|(k^2 - u^2).<br>$$<br>因此上述无理根式的不定积分也就转化为以下三种类型之一：<br>$$<br>\int R(u, \sqrt{u^2 \pm k^2}) \mathrm{d}u, \quad \int R(u, \sqrt{k^2 - u^2}) \mathrm{d}u.<br>$$<br>当分别令$u = k\tan t, u = k\sec t, u = k \sin t$后，它们都化为三角有理式的不定积分。</p>
<p><strong>一般地，二次三项式$ax^2 + bx + c$中若$a&gt;0$，则可令</strong><br>$$<br>\sqrt{ax^2 + bx + c} = \sqrt{a}x \pm t;<br>$$<br><strong>若$c&gt;0$，还可令</strong><br>$$<br>\sqrt{ax^2 + bx + c} = xt \pm \sqrt{c}.<br>$$<br>**这类变换称为<font color=#dd0000dd>欧拉变换</font>**。</p>
<p>至此，已经学了求不定积分的基本方法，以及某些特殊类型不定积分的求法。需要指出的是，通常所说的“求不定积分”是指<font color=dddddd00>用初等函数的形式把不定积分表示出来</font>。在这个意义下，并不是任何初等函数的不定积分都能“求出来”的，如<br>$$<br>\int e^{\pm x^2} \mathrm{d}x, \quad \int \frac{\mathrm{d}x}{\ln x}, \quad \int \frac{\sin x}{x}\mathrm{d}x, \quad \int \sqrt{1 - k^2 \sin^2 x} \mathrm{d}x \ (0 &lt; k^2 &lt; 1).<br>$$<br>等等，虽然它们都存在，但却无法用初等函数来表示。这一结论是有刘维尔（Liouville）于1835年作出过证明。因此，初等函数的原函数不一定是初等函数。但是，这些函数可以采用定积分形式来表示。</p>
<p>求不定积分除了使用手动推到的方法，也可以利用某些计算器（如TI-92型）和计算机软件（如Mathemetica, Maple, Python包Sympy）来作。例如使用Python的Sympy包求函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> *</span><br><span class="line">x = symbols(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">expr = sin(x) / x</span><br><span class="line">expr_int = Integral(expr, x)</span><br><span class="line">expr_int</span><br></pre></td></tr></table></figure>

<p>结果显示<br>$$<br>\int \frac{\sin(x)}{x} \mathrm{d}x<br>$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">expr_int.doit()</span><br></pre></td></tr></table></figure>

<p>结果显示<br>$$<br>Si(x)<br>$$<br>值得注意的是，虽然该函数有显示表达式，但却不属于初等函数范畴，其定义式如下<br>$$<br>Si(x) = \int^x_0 \frac{\sin(x)}{x} \mathrm{d}x.<br>$$</p>
<p>利用python还可以算出<br>$$<br>\int e^{-x^2} \mathrm{d}x = \frac{\sqrt{\pi}\cdot erf(x)}{2}, \\<br>\int e^{x^2} \mathrm{d}x = \frac{\sqrt{\pi}\cdot erfi(x)}{2}, \\<br>\int \frac{1}{\ln x} \mathrm{d}x = li(x), \\<br>\int \sqrt{1 - k^2 \sin^2 x} \mathrm{d}x = E(x|k^2).<br>$$<br>需要注意的是，$\int \sqrt{1 - k^2 \sin^2 x} \mathrm{d}x \ (0 &lt; k^2 &lt; 1)$, 计算花费的时间会长一些，其他都是及时返回结果。</p>
<h1 id="重要例子"><a href="#重要例子" class="headerlink" title="重要例子"></a>重要例子</h1><p>(1) $\int \frac{\mathrm{d}x}{1 + x^4}$</p>
<p>解    因为<br>$$<br>1 + x^4 = (1 + 2x^2 + x^4) - 2x^2 \\<br>\quad = (1 + x^2)^2 - (\sqrt{2}x)^2 \\<br>\quad = (1 + \sqrt{2}x + x^2)(1 - \sqrt{2}x + x^2).<br>$$<br>所以，原式子可以化为<br>$$<br>\int \frac{1}{1 + x^4} \mathrm{d}x = \int \frac{1}{(1 + \sqrt{2}x + x^2)(1 -\sqrt{2}x + x^2)} \mathrm{d}x<br>$$<br>然后，再利用有理函数的不定积分方法计算。</p>
<p>值得注意的，也可以利用如下方法求解。</p>
<p>解    注意到<br>$$<br>x^2 + \frac{1}{x^2} = (x + \frac{1}{x})^2 - 2 = (x - \frac{1}{x})^2 + 2.<br>$$<br>所以，<br>$$<br>\int \frac{1}{1 + x^4} \mathrm{d}x = \int \frac{\frac{1}{x^2}}{x^2 + \frac{1}{x^2}} \mathrm{d}x = \frac{1}{2}\int \frac{(1+\frac{1}{x^2}) - (1 - \frac{1}{x^2})}{x^2 + \frac{1}{x^2}} \mathrm{d}x \\<br>\quad = \frac{1}{2}[\int \frac{\mathrm{d}(x - \frac{1}{x})}{(x-\frac{1}{x})^2 + 2} - \int \frac{\mathrm{d}(x + \frac{1}{x})}{(x + \frac{1}{x})^2 - 2}] \\<br>\quad = \frac{1}{2}[\frac{1}{\sqrt{2}}\arctan\frac{x-\frac{1}{x}}{\sqrt{2}} - \frac{1}{2\sqrt{2}}\ln |\frac{x + \frac{1}{x} - \sqrt{2}}{x + \frac{1}{x} + \sqrt{2}}|] + C.<br>$$<br>（2）$\int \frac{\mathrm{d}x}{\sqrt{x^2 + x}}$</p>
<p>解<br>$$<br>\int \frac{\mathrm{d}x}{\sqrt{x^2 + x}} = \int \frac{\mathrm{d}x}{\sqrt{x}\sqrt{x + 1}} = 2\int\frac{\mathrm{d}\sqrt{x}}{\sqrt{(\sqrt{x})^2 + 1}} = 2 \ln |\sqrt{x} + \sqrt{x + 1}| + C.<br>$$<br>利用换元$\sqrt{x} = \tan t$.</p>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>integral</tag>
      </tags>
  </entry>
  <entry>
    <title>实数</title>
    <url>/2020/03/19/real-number/</url>
    <content><![CDATA[<p>实数包含有理数和无理数。有理数可以用分数形式$\frac{p}{q}, p, q$为整数，$q \neq 0$表示；也可以用有限十进制小数或无限十进制循环小数表示。无理数可以用不循环的小数表示。有理数和无理数统称为实数。</p>
<a id="more"></a>

<h1 id="实数"><a href="#实数" class="headerlink" title="实数"></a>实数</h1><p>为了统一，将有限小数（包括整数）也表示为无限小数。规定：对于正有限小数$x$, 当$x = a_0.a_1 a_2 \cdots a_n$时，其中$0 \leq a_i \leq 9, i = 1, 2, \cdots, n, a_n \neq 0, a_0$为非负整数，记<br>$$<br>x = a_0. a_1 a_2 \cdots (a_n - 1)9999 \cdots,<br>$$<br>而当$x = a_0$为正整数时，则记<br>$$<br>x = (a_0 - 1).9999 \cdots,<br>$$<br>对于负数，可以先转化为正数考虑，如$x$为负数，先将$-x$表示为无限循环小数，然后在添加负号。</p>
<p>对于0，规定表示为$0.0000 \cdots$，于是任意实数都可以用一个确定的无限小数表示。</p>
<p><strong>定义1</strong> 给定两个非负实数<br>$$<br>x = a_0.a_1 a_2 \cdots a_n \cdots,\quad y = b_0.b_1 b_2 \cdots b_n \cdots,<br>$$<br>其中$a_0, b_0$为非负整数，$a_k, b_k \ (k = 1, 2, \cdots)$为整数，$0 \leq a_k \leq 9, \ 0 \leq b_k \leq 9$. 若有<br>$$<br>a_k = b_k, \ k = 0, 1, 2, \cdots,<br>$$<br>则称$x$与$y$相等，记为$x = y$；若$a_0 &gt; b_0$或存在非负整数$l$，使得<br>$$<br>a_k = b_k \ (k = 0, 1, 2, \cdots, l) \ 但是 \ a_{i + 1} &gt; b_{i + 1}<br>$$<br>则称$x$大于$y$或$y$小于$x$，分别记为$x &gt; y$或$y &lt; x$.</p>
<p><strong>定义2</strong> 设$x = a_0.a_1 a_2 \cdots a_n \cdots$为非负实数。称有理数<br>$$<br>x_n = a_0.a_1 a_2 \cdots a_n<br>$$<br>为实数$x$的$n$位不足近似，而有理数<br>$$<br>\overline{x_n} = x_n + \frac{1}{10^n}<br>$$<br>称为$x$的$n$位过剩近似，$n = 0, 1, 2, \cdots$.</p>
<p>对于负实数$x = -a_0.a_1 a_2 \cdots a_n \cdots$,其$n$位不足近似和过剩近似分别规定为<br>$$<br>x_n = -a_0.a_1 a_2 \cdots a_n - \frac{1}{10^n} \ 与 \ \overline{x_n} = -a_0.a_1 a_2 \cdots a_n.<br>$$<br>注意，实数$x$的不足近似$x_n$是单调递增的，而过剩近似$\overline{x_n}$是单调递减的。</p>
<p>全体实数构成的集合一般用$\mathbb{R}$表示，实数具有如下一些主要性质：</p>
<ol>
<li>实数集对加、减、乘、除（除数不为0）四则运算是封闭的，即任意两个实数的和、差、积、商仍然是实数；</li>
<li>实数集是有序的，即任意两个实数$a, b$必满足下述三个关系之一：$a &lt; b, \ a = b, \ a &gt; b$;</li>
<li>实数的大小关系具有传递性，即若$a &gt; b, \ b &gt; c$，则$a &gt; c$;</li>
<li>实数具有阿基米德（Archimedes）性，即对任何$a, b \in \mathbb{R}$，若$b &gt; a &gt; 0$，则存在正整数$n$，使得$na &gt; b$；</li>
<li>实数集$\mathbb{R}$具有稠密性，即任何两个不相等的实数之间必有另一个实数，且既有有理数，也有无理数；</li>
<li>如果在一直线上确定一点$O$作为原点，指定一个正方向，规定一个单位长度，则此直线称为一个数轴。实数集和数轴上的点一一对应。</li>
</ol>
<h1 id="绝对值和不等式"><a href="#绝对值和不等式" class="headerlink" title="绝对值和不等式"></a>绝对值和不等式</h1><p>实数$x$的绝对值定义为<br>$$<br>|x| =<br>\begin{cases}<br>x, \ x \geq 0, \\<br>-x, \ x &lt; 0.<br>\end{cases}<br>$$<br>表示在数轴上点$x$到原点的距离。</p>
<p>实数的绝对值具有如下一些性质：</p>
<ol>
<li><p>$|x| = |-x| \geq 0$；当且仅当$x = 0$时有$|x| = 0$；</p>
</li>
<li><p>$- |x| \leq x \leq |x|$；</p>
</li>
<li><p>$|x| &lt; h \Leftrightarrow - h &lt; x &lt; h;\ |x| \leq h \Leftrightarrow -h \leq x \leq h \ (h &gt; 0)$；</p>
</li>
<li><p>对于任何$a, b \in \mathbb{R}$有如下的三角不等式：<br>$$<br>|x| - |y| \leq |x \pm y| \leq |x| + |y|;<br>$$</p>
</li>
<li><p>$|xy| = |x| |y|$；</p>
</li>
<li><p>$|\frac{x}{y}| = \frac{|x|}{|y|} \ y \neq 0$；</p>
</li>
</ol>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><ol>
<li>设$a, b \in \mathbb{R}$，若对任何正数$\varepsilon$有$|a - b| &lt; \varepsilon$，则$a = b$.</li>
<li>设$x &gt; 0, b &gt;0, a \neq b$, 则$\frac{a + x}{b + x}$介于$1$与$\frac{a}{b}$之间。</li>
</ol>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>real number</tag>
      </tags>
  </entry>
  <entry>
    <title>如何退出 scala 命令行窗口</title>
    <url>/2019/12/20/quit-scala-shell/</url>
    <content><![CDATA[<p><img src="https://cdn.datafloq.com/cache/blog_pictures/878x531/apache-flink.jpg" alt="undefined"></p>
<p>当运行 flink scala shell 时，想要退出本地命令行端口，可以使用如下的命令：</p>
<a id="more"></a>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">:q</span><br><span class="line">:quit</span><br><span class="line">sys.exit</span><br></pre></td></tr></table></figure>

<p>也可以使用快捷键：</p>
<ul>
<li>在 Linux 系统下<br>Ctrl + d</li>
<li>在 Windows 系统下<br>Ctrl + z</li>
</ul>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>flink</tag>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch 中的 nn 和 nn.functional</title>
    <url>/2021/06/21/pytorch-nn-vs-functional/</url>
    <content><![CDATA[<p>PyTorch 中有两个模块 torch.nn 和 torch.nn.functional 都可以用来构造深度学习神经网络模型，实现相同的功能，然而它们之间有着重要的差别。</p>
<a id="more"></a>

<p>大体上来说，torch.nn 更抽象，是对 torch.nn.functional 更高一层的实现，有点 keras vs. tensorflow（1.x） 的感觉。torch.nn 中的，如 ReLU、Conv2d等，是类，而 torch.nn.functional 中的，如 relu、conv2d 等，是函数。</p>
<h1 id="torch-nn"><a href="#torch-nn" class="headerlink" title="torch.nn"></a>torch.nn</h1><p>torch.nn 里面的类是 torch.nn.functional 中函数的封装，两者都继承于 torch.nn.Module，因此 torch.nn 除了具有 torch.nn.functional 的功能外，还附带了 torch.nn.Module 相关的属性和方法，如 train(), eval(), load_state_dict, state_dict 等。</p>
<p><font size=3 color=red> torch.nn 需要先实例化，然后对实例化对象传入数据：</font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">inputs = torch.rand(<span class="number">64</span>, <span class="number">3</span>, <span class="number">217</span>, <span class="number">217</span>)</span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">conv = torch.nn.Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">64</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 实例化对象处理数据</span></span><br><span class="line">out = conv(inputs)</span><br></pre></td></tr></table></figure>

<p><font size=3 color=red>torch.nn 可以与 torch.nn.Sequential 结合</font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">neural_network = torch.nn.Sequential(</span><br><span class="line">    torch.nn.Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">64</span>, padding=<span class="number">1</span>),</span><br><span class="line">    torch.nn.BatchNorm2d(num_features=<span class="number">64</span>),</span><br><span class="line">    torch.nn.ReLU(),</span><br><span class="line">    torch.nn.MaxPool2d(kernel_size=<span class="number">2</span>),</span><br><span class="line">    torch.nn.Dropout(<span class="number">0.5</span>),</span><br><span class="line">    torch.nn.Linear(in_features=<span class="number">32</span>, out_features=<span class="number">10</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h1 id="torch-nn-functional"><a href="#torch-nn-functional" class="headerlink" title="torch.nn.functional"></a>torch.nn.functional</h1><p>torch.nn.functional 中定义的是函数接口，其同样继承自 torch.nn.Module.</p>
<p><font size=3 color=red>torch.nn.functional 需要传入数据和参数（如 weights, bias）</font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">weights = torch.rand(<span class="number">64</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">bias = torch.rand(<span class="number">64</span>)</span><br><span class="line">inputs = torch.rand(<span class="number">64</span>, <span class="number">3</span>, <span class="number">217</span>, <span class="number">217</span>)</span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">out = torch.nn.functional.conv2d(input=inputs, weight=weights, bias=bias, padding=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><font size=3 color=red>torch.nn 中的类是通过 torch.nn.functional 定义的</font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReLU</span>(<span class="params">Module</span>):</span></span><br><span class="line">    <span class="string">r&quot;&quot;&quot;Applies the rectified linear unit function element-wise:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :math:`\text&#123;ReLU&#125;(x) = (x)^+ = \max(0, x)`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        inplace: can optionally do the operation in-place. Default: ``False``</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Shape:</span></span><br><span class="line"><span class="string">        - Input: :math:`(N, *)` where `*` means, any number of additional</span></span><br><span class="line"><span class="string">          dimensions</span></span><br><span class="line"><span class="string">        - Output: :math:`(N, *)`, same shape as the input</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. image:: ../scripts/activation_images/ReLU.png</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Examples::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; m = nn.ReLU()</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; input = torch.randn(2)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; output = m(input)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      An implementation of CReLU - https://arxiv.org/abs/1603.05201</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; m = nn.ReLU()</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; input = torch.randn(2).unsqueeze(0)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; output = torch.cat((m(input),m(-input)))</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    __constants__ = [<span class="string">&#x27;inplace&#x27;</span>]</span><br><span class="line">    inplace: bool</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, inplace: bool = False</span>):</span></span><br><span class="line">        super(ReLU, self).__init__()</span><br><span class="line">        self.inplace = inplace</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, input: Tensor</span>) -&gt; Tensor:</span></span><br><span class="line">        <span class="keyword">return</span> F.relu(input, inplace=self.inplace)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extra_repr</span>(<span class="params">self</span>) -&gt; str:</span></span><br><span class="line">        inplace_str = <span class="string">&#x27;inplace=True&#x27;</span> <span class="keyword">if</span> self.inplace <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> inplace_str</span><br></pre></td></tr></table></figure>

<p>注意：<font size=3 color=cyan>in-place</font> operation 在 pytorch 中是指改变一个 tensor 的值的时候，不经过复制操作，而是直接在原来的内存上改变它的值。可以把它称为原地操作符。</p>
<p>在 pytorch 中经常加后缀 <code>_</code> 来代表原地 in-place operation，比如说 .add_() 或者.scatter_(). 我们可以将 in_place 操作简单的理解类似于python 中的 +=, -= 等操作。</p>
<p>对于 requires_grad=True 的 叶子张量 (leaf tensor) 不能使用 inplace operation; 对于在 求梯度阶段需要用到的张量 不能使用 inplace operation.</p>
<p><font size=3 color=cyan>torch 中设置随机数种子，保证结果复现：</font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_seed</span>(<span class="params">seed</span>):</span></span><br><span class="line">    torch.manual_seed(seed)</span><br><span class="line">    torch.cuda.manual_seed_all(seed)</span><br><span class="line">    np.random.seed(seed)</span><br><span class="line">    random.seed(seed)</span><br><span class="line">    torch.backends.cudnn.deterministic = <span class="literal">True</span></span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>具有学习参数的 （如 Conv2d, BatchNorm2d, Linear）采用 torch.nn 的方式，没有学习参数的（如 MaxPool2d, loss func, activation func）等根据个人选择使用 torch.nn.functional 或者 torch.nn 的方式。</p>
</li>
<li><p>当模型较复杂时，推荐 torch.nn，当其不能满足功能需求时，torch.nn.functional 是最佳选择，如自定义模块时。因为其更接近底层，更加灵活。</p>
</li>
<li><p>在前馈网络计算（forward）时，torch.nn.functional 中的参数无法保存，即没有状态参数。状态参数一般指的是可学习的参数，如卷积层的 weights 和 bias，或根据需要自定义的一些可学习参数。torch.nn.functional 中涉及的参数一般是超参，无法利用反向传播进行学习。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># 保存最好的模型参数</span></span><br><span class="line">torch.save(model,<span class="string">&#x27;best.pth&#x27;</span>)</span><br><span class="line"><span class="comment"># 再次训练时</span></span><br><span class="line">model.load_state_dict(torch.load(<span class="string">&quot;best.pt&quot;</span>))  <span class="comment"># model.load_state_dict()函数把加载的权重复制到模型的权重中去</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><font size=3 color=cyan>关于 dropout，推荐使用 torch.nn 的方式</font>，因为一般情况下只有训练阶段才进行 dropout，在 eval 阶段都不会进行 dropout， 使用 torch.nn 方式定义 dropout，在调用 model.eval() 之后，model 中所有的 dropout layer 都关闭，但以 torch.nn.function.dropout 的方式定义 dropout，在调用 model.eval() 之后并不能关闭 dropout. </li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://blog.csdn.net/u011501388/article/details/86602275">PyTorch之nn.ReLU与F.ReLU的区别</a></li>
<li><a href="https://www.joeltok.com/blog/pytorch-convert-f-relu-to-nn-relu">Converting F.relu() to nn.ReLU() in PyTorch</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1734426">PyTorch之nn.ReLU与F.ReLU的区别介绍</a></li>
<li><a href="https://www.zhihu.com/question/66782101/answer/579393790">PyTorch 中，nn 与 nn.functional 有什么区别？</a></li>
</ol>
]]></content>
      <categories>
        <category>research</category>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>dl</tag>
        <tag>python</tag>
        <tag>ml</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 安装教程</title>
    <url>/2020/06/19/redis-install-tutorial/</url>
    <content><![CDATA[<p>Redis 是一款内存型高性能的key-value的No-SQL数据库，性能高，比较受欢迎。下面介绍一下再Ubuntu 18.04系统上编译安装 redis  稳定版本（次版本）的方法，并配置如何开机自启以及查看运行情况命令。</p>
<a id="more"></a>

<h2 id="下载redis"><a href="#下载redis" class="headerlink" title="下载redis"></a>下载redis</h2><p>redis的最新稳定版本6.0.5可以从其<a href="https://redis.io/download">官网下载</a>，这里根据公司需求，要下载次稳定版本，就是下载6.0.4，下面介绍如何下载。在下载官网页面下，找到 How to verify files for integrity，点击GitHub repository 的 <a href="https://github.com/antirez/redis-hashes/blob/master/README">redis-hashes</a> ，最下面的倒数第二行就是次稳定版本的链接：<a href="http://download.redis.io/releases/redis-6.0.4.tar.gz">http://download.redis.io/releases/redis-6.0.4.tar.gz</a></p>
<p>使用命令下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-6.0.4.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h2><p>如下安装就是参考官网方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xzf redis-6.0.4.tar.gz</span><br><span class="line">cd redis-6.0.4</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>此时，就已经编译好redis，可以使用了。使用方法如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启redis服务</span></span><br><span class="line">src/redis-server</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用redis客户端连接</span></span><br><span class="line">src/redis-cli</span><br></pre></td></tr></table></figure>

<p>但是，如上方法对于本机使用还可以，如果想远程链接、其他目录启动与连接、设置密码、开机自启等都无法实现。这些都需要对redis配置文件进行修改。下面介绍一下。</p>
<h2 id="配置redis"><a href="#配置redis" class="headerlink" title="配置redis"></a>配置redis</h2><h3 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h3><p>修改redis配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 找到下面配置，并注释掉</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">bind</span> 127.0.0.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置保护模式为no</span></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置监控模式为systemd，注意该设置与下面的开机自启对应，不设置启动不起来</span></span><br><span class="line">supervised systemd</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置数据库保存位置</span></span><br><span class="line"> dir /var/redis</span><br><span class="line"> </span><br><span class="line"><span class="meta"> #</span><span class="bash"> 设置自己的密码，这里设置为redis</span></span><br><span class="line"> requirepass redis</span><br></pre></td></tr></table></figure>

<p>创建数据库目录，并赋给读写权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo adduser --system --group --no-create-home redis</span><br><span class="line">sudo mkdir -p /var/redis</span><br><span class="line">sudo chown redis:redis /var/redis</span><br><span class="line">sudo chmod 770 /var/redis</span><br></pre></td></tr></table></figure>

<p>在另一台Ubuntu18.04上安装redis客户端工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install redis-tools</span><br></pre></td></tr></table></figure>

<p>通过redis客户端远程连接redis数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 1.14.1.14 -p 6379 -a redis</span><br></pre></td></tr></table></figure>

<p>如果忘记输入密码，可以在redis命令行里再次输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 1.14.1.14 -p 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入redis后，再输入密码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h 1.14.1.14 -p 6379</span></span><br><span class="line">1.14.1.14:6379&gt; keys *</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">1.14.1.14:6379&gt; AUTH redis</span><br><span class="line">OK</span><br><span class="line">1.14.1.14:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line">1.14.1.14:6379&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /lib/systemd/system/redis.service</span><br></pre></td></tr></table></figure>

<p>我这里是把redis文件夹放在了/home/jinzhongxu/Documents目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Redis In-Memory Data Store</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=redis</span><br><span class="line">Group=redis</span><br><span class="line">ExecStart=/home/jinzhongxu/Documents/redis-6.0.4/src/redis-server /home/jinzhongxu/Documents/redis    -6.0.4/redis.conf</span><br><span class="line">ExecStop=/home/jinzhongxu/Documents/redis-6.0.4/src/redis-cli shutdown</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看状态</span></span><br><span class="line">sudo systemctl status redis.service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭服务</span></span><br><span class="line">sudo systemctl stop redis.service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启服务</span></span><br><span class="line">sudo systemctl start redis.service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开机自启</span></span><br><span class="line">sudo systemctl enable redis.service</span><br></pre></td></tr></table></figure>

<h3 id="查看运行状态"><a href="#查看运行状态" class="headerlink" title="查看运行状态"></a>查看运行状态</h3><p>除了上面的查看状态方法，还可以通过如下方法进行查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看redis进程</span></span><br><span class="line">ps -ef | grep redis</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者以树状图方式查看</span></span><br><span class="line">pstree -ph | grep redis</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检测监听端口</span></span><br><span class="line">netstat -nlt | grep 6379</span><br></pre></td></tr></table></figure>

<h3 id="Ubuntu14-04-安装redis"><a href="#Ubuntu14-04-安装redis" class="headerlink" title="Ubuntu14.04 安装redis"></a>Ubuntu14.04 安装redis</h3><p>在Ubuntu14.04.5上安装redis的大概步骤如下，在gcc版本满足编译redis版本的情况下，使用如下即可。如果gcc版本低，而ubuntu14.04.5可以联网，可以联网升级gcc，然后再编译安装redis</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-6.0.4.tar.gz</span><br><span class="line">tar xzf redis-6.0.4.tar.gz</span><br><span class="line">cd redis-6.0.4</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">cd utils</span><br><span class="line">sudo ./install_server.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认该步骤会自动设置用户、开机启动等</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看状态并启动</span></span><br><span class="line">service redis-server status</span><br><span class="line">service redis-server stop</span><br><span class="line">service redis-server start</span><br></pre></td></tr></table></figure>

<p>但是，在不能联网的Ubuntu14.04.5上安装redis-6.0.4最大的问题就是gcc版本太低问题，默认版本是4.8.4，但是，需要5.3以上，那么就必须安装一个高版本的gcc，然后是用高版本的gcc编译安装redis</p>
<h3 id="下载gcc"><a href="#下载gcc" class="headerlink" title="下载gcc"></a>下载gcc</h3><p>在网址<a href="http://www.linuxfromscratch.org/blfs/view/8.0/general/gcc.html">Introduction to GCC</a>，下载<a href="http://ftpmirror.gnu.org/gcc/gcc-6.3.0/gcc-6.3.0.tar.bz2">GCC-6.3.0</a> ，然后拷贝到ubuntu14.04.5上。</p>
<h3 id="安装gcc-6-3-0"><a href="#安装gcc-6-3-0" class="headerlink" title="安装gcc 6.3.0"></a>安装gcc 6.3.0</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xjf gcc-6.3.0.tar.bz2</span><br><span class="line">cd gcc</span><br><span class="line"><span class="meta">#</span><span class="bash"> configure gcc时可能会报错，需要安装如下三个包</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> apt install libgmp-dev libmpfr-dev libmpc-dev</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果只需要配置64位的，可以使用如下方法</span></span><br><span class="line">./configure --disable-multilib</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h3 id="安装redis-6-0-4"><a href="#安装redis-6-0-4" class="headerlink" title="安装redis-6.0.4"></a>安装redis-6.0.4</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xzf redis-6.0.4.tar.gz</span><br><span class="line">cd redis-6.0.4</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以使用 gcc --version查看刚刚安装好的gcc目录，我这边安装在/usr/<span class="built_in">local</span>/bin/gcc</span></span><br><span class="line">make CC=/usr/local/bin/gcc</span><br><span class="line">make install</span><br><span class="line">cd utils</span><br><span class="line">sudo ./install_server.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service redis-6370 status</span><br><span class="line">sudo service redis-6370 stop</span><br><span class="line">sudo service redis-6370 start</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 批处理：修改文件名和文件内容</title>
    <url>/2021/02/09/rename-and-sed/</url>
    <content><![CDATA[<p>在 Linux 系统上，包含有大量相同字段的文件名，想要把这些字段（中文字段）改成其他字段（数字或其他英文字段），因为某些程序的需要，不支持中文文件名，此时可以使用命令 rename 批量修改文件名。当文件中包含有大量相同字段，想要修改，但是，收到修改又比较浪费时间。此时，可以使用命令 sed 完成。</p>
<a id="more"></a>

<h1 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h1><p>在 linux 系统中重命名文件，经常用到 mv命令，批量重命名文件 rename 是最好的选择。</p>
<p>linux的 rename命令有两个版本，一个是c语言版本的，一个是perl语言版本的，判断方法：输入man rename </p>
<h2 id="C语言版本"><a href="#C语言版本" class="headerlink" title="C语言版本"></a>C语言版本</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">rename 原字符串 新字符串 文件名</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rename 第三阶段 3 *</span><br><span class="line"><span class="comment"># * 代表所有字符</span></span><br><span class="line"><span class="comment"># ？代表单个字符</span></span><br></pre></td></tr></table></figure>

<h2 id="Perl语言版本"><a href="#Perl语言版本" class="headerlink" title="Perl语言版本"></a>Perl语言版本</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">rename &#x27;s/原字符串/新字符串/&#x27; 文件名</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rename <span class="string">&#x27;s/第三阶段/3/&#x27;</span> *</span><br><span class="line">rename <span class="string">&quot;s/$/.txt/&quot;</span> * //把所有的文件名都以txt结尾</span><br></pre></td></tr></table></figure>

<h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p>linux下批量替换文件内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 针对单个文件</span></span><br><span class="line">sed -i <span class="string">&quot;s/查找字段/替换字段/g&quot;</span> 文件名</span><br><span class="line"><span class="comment"># 针对目录下的所有文件</span></span><br><span class="line">sed -i <span class="string">&quot;s/查找字段/替换字段/g&quot;</span> `grep 查找字段 -rl 路径`</span><br><span class="line"><span class="comment"># r 表示递归</span></span><br><span class="line"><span class="comment"># l 表示 -files-with-matches</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&quot;s/www.baidu.com/baidu.com/g&quot;</span> file.config</span><br><span class="line">sed -i <span class="string">&quot;s/www.baidu.com/baidu.com/g&quot;</span> `grep www.baidu.com -rl /home`</span><br></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><p><a href="https://blog.51cto.com/jiemian/1846951">linux下rename命令用法详解(重命名文件)</a></p>
</li>
<li><p><a href="https://wangchujiang.com/linux-command/c/rename.html">rename</a></p>
</li>
<li><p><a href="http://einverne.github.io/post/2018/01/rename-files-batch.html">每天学习一个命令: rename 批量修改文件名</a></p>
</li>
<li><p><a href="https://blog.csdn.net/hnlyyk/article/details/49299909">linux下批量替换文件内容</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>rename</tag>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 关机和重启命令</title>
    <url>/2020/03/27/restart-and-shutdown/</url>
    <content><![CDATA[<p>重新启动Linux系统和关闭Linux系统推荐使用shutdown命令。</p>
<p>下面分别介绍重新Linxu系统的命令：shutdown, reboot, init等命令，以及关机命令：shutdown, halt, init, poweroff</p>
<a id="more"></a>

<h1 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h1><p>该命令需要root权限，且功能比较强大，像reboot，halt等都是基于该命令。</p>
<p>shutdown命令比较安全，使用该命令后，它会在系统关闭之前给系统上的所有登录用户一条警告。同时该命令搭配不同的参数，可以设置不同的重启操作。</p>
<p>该命令的一般格式：<font size=3 color=red> shutdown [选项] [时间] [警告信息] </font></p>
<p>选项的含义:</p>
<ul>
<li>k: 并不真正关机而只是发出警告信息给所有用户</li>
<li>r: 关机后立即重新启动</li>
<li>h: 关机后不重新启动</li>
<li>f: 快速关机重启动时跳过fsck</li>
<li>n: 快速关机不经过init 程序</li>
<li>c: 取消一个已经运行的shutdown</li>
</ul>
<h1 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h1><p>reboot 命令比较粗暴，重启系统时直接删除所有进程，不是平稳安全的关闭它们。但简单粗暴的它可以快速关闭系统。容易造成其他用户的数据丢失。所以建议在单用户模式下才使用reboot命令，在多用户模式下使用shutdown命令。</p>
<h1 id="init"><a href="#init" class="headerlink" title="init"></a>init</h1><p>init命令主要用于切换系统的运行级别，切换是立即完成的。</p>
<p>init 0：表示将运行级别切换为0，表示关机；</p>
<p>init 6：表示将运行级别切换为6，表示重启。</p>
<h1 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h1><p>该命令类似于reboot，是相对简单的关机命令。但实质上是调用了shutdown -h，但它有如下一些恐怖的参数</p>
<ul>
<li>f: 没有调用shutdown而强制关机或重启</li>
<li>i: 关机或重新启动之前，关掉所有的网络接口</li>
<li>p: 关机时调用poweroff，此选项为缺省选项</li>
</ul>
<h1 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h1><p><strong>poweroff命令</strong>用来关闭计算机操作系统并且切断系统电源。它有如下参数</p>
<ul>
<li>n：关闭操作系统时不执行sync操作；</li>
<li>w：不真正关闭操作系统，仅在日志文件“/var/log/wtmp”中；</li>
<li>d：关闭操作系统时，不将操作写入日志文件“/var/log/wtmp”中添加相应的记录；</li>
<li>f：强制关闭操作系统；</li>
<li>i：关闭操作系统之前关闭所有的网络接口；</li>
<li>h：关闭操作系统之前将系统中所有的硬件设置为备用模式。</li>
</ul>
<h1 id="如何重启"><a href="#如何重启" class="headerlink" title="如何重启"></a>如何重启</h1><p>下面总结一些常用的重启命令:</p>
<p>立即安全的重启（推荐的命令），可以考虑参数r与reboot对应</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure>

<p>10分钟后重启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shutdown -r +10</span><br></pre></td></tr></table></figure>

<p>立刻重启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reboot</span><br><span class="line">init 6</span><br></pre></td></tr></table></figure>

<h1 id="常用关机命令"><a href="#常用关机命令" class="headerlink" title="常用关机命令"></a>常用关机命令</h1><p>下面总结一些常用的关机命令：</p>
<p>立即安全的关机（推荐的命令），可以考虑参数h与halt对应</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo shutdown -h now</span><br></pre></td></tr></table></figure>

<p>10分钟后关机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo shutdown -h +10</span><br></pre></td></tr></table></figure>

<p>晚上18：30关机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo shutdown -h 18:30</span><br></pre></td></tr></table></figure>

<p>在未来某天某时关机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;shutdown -h +5&quot;</span> | at 10:05am 2022-01-19</span><br></pre></td></tr></table></figure>

<p>关机时广播指定信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo shutdown -h +20 <span class="string">&quot;System Upgrade&quot;</span></span><br></pre></td></tr></table></figure>

<p>立刻关机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">halt</span><br><span class="line">init 0</span><br><span class="line">poweroff</span><br><span class="line">sudo shutdown -h +0</span><br></pre></td></tr></table></figure>

<p>取消定时关机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo shutdown -c <span class="string">&quot;Canceling System Upgrade&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://phoenixnap.com/kb/linux-shutdown-command">How to use Linux Shutdown Command with Examples</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>shutdown</tag>
        <tag>reboot</tag>
      </tags>
  </entry>
  <entry>
    <title>在服务器上搭建个人网盘</title>
    <url>/2019/12/21/server-pan/</url>
    <content><![CDATA[<p>本篇通过 <a href="https://filebrowser.xyz/installation">filebrowser</a> 在服务器上搭建个人网盘.</p>
<p>首先，在终端运行一下代码：</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://filebrowser.xyz/get.sh | bash</span><br></pre></td></tr></table></figure>

<p>进行网盘系统安装。</p>
<p>其次，进入你需要建立网盘的目录，运行 filebrowser 命令</p>
<p>或者直接运行 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">filebrowser -`r` /path/to/your/files</span><br></pre></td></tr></table></figure>



<p>这时，网盘运行中服务器127.0.0.1:8080端口。</p>
<p>最后，本地远程连接服务器，并映射服务器端口到本地端口8008，命令如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -L8008:localhost:8080 root@xxx.xxx.xxx.xxx</span><br></pre></td></tr></table></figure>

<p>这样就可以在本地浏览器输入localhost:8008打开个人网盘，记得修改密码。</p>
<p>注意点：平常想要本地打开网盘，可以直接在本地终端一行命令完成，如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -L8008:localhost:8080 root@xxx.xxx.xxx.xxx <span class="string">&#x27;filebrowser&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>pan</tag>
      </tags>
  </entry>
  <entry>
    <title>如何求解方程$\sin(x)=2$</title>
    <url>/2019/12/21/sinx/</url>
    <content><![CDATA[<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

<p>如何求解方程<br>$$<br>\sin(x)=2<br>$$<br>该方程有多少个解?</p>
]]></content>
      <categories>
        <category>maths</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>sin</tag>
      </tags>
  </entry>
  <entry>
    <title>解决SSH连接CentOS速度慢的问题</title>
    <url>/2021/01/29/ssh-centos-speed-up/</url>
    <content><![CDATA[<p>使用 SSH 登录 CentOS 时，总是比登录 Ubuntu 等系统慢。解决方法就是如下设置。本文以 CentOS 7 为例。</p>
<a id="more"></a>

<h1 id="修改-SSH-配置"><a href="#修改-SSH-配置" class="headerlink" title="修改 SSH 配置"></a>修改 SSH 配置</h1><ol>
<li><p>登录系统</p>
</li>
<li><p>打开 SSH 配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 UseDNS 为如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">UseDNS no</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 GSSAPIAuthentication 为如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GSSAPIAuthentication no</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 SSHD 服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service sshd restart</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://blog.csdn.net/qq_30264689/article/details/89314555">centos ssh连接登录慢解决</a></li>
<li><a href="https://blog.csdn.net/leeyisong/article/details/81558478">centos7解决ssh登录速度慢的问题</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SSH连接GitHub</title>
    <url>/2020/01/08/ssh-git/</url>
    <content><![CDATA[<p>在本地开发代码时，需要push本地代码到GitHub仓库时，总是需要输入用户名和秘密，这导致了开发的效率降低，也不安全。那有一种方式可以快速高效且安全的连接到GitHub仓库，并提交代码，那就是使用SSH连接GitHub仓库，下面给出如何从手动输入秘密切换到使用SSH连接GitHub仓库。</p>
<a id="more"></a>

<h1 id="添加SSH公钥到GitHub账号下"><a href="#添加SSH公钥到GitHub账号下" class="headerlink" title="添加SSH公钥到GitHub账号下"></a>添加SSH公钥到GitHub账号下</h1><p>假设使用的是Ubuntu系统，将用户下的公钥拷贝粘贴到GitHub账号下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>拷贝所有内容到GitHub主页—右上角Settings—左侧SSH and GPG keys—SSH keys—New SSH key—随便写个名字在title栏，并粘贴刚刚拷贝的内容到key栏中—Add SSH key</p>
<h1 id="测试能否正确通过SSH连接GitHub"><a href="#测试能否正确通过SSH连接GitHub" class="headerlink" title="测试能否正确通过SSH连接GitHub"></a>测试能否正确通过SSH连接GitHub</h1><p>在终端中输入一下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>如果出现 Hi your-user-name! You’ve successfully authenticated, but GitHub does not provide shell access. 证明正确通过SSH连接GitHub</p>
<h1 id="添加本地仓库"><a href="#添加本地仓库" class="headerlink" title="添加本地仓库"></a>添加本地仓库</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line"></span><br><span class="line">git remote add origin git@github.com:user-name/your-repo-name.git</span><br></pre></td></tr></table></figure>

<h1 id="push-本地代码到仓库"><a href="#push-本地代码到仓库" class="headerlink" title="push 本地代码到仓库"></a>push 本地代码到仓库</h1><p>正确完成以上步骤后，第一次push本地代码，需要使用如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --<span class="built_in">set</span>-upstream origin master</span><br></pre></td></tr></table></figure>

<p>以后，就可以直接使用如下命令进行提交代码到远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh 出现 Could not resolve hostname flink Name or service not known 的解决方案</title>
    <url>/2019/12/20/ssh-flink-hostname-not-known/</url>
    <content><![CDATA[<p>当使用 ssh 远程连接服务器出现 Could not resolve hostname slave.flink: Name or service not known 时，一种测试通过的解决方案如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure>
<p>添加如下代码，就是使本地计算机能够解析该主机名</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.66.88 flink</span><br></pre></td></tr></table></figure>
<p>这样就可以进行 ssh 连接。</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>big data</tag>
        <tag>ssh</tag>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习中的标准化和归一化方法</title>
    <url>/2020/05/08/standardization-normalization/</url>
    <content><![CDATA[<p>在机器学习实践中，经常会遇到对数据进行标准化、归一化等，那它与数学中的标准化、归一化、单位化有什么区别呢，python 包中如何实现这些标准化、归一化（或叫正则化）、单位化计算呢，还有哪些类似的计算方法呢，对于已知的数据集我该采用哪种标准化或归一化或单位化方法呢？这些问题一直是每一个机器学习从业者或学生们在实际工作中遇到的问题，而且网络上很多都介绍的不是很清晰，这里进行一个总结，以飨读者。</p>
<a id="more"></a>

<h1 id="标准化、归一化、单位化的区别"><a href="#标准化、归一化、单位化的区别" class="headerlink" title="标准化、归一化、单位化的区别"></a>标准化、归一化、单位化的区别</h1><h2 id="标准化-Standardization"><a href="#标准化-Standardization" class="headerlink" title="标准化 (Standardization)"></a>标准化 (Standardization)</h2><p>首先看到标准化使我想起在概率论中对随机变量 $\xi$ 的标准化<br>$$<br>z = \frac{\xi - \mu}{\sigma}.<br>$$<br>这里，$\mu$ 是随机变量 $\xi$ 的均值，$\sigma$ 是标准差。它也叫做 $z$-score，多翻译为标准分数（standard score）。 经过变换后，随机变量 $z$ 就是标准差为 1 的随机变量，因此，也可以叫做标准差归一化。需要注意的是，因为标准差的计算公式是使 $\xi - \mu$ 和 $\sigma$ 具有相同的量纲，所以， $z$ 是一个没有量纲的随机变量，并且，可以证明随机变量 $\xi$ 和 $z$ 具有相同类型的分布。不过，通过 $z$-score 可以看出该值在分布中的相对位置，它指示了一个元素距离均值有几个标准偏差远。$z$-score 可正可负，也可以大于 1 或者小于 -1，不过所有 $z$-score均值为 0. </p>
<p>NYU Stern Finance Professor Edward Altman 在1967年发明了 $z$-score ， 并在1968 年发布。在正态分布中，68% 的 $z$-score 落在 [-1, 1] 中，95% 的 $z$-score 落在 [-2, 2] 中，99% 的 $z$-score 落在 [-3, 3] 中。</p>
<h2 id="正则化或归一化-Normalization"><a href="#正则化或归一化-Normalization" class="headerlink" title="正则化或归一化 (Normalization)"></a>正则化或归一化 (Normalization)</h2><p>归一化，单从字面意思可以理解为将数据缩放或映射到区间 [0, 1] 内。其实，现在已经对其进行了推广，可以不仅仅限制的正数范围内，可以映射到区间 [-1, 1] 中。在机器学习中，常用的归一化方法有两种，公式表示分别是<br>$$<br>y_{\min-\max} = \frac{x - \min(x)}{\max(x) - \min(x)},<br>$$<br>$$<br>y_{\text{mean}} = \frac{x - \text{mean}(x)}{\max(x) - \min(x)}.<br>$$</p>
<p>分别称为 $\min - \max$ 归一化和 $\text{mean}$ 归一化。可以看出，经过这两种归一化后同样能够消除量纲对计算的影响。前者归一化后的结果都是正数，后者可正可负。可以根据需要进行选择。前者的  $\min - \max$ 归一化也可以看作是最大值归一化或者最小值归零化。后者的 $\text{mean}$ 归一化其实是均值归零化，但是映射后所有的量的绝对值都限制在 0-1之间。</p>
<h2 id="单位化-Unitization"><a href="#单位化-Unitization" class="headerlink" title="单位化 (Unitization)"></a>单位化 (Unitization)</h2><p>这个概念在机器学习中虽然不常出现，但是，它的含义已经在机器学习中显露。最早接触单位化是在数学中向量的单位化，即将一个向量不改变其方向只对其长度进行缩放到单位长度 1. 在机器学习中，如果把某一个特征的所有观测组成一个向量，再进行单位化，那么类似于前面的归一化方法，将会把所有值映射为 $[-1, 1]$ 中。数学上单位化的公式如下<br>$$<br>\vec{e} = \frac{\vec{x}}{\parallel \vec{x} \parallel _2}.<br>$$</p>
<p>这里，计算的是二范数 $l_2$，在机器学习中，也有定义为其他函数的，如 $l_1$, $l_{\infty}$等。</p>
<h2 id="三者的本质"><a href="#三者的本质" class="headerlink" title="三者的本质"></a>三者的本质</h2><p>从数学上看，它们的计算公式可以用通用形式表示如下<br>$$<br>y = f(x) = \frac{x - A}{B}.<br>$$<br>就是将变量 $x$ 先进行平移 $A$ 个单位，然后再缩放到原来的 $\frac{1}{B}$. 在机器学习或概率论中为了计算和分析的方便，一般选择 $B$ 和变量具有相同量纲，这样可以消去量纲对后面计算的影响，$A$ 的选择将会影响映射后变量取值的正负等。</p>
<h1 id="Python-中标准化、归一化的实现"><a href="#Python-中标准化、归一化的实现" class="headerlink" title="Python 中标准化、归一化的实现"></a>Python 中标准化、归一化的实现</h1><h2 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h2><p>标准化方法在 Python 中有包 scikit-learn 的 preprocessing 模块，实现函数是 Scale 和 StandardScaler.</p>
<p>使用这种缩放的动机包括使得缩放后的值保留原数据集的分布信息。</p>
<h3 id="scale-z-score"><a href="#scale-z-score" class="headerlink" title="scale  ($z$-score)"></a>scale  ($z$-score)</h3><p>函数 scale 提供了一种快速简单的方法来对单个类似数组的数据集执行标准化操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> scale</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">X_train = np.array([[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>], </span><br><span class="line">                    [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>], </span><br><span class="line">                    [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])</span><br><span class="line">X_scaled = scale(X_train)</span><br><span class="line">X_scaled</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">array([[ <span class="number">0.</span>        , <span class="number">-1.22474487</span>,  <span class="number">1.33630621</span>],</span><br><span class="line">       [ <span class="number">1.22474487</span>,  <span class="number">0.</span>        , <span class="number">-0.26726124</span>],</span><br><span class="line">       [<span class="number">-1.22474487</span>,  <span class="number">1.22474487</span>, <span class="number">-1.06904497</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="StandardScaler-z-score"><a href="#StandardScaler-z-score" class="headerlink" title="StandardScaler ($z$-score)"></a>StandardScaler ($z$-score)</h3><p>程序类 StandardScaler 实现了 Transformer API，以计算训练集上的均值和标准差，以便以后能够在测试集上重新应用相同的变换。因此，此类适合在 sklearn.pipeline.Pipeline 的早期步骤中使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">data = [[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">scaler.fit(data)  <span class="comment"># 先使用 data 训练，即计算均值和标准差</span></span><br><span class="line">scaler.transform([[<span class="number">0.5</span>, <span class="number">0.5</span>]])  <span class="comment"># 使用上面计算的均值和标准差计算 z-scores</span></span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>

<p>也可以直接计算 data 的 $z$-score</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scaler.fit_transform(data)</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">-1.</span>, <span class="number">-1.</span>],</span><br><span class="line">       [<span class="number">-1.</span>, <span class="number">-1.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="RobustScaler-and-robust-scale-approx-z-score"><a href="#RobustScaler-and-robust-scale-approx-z-score" class="headerlink" title="RobustScaler and robust_scale (approx $z$-score)"></a>RobustScaler and robust_scale (approx $z$-score)</h3><p>标准化计算容易受到异常值的影响，因此 Python 包 scikit-learn 包的模块 preprocessing 中提供了函数 RobustScaler 和它的便携计算 roubust_scale. 在 RobustScaler 中的 <strong>quantile_range</strong> 中默认 <strong>(q_min, q_max) = （25.0, 75.0）</strong> ，即 (1st quantile, 3rd quantile) = IQR Quantile ，使用 1 分位数 和 3 分位数里的数值计算均值和方差用于变化其他数据。</p>
<p>更多具体的参数请参考官网介绍</p>
<ul>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.scale.html">sklearn.preprocessing.scale</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html">sklearn.preprocessing.StandardScaler</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.RobustScaler.html#sklearn.preprocessing.RobustScaler">sklearn.preprocessing.RobustScaler</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.robust_scale.html#sklearn.preprocessing.robust_scale">sklearn.preprocessing.robust_scale</a></li>
</ul>
<h2 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h2><p>归一化方法在 Python 中有包 scikit-learn 中的 preprocessing 模块，实现函数是 MinMaxScaler 和 minmax_scale.</p>
<p>使用这种缩放的动机包括对特征的非常小的标准偏差具有鲁棒性增强稳定性，并在稀疏数据中保留 0 值。</p>
<h3 id="minmax-scale-min-max-归一化"><a href="#minmax-scale-min-max-归一化" class="headerlink" title="minmax_scale (min - max 归一化)"></a>minmax_scale (min - max 归一化)</h3><p>函数 minmax_scale 提供了一种快速简单的方法来对单个类似数组的数据集执行 min-max 归一化操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> minmax_scale</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">X_train = np.array([[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>], </span><br><span class="line">                    [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>], </span><br><span class="line">                    [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])</span><br><span class="line">X_scaled = scale(X_train)</span><br><span class="line">X_scaled</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">0.5</span>       , <span class="number">0.</span>        , <span class="number">1.</span>        ],</span><br><span class="line">       [<span class="number">1.</span>        , <span class="number">0.5</span>       , <span class="number">0.33333333</span>],</span><br><span class="line">       [<span class="number">0.</span>        , <span class="number">1.</span>        , <span class="number">0.</span>        ]])</span><br></pre></td></tr></table></figure>

<h3 id="MinMaxScaler-min-max-归一化"><a href="#MinMaxScaler-min-max-归一化" class="headerlink" title="MinMaxScaler  (min - max 归一化)"></a>MinMaxScaler  (min - max 归一化)</h3><p>默认 MinMaxScaler 将数据映射到 $[0, 1]$ 中，也可以修改参数 scaler = MinMaxScaler(feature_range=(-5, 5)) 将 data 映射到自己需要的区间，如这里的 $[-5, 5]$. 内部计算公式如下</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">X_std = (X - X.min(axis=<span class="number">0</span>)) / (X.max(axis=<span class="number">0</span>) - X.min(axis=<span class="number">0</span>))  # min, max 为 data 的最值</span><br><span class="line">X_scaled = X_std * (max - min) + min  # min, max 为 feature_range 中设置的区间端点</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line">data = [[<span class="number">-1</span>, <span class="number">2</span>], [<span class="number">-0.5</span>, <span class="number">6</span>], [<span class="number">0</span>, <span class="number">10</span>], [<span class="number">1</span>, <span class="number">18</span>]]</span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line">scaler.fit(data)</span><br><span class="line">scaler.transform([[<span class="number">0</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">array([[ <span class="number">0.5</span>  , <span class="number">-0.125</span>]])</span><br></pre></td></tr></table></figure>

<p>也可以直接计算 data 的 min - max 归一化值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scaler.fit_transform(data)</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">0.</span>  , <span class="number">0.</span>  ],</span><br><span class="line">       [<span class="number">0.25</span>, <span class="number">0.25</span>],</span><br><span class="line">       [<span class="number">0.5</span> , <span class="number">0.5</span> ],</span><br><span class="line">       [<span class="number">1.</span>  , <span class="number">1.</span>  ]])</span><br></pre></td></tr></table></figure>

<p>更多具体的参数请参考官网介绍</p>
<ul>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html#sklearn.preprocessing.MinMaxScaler">sklearn.preprocessing.MinMaxScaler</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.minmax_scale.html#sklearn.preprocessing.minmax_scale">sklearn.preprocessing.minmax_scale</a></li>
</ul>
<h2 id="单位化-vector-unitization"><a href="#单位化-vector-unitization" class="headerlink" title="单位化 (vector unitization)"></a>单位化 (vector unitization)</h2><p>单位化方法在 Python 中有包 scikit-learn 中的 preprocessing 模块，实现函数是 MaxAbsScaler 和 maxabs_scale （ 注意这里的分母是 $l_{\infty}$ ），以及 Normalizer 和 normalize (分母可以自己指定)。</p>
<p>类似于 min - max 归一化的 MinMaxScaler ，使用这种缩放的动机包括对特征的非常小的标准偏差具有鲁棒性增强稳定性，并在稀疏数据中保留 0 值。</p>
<h3 id="maxabs-scale-vector-unitization"><a href="#maxabs-scale-vector-unitization" class="headerlink" title="maxabs_scale (vector unitization)"></a>maxabs_scale (vector unitization)</h3><p>函数 maxabs_scale 提供了一种快速简单的方法来对单个类似数组的数据集执行单位化操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> maxabs_scale</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">X_train = np.array([[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>], </span><br><span class="line">                    [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>], </span><br><span class="line">                    [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])</span><br><span class="line">X_scaled = maxabs_scale(X_train)</span><br><span class="line">X_scaled</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">array([[ <span class="number">0.5</span>, <span class="number">-1.</span> ,  <span class="number">1.</span> ],</span><br><span class="line">       [ <span class="number">1.</span> ,  <span class="number">0.</span> ,  <span class="number">0.</span> ],</span><br><span class="line">       [ <span class="number">0.</span> ,  <span class="number">1.</span> , <span class="number">-0.5</span>]])</span><br></pre></td></tr></table></figure>



<h3 id="MaxAbsScaler-vector-unitization"><a href="#MaxAbsScaler-vector-unitization" class="headerlink" title="MaxAbsScaler (vector unitization)"></a>MaxAbsScaler (vector unitization)</h3><p>MaxAbsScaler 将数据缩放到区间 $[-1, 1]$，并且消除了量纲的影响为以后数据的进一步处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MaxAbsScaler</span><br><span class="line">X = [[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>], </span><br><span class="line">     [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>], </span><br><span class="line">     [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]]</span><br><span class="line">scaler = MaxAbsScaler()</span><br><span class="line">scaler.fit(X)</span><br><span class="line">scaler.transform([[<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0.5</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">0.</span>  , <span class="number">0.5</span> , <span class="number">0.25</span>]])</span><br></pre></td></tr></table></figure>

<p>也可以直接计算 X 的 单位化， 按照每列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scaler.fit_transform(X)</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">array([[ <span class="number">0.5</span>, <span class="number">-1.</span> ,  <span class="number">1.</span> ],</span><br><span class="line">       [ <span class="number">1.</span> ,  <span class="number">0.</span> ,  <span class="number">0.</span> ],</span><br><span class="line">       [ <span class="number">0.</span> ,  <span class="number">1.</span> , <span class="number">-0.5</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="normalize"><a href="#normalize" class="headerlink" title="normalize"></a>normalize</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> normalize</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">X_train = np.array([[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>], </span><br><span class="line">                    [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>], </span><br><span class="line">                    [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])</span><br><span class="line">X_scaled = normalize(X_train, norm=<span class="string">&#x27;l2&#x27;</span>)</span><br><span class="line">X_scaled</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">array([[ <span class="number">0.40824829</span>, <span class="number">-0.40824829</span>,  <span class="number">0.81649658</span>],</span><br><span class="line">       [ <span class="number">1.</span>        ,  <span class="number">0.</span>        ,  <span class="number">0.</span>        ],</span><br><span class="line">       [ <span class="number">0.</span>        ,  <span class="number">0.70710678</span>, <span class="number">-0.70710678</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="Normalizer"><a href="#Normalizer" class="headerlink" title="Normalizer"></a>Normalizer</h3><p>可以自己指定范数 <strong>‘l1’, ‘l2’, or ‘max’, optional (‘l2’ by default)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Normalizer</span><br><span class="line">X = [[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>], </span><br><span class="line">     [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>], </span><br><span class="line">     [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]]</span><br><span class="line">scaler = Normalizer(norm=<span class="string">&#x27;l2&#x27;</span>)</span><br><span class="line">scaler.fit(X)</span><br><span class="line">scaler.transform([[<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0.5</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">0.</span>        , <span class="number">0.70710678</span>, <span class="number">0.70710678</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scaler.fit_transform(X)</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">array([[ <span class="number">0.40824829</span>, <span class="number">-0.40824829</span>,  <span class="number">0.81649658</span>],</span><br><span class="line">       [ <span class="number">1.</span>        ,  <span class="number">0.</span>        ,  <span class="number">0.</span>        ],</span><br><span class="line">       [ <span class="number">0.</span>        ,  <span class="number">0.70710678</span>, <span class="number">-0.70710678</span>]])</span><br></pre></td></tr></table></figure>

<p>更多具体的参数请参考官网介绍</p>
<ul>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MaxAbsScaler.html#sklearn.preprocessing.MaxAbsScaler">sklearn.preprocessing.MaxAbsScaler</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.maxabs_scale.html#sklearn.preprocessing.maxabs_scale">sklearn.preprocessing.maxabs_scale</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.Normalizer.html#sklearn.preprocessing.Normalizer">sklearn.preprocessing.Normalizer</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.normalize.html#sklearn.preprocessing.normalize">sklearn.preprocessing.normalize</a></li>
</ul>
<h1 id="Python-中-scikit-learn-包提供的其他数据变换或预处理方法"><a href="#Python-中-scikit-learn-包提供的其他数据变换或预处理方法" class="headerlink" title="Python 中 scikit-learn 包提供的其他数据变换或预处理方法"></a>Python 中 scikit-learn 包提供的其他数据变换或预处理方法</h1><h2 id="编码类别特征"><a href="#编码类别特征" class="headerlink" title="编码类别特征"></a>编码类别特征</h2><h3 id="OrdinalEncoder-categorical-to-integer"><a href="#OrdinalEncoder-categorical-to-integer" class="headerlink" title="OrdinalEncoder (categorical to integer)"></a>OrdinalEncoder (categorical to integer)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OrdinalEncoder</span><br><span class="line">enc = OrdinalEncoder()</span><br><span class="line">X = [[<span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;from US&#x27;</span>, <span class="string">&#x27;uses Safari&#x27;</span>], [<span class="string">&#x27;female&#x27;</span>, <span class="string">&#x27;from Europe&#x27;</span>, <span class="string">&#x27;uses Firefox&#x27;</span>]]</span><br><span class="line">enc.fit(X)</span><br><span class="line">enc.transform([[<span class="string">&#x27;female&#x27;</span>, <span class="string">&#x27;from US&#x27;</span>, <span class="string">&#x27;uses Safari&#x27;</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="OneHotEncoder-categorical-to-vector"><a href="#OneHotEncoder-categorical-to-vector" class="headerlink" title="OneHotEncoder (categorical to vector)"></a>OneHotEncoder (categorical to vector)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line">enc = OneHotEncoder()</span><br><span class="line">X = [[<span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;from US&#x27;</span>, <span class="string">&#x27;uses Safari&#x27;</span>], [<span class="string">&#x27;female&#x27;</span>, <span class="string">&#x27;from Europe&#x27;</span>, <span class="string">&#x27;uses Firefox&#x27;</span>]]</span><br><span class="line">enc.fit(X)</span><br><span class="line">enc.transform([[<span class="string">&#x27;female&#x27;</span>, <span class="string">&#x27;from US&#x27;</span>, <span class="string">&#x27;uses Safari&#x27;</span>],  [<span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;from Europe&#x27;</span>, <span class="string">&#x27;uses Safari&#x27;</span>]]).toarray()</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Encoding categorical features : OneHotEncoder : 自己指定类别</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line">genders = [<span class="string">&#x27;female&#x27;</span>, <span class="string">&#x27;male&#x27;</span>]</span><br><span class="line">locations = [<span class="string">&#x27;from Africa&#x27;</span>, <span class="string">&#x27;from Asia&#x27;</span>, <span class="string">&#x27;from Europe&#x27;</span>, <span class="string">&#x27;from US&#x27;</span>]</span><br><span class="line">browsers = [<span class="string">&#x27;uses Chrome&#x27;</span>, <span class="string">&#x27;uses Firefox&#x27;</span>, <span class="string">&#x27;uses IE&#x27;</span>, <span class="string">&#x27;uses Safari&#x27;</span>]</span><br><span class="line">enc = OneHotEncoder(categories=[genders, locations, browsers])</span><br><span class="line">X = [[<span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;from US&#x27;</span>, <span class="string">&#x27;uses Safari&#x27;</span>], [<span class="string">&#x27;female&#x27;</span>, <span class="string">&#x27;from Europe&#x27;</span>, <span class="string">&#x27;uses Firefox&#x27;</span>]]</span><br><span class="line">enc.fit(X)</span><br><span class="line">enc.transform([[<span class="string">&#x27;female&#x27;</span>, <span class="string">&#x27;from Asia&#x27;</span>, <span class="string">&#x27;uses Chrome&#x27;</span>]]).toarray()</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Encoding categorical features : OneHotEncoder : 忽略未知类别</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line">env = OneHotEncoder(handle_unknown=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">X = [[<span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;from US&#x27;</span>, <span class="string">&#x27;uses Safari&#x27;</span>], [<span class="string">&#x27;female&#x27;</span>, <span class="string">&#x27;from Europe&#x27;</span>, <span class="string">&#x27;uses Firefox&#x27;</span>]]</span><br><span class="line">enc.fit(X)</span><br><span class="line">enc.transform([[<span class="string">&#x27;female&#x27;</span>, <span class="string">&#x27;from Asia&#x27;</span>, <span class="string">&#x27;uses Chrome&#x27;</span>]]).toarray()</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Encoding categorical features : OneHotEncoder : 忽略未知类别</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line">env = OneHotEncoder(drop=<span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">X = [[<span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;from US&#x27;</span>, <span class="string">&#x27;uses Safari&#x27;</span>], [<span class="string">&#x27;female&#x27;</span>, <span class="string">&#x27;from Europe&#x27;</span>, <span class="string">&#x27;uses Firefox&#x27;</span>]]</span><br><span class="line">env.fit(X)</span><br><span class="line">env.transform(X).toarray()</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>

<h2 id="映射到某种分布上"><a href="#映射到某种分布上" class="headerlink" title="映射到某种分布上"></a>映射到某种分布上</h2><h3 id="Mapping-to-a-Uniform-distribution-QuantileTransformer-or-quantile-transform"><a href="#Mapping-to-a-Uniform-distribution-QuantileTransformer-or-quantile-transform" class="headerlink" title="Mapping to a Uniform distribution (QuantileTransformer or quantile_transform)"></a>Mapping to a Uniform distribution (QuantileTransformer or quantile_transform)</h3><h3 id="Mapping-to-a-Gaussian-distribution-PowerTransformer"><a href="#Mapping-to-a-Gaussian-distribution-PowerTransformer" class="headerlink" title="Mapping to a Gaussian distribution (PowerTransformer)"></a>Mapping to a Gaussian distribution (PowerTransformer)</h3><h2 id="连续数据到离散数据"><a href="#连续数据到离散数据" class="headerlink" title="连续数据到离散数据"></a>连续数据到离散数据</h2><h3 id="KBinDiscretizer-continuous-to-bin"><a href="#KBinDiscretizer-continuous-to-bin" class="headerlink" title="KBinDiscretizer (continuous to bin)"></a>KBinDiscretizer (continuous to bin)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Discretization :  K-bins discretization</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> KBinsDiscretizer</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">est = KBinsDiscretizer(n_bins=[<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>], encode=<span class="string">&#x27;ordinal&#x27;</span>)</span><br><span class="line">X =  np.array([[ <span class="number">-3.</span>, <span class="number">5.</span>, <span class="number">15</span> ], [  <span class="number">0.</span>, <span class="number">6.</span>, <span class="number">14</span> ], [  <span class="number">6.</span>, <span class="number">3.</span>, <span class="number">11</span> ]])</span><br><span class="line">est.fit(X)</span><br><span class="line">est.transform(X)</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">2.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="Binarizer-continuous-to-boolean"><a href="#Binarizer-continuous-to-boolean" class="headerlink" title="Binarizer (continuous to boolean)"></a>Binarizer (continuous to boolean)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Discretization : Binarizer</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Binarizer</span><br><span class="line">X = [[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>], [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>], [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]]</span><br><span class="line">binarizer = Binarizer(threshold=<span class="number">1.1</span>)</span><br><span class="line">binarizer.transform(X)</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="PolynomialFeatures-add-features"><a href="#PolynomialFeatures-add-features" class="headerlink" title="PolynomialFeatures (add features)"></a>PolynomialFeatures (add features)</h3><h2 id="自定义变换"><a href="#自定义变换" class="headerlink" title="自定义变换"></a>自定义变换</h2><h3 id="log1p"><a href="#log1p" class="headerlink" title="log1p"></a>log1p</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Custom transformer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> FunctionTransformer</span><br><span class="line">transformer = FunctionTransformer(np.log1p, validate=<span class="literal">True</span>)</span><br><span class="line">X = np.array([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line">transformer.transform(X)</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">0.</span>        , <span class="number">0.69314718</span>],</span><br><span class="line">       [<span class="number">1.09861229</span>, <span class="number">1.38629436</span>]])</span><br></pre></td></tr></table></figure>

<p>更多请参考：</p>
<ol>
<li>Python 中 scikit-learn 提供的 标准化，归一化和单位化方法介绍 <a href="https://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-scaler">Preprocessing data</a></li>
<li>Python 中各中数据预处理缩放方法对比图 <a href="https://scikit-learn.org/stable/auto_examples/preprocessing/plot_all_scaling.html#sphx-glr-auto-examples-preprocessing-plot-all-scaling-py">Compare the effect of different scalers on data with outliers</a></li>
</ol>
]]></content>
      <categories>
        <category>research</category>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>normalization</tag>
        <tag>standardization</tag>
      </tags>
  </entry>
  <entry>
    <title>开启bbr</title>
    <url>/2019/12/20/start-bbr/</url>
    <content><![CDATA[<p>有时候网速太慢，可以使用bbr加速，使用如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.core.default_qdisc=fq&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.tcp_congestion_control=bbr&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>bbr</tag>
      </tags>
  </entry>
  <entry>
    <title>关闭 Windows10 自动更新</title>
    <url>/2021/04/19/stop-windows10-update/</url>
    <content><![CDATA[<p>Windows10 自动更新比较频繁，而且常常需要重启电脑，这样严重影响使用体验。下面介绍一种停止 Windows10 自动更新的方法，当想要更新时，手动更新即可完成更新。</p>
<a id="more"></a>

<h1 id="关闭自动更新"><a href="#关闭自动更新" class="headerlink" title="关闭自动更新"></a>关闭自动更新</h1><p>win + r –&gt; 输入 gpedit.msc –&gt; 管理模板 –&gt; Windows 组件 –&gt; Windows 更新 –&gt; 双击右侧的配置自动更新 –&gt; 点击已禁用</p>
<h1 id="手动更新系统"><a href="#手动更新系统" class="headerlink" title="手动更新系统"></a>手动更新系统</h1><p>win + i –&gt; 更新和安全 –&gt; 检查更新</p>
]]></content>
      <categories>
        <category>technology</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows10</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Maven打包jar包并提交到storm拓扑上运行</title>
    <url>/2020/01/19/storm-jar-mvn-topology/</url>
    <content><![CDATA[<p>使用maven编写Java代码并打包jar包是非常方便的，这篇文章介绍使用maven打包storm应用程序代码并提交到storm集群上的拓扑上运行。</p>
<a id="more"></a>

<h1 id="使用idea和maven创建一个storm工程"><a href="#使用idea和maven创建一个storm工程" class="headerlink" title="使用idea和maven创建一个storm工程"></a>使用idea和maven创建一个storm工程</h1><ol>
<li><p>点击Project</p>
</li>
<li><p>选择Maven</p>
</li>
<li><p>点击Next</p>
</li>
<li><p>输入工程名、GroupId、ArtifactId等，假设这里输入工程名为：com.monkey</p>
</li>
<li><p>默认打开一个pom.xml文件，在里面输入一下配置信息</p>
<p>1&gt; 打开官网：<a href="https://mvnrepository.com/artifact/org.apache.storm/storm-core">Storm Core</a></p>
<p>选择版本，拷贝如下信息到pom.xml中，注意，需要手动创建&lt;dependencies&gt;*&lt;/dependencies&gt;，并把下面的内容替换 * 号，另外，如果是本地测试，需要将provided修改为compile，如果是打成jar包并提交storm集群上，请使用provided</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.apache.storm/storm-core --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.storm&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;storm-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2&gt; 打开官网：<a href="https://maven.apache.org/plugins/maven-shade-plugin/usage.html">Apache Maven Shade Plugin</a> ，拷贝如下的配置文件，注意，your.main.class替换为你自己的主函数类名，该插件进行maven打包最同意，直接进入工程目录，然后输入命令 mvn package进行打包，它会将依赖的所有jar打包，包含可能同名的jar包；而使用Apache Maven Assembly Plugin 打包，会覆盖同名的jar包，对于那些不同目录下同名的jar包覆盖可能会造成运行时错误，如hdfs，配置信息，下面给出，打包命令 mvn package assembly:single；对于不需要依赖的程序，可以直接在工程目录下运行命令 mvn package 进行打包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">       &lt;plugins&gt;</span><br><span class="line">           &lt;plugin&gt;</span><br><span class="line">               &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;3.2.1&lt;/version&gt;</span><br><span class="line">               &lt;configuration&gt;</span><br><span class="line">                   &lt;transformers&gt;</span><br><span class="line">                       &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;</span><br><span class="line">                           &lt;mainClass&gt;WordCountTopology&lt;/mainClass&gt;</span><br><span class="line">                       &lt;/transformer&gt;</span><br><span class="line">                   &lt;/transformers&gt;</span><br><span class="line">               &lt;/configuration&gt;</span><br><span class="line">               &lt;executions&gt;</span><br><span class="line">                   &lt;execution&gt;</span><br><span class="line">                       &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                       &lt;goals&gt;</span><br><span class="line">                           &lt;goal&gt;shade&lt;/goal&gt;</span><br><span class="line">                       &lt;/goals&gt;</span><br><span class="line">                   &lt;/execution&gt;</span><br><span class="line">               &lt;/executions&gt;</span><br><span class="line">           &lt;/plugin&gt;</span><br><span class="line">       &lt;/plugins&gt;</span><br><span class="line">   &lt;/build&gt;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="6">
<li><p>写代码</p>
<p>注意，在构建拓扑时，如果既想在本地调试运行（pom.xml 设置成compile），又想能够提交到远程集群运行（pom.xml设置成provided），构建拓扑类需如下写代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line"><span class="comment">// config.put(&quot;wordcount&quot;, &quot;wordcount&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;remote run&quot;</span>); <span class="comment">// 远程集群运行</span></span><br><span class="line">        StormSubmitter.submitTopology(args[<span class="number">0</span>], config, builder.createTopology());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;local run&quot;</span>); <span class="comment">// 本地运行</span></span><br><span class="line">        LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</span><br><span class="line"></span><br><span class="line">        cluster.submitTopology(TOPOLOGY_NAME, config, builder.createTopology());</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        cluster.killTopology(TOPOLOGY_NAME);</span><br><span class="line">        cluster.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="使用idea和maven打包jar包"><a href="#使用idea和maven打包jar包" class="headerlink" title="使用idea和maven打包jar包"></a>使用idea和maven打包jar包</h1><p>打包工程到jar包，进入工程目录下，输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean</span><br><span class="line">mvn package</span><br></pre></td></tr></table></figure>

<p>在./target目录下有<strong>com.monkey-*.jar</strong>和 original-com.monkey-*.jar两个jar包，第一个才是我们需要的jar包</p>
<h1 id="提交jar包到storm拓扑上"><a href="#提交jar包到storm拓扑上" class="headerlink" title="提交jar包到storm拓扑上"></a>提交jar包到storm拓扑上</h1><p>将刚刚打包的jar包提交到storm的拓扑上，使用如下命令(这里以工程目录下提交，并且storm安装在用户目录下)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/storm/bin/storm jar ./target/com.monkey-\*.jar WordCountTopology <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>参数解释：“~/storm/bin/storm” 表示storm命令，“jar”表示storm命令的参数，运行jar包命令，“./target/com.monkey-*.jar”表示待提交运行的jar包，“WordCountTopology”表示工程项目的主类入口，注意和上面pom.xml配置参数对应一致，“test”表示提交到集群拓扑上显示的Topology_name</p>
<p>后续，可以通过网页，如localhost:8080打开storm ui，进入topology summary进行管理，如kill等。也可以通过命令行的方式管理，如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">storm -h</span><br></pre></td></tr></table></figure>

<p>表示打开storm命令帮助文件，里面有storm命令行介绍及参数列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">storm list</span><br></pre></td></tr></table></figure>

<p>表示查看正在运行的拓扑信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">storm <span class="built_in">kill</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>表示kill掉拓扑名为test的拓扑，更多命令请参考：<a href="https://www.bookstack.cn/read/Storm-Documents/Manual-zh-Command-Line-Client.md">命令行操作</a></p>
<p>注意，可以通过配置项来修改拓扑的运行，配置信息的优先级依次为：</p>
<p>defaults.yaml &lt; storm.yaml &lt; 拓扑配置 &lt; 内置型组件信息配置 &lt; 外置型组件信息配置。</p>
<h1 id="其他maven打包方法"><a href="#其他maven打包方法" class="headerlink" title="其他maven打包方法"></a>其他maven打包方法</h1><p>上面介绍了使用maven的shade插件进行打包，其实还有两种比较简单的打jar包方法，但是，都没有shade插件打包的通用。</p>
<h2 id="1-直接使用maven打包"><a href="#1-直接使用maven打包" class="headerlink" title="1. 直接使用maven打包"></a>1. 直接使用maven打包</h2><p>当工程代码不需要依赖外部jar包时，同时在pom.xml文件中，指定了程序的主入口，就可以在工程目录下，使用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean</span><br><span class="line">mvn package </span><br></pre></td></tr></table></figure>

<p>进行打包</p>
<h2 id="2-使用maven-assembly-插件打包"><a href="#2-使用maven-assembly-插件打包" class="headerlink" title="2. 使用maven assembly 插件打包"></a>2. 使用maven assembly 插件打包</h2><p>对于大多数带有额外jar包的程序或工程，都可以使用assembly进行打包，只要额外jar包中不出现同名的不同功能的jar包，需要在pom.xml文件中，写入如下配置信息，注意修改主类入口函数名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;descriptorRefs&gt;</span><br><span class="line">            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;</span><br><span class="line">        &lt;/descriptorRefs&gt;</span><br><span class="line">        &lt;archive&gt;</span><br><span class="line">            &lt;manifest&gt;</span><br><span class="line">                &lt;mainClass&gt;your.main.class&lt;/mainClass&gt;</span><br><span class="line">            &lt;/manifest&gt;</span><br><span class="line">        &lt;/archive&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>

<p>进入工程目录，输入如下命令进行打包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean</span><br><span class="line">mvn package assembly:single</span><br></pre></td></tr></table></figure>

<p>需要的jar包是带有依赖的那个</p>
<h2 id="3-使用maven-shade插件打包"><a href="#3-使用maven-shade插件打包" class="headerlink" title="3.使用maven shade插件打包"></a>3.使用maven shade插件打包</h2><p>该方法是推荐的方法，对于任何情况的工程都可以使用，而且打包命令简单。请参考上面的pom.xml配置文件信息，并进入工程输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean</span><br><span class="line">mvn package</span><br></pre></td></tr></table></figure>

<p>进行打包</p>
<p>本节内容参考了如下文章：</p>
<p>1、<a href="https://www.cnblogs.com/xuwujing/p/8584684.html">Storm 入门的Demo教程</a></p>
<p>2、<a href="https://www.cnblogs.com/200911/p/5085343.html">storm学习之六-使用Maven 生成jar包多种方式</a></p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
        <tag>storm</tag>
      </tags>
  </entry>
  <entry>
    <title>storm 集群部署</title>
    <url>/2020/03/08/storm-cluster-deployment/</url>
    <content><![CDATA[<p>Storm 是一个分布式计算框架，主要由Clojure编程语言编写，其主要编程语言是Java 和Clojure。最初是由Nathan Marz及其团队创建于BackType，该项目在被Twitter取得后开源。Storm集群部署需要Zookeeper和python的支持，假设这两个软件已经安装，并成功部署了Zookeeper集群。获取如何Standalone集群部署Zookeeper请参考我的文章：<a href="https://xujinzh.github.io/2020/03/03/zookeeper-cluster-deployment/">Zookeeper集群部署</a> </p>
<a id="more"></a>

<p>下面分步骤进行Storm的集群部署，假设部署到三台服务器上，其IP地址分别是1.1.1.0， 1.1.1.1， 1.1.1.2，如果想部署更多台，可以后续随意增加，非常方便扩容，这是storm的一个优点。这里将1.1.1.0作为nimbus节点和UI节点，把1.1.1.1 和1.1.1.2 作为supervisor节点。假设部署的zookeeper集群分别是box0, box1, box2，其IP分别是1.1.10.0， 1.1.10.1， 1.1.10.2，并启动了zookeeper服务。</p>
<h1 id="下载storm"><a href="#下载storm" class="headerlink" title="下载storm"></a>下载storm</h1><p>从官网：<a href="https://storm.apache.org/downloads.html">Apache Storm downloads</a> 下载喜欢的版本。这里以版本 <a href="https://www.apache.org/dyn/closer.lua/storm/apache-storm-2.1.0/apache-storm-2.1.0.tar.gz">apache-storm-2.1.0.tar.gz</a> 为例进行安装部署。</p>
<h1 id="安装Storm"><a href="#安装Storm" class="headerlink" title="安装Storm"></a>安装Storm</h1><p>解压缩下载的storm软件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzf apache-storm-2.1.0.tar.gz</span><br><span class="line">mv apache-storm-2.1.0 storm</span><br></pre></td></tr></table></figure>

<h1 id="配置storm"><a href="#配置storm" class="headerlink" title="配置storm"></a>配置storm</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> storm/</span><br><span class="line">mkdir data</span><br><span class="line">vim ./conf/storm.yaml </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storm.zookeeper.servers:</span><br><span class="line">   - &quot;1.1.10.0&quot;</span><br><span class="line">   - &quot;1.1.10.1&quot;</span><br><span class="line">   - &quot;1.1.10.2&quot;</span><br><span class="line">nimbus.seeds: [&quot;1.1.1.0&quot;]</span><br><span class="line">storm.local.dir=&quot;/home/jinzhongxu/storm/data&quot;</span><br><span class="line">supervisor.slots.ports:</span><br><span class="line"> 	- 6701</span><br><span class="line"> 	- 6702</span><br><span class="line"> 	- 6703</span><br><span class="line"> 	- 6704</span><br></pre></td></tr></table></figure>

<p><strong>注意，这里需要严格保证空格，配置各项需要与侧边栏空一格，“-” 与配置参数空一格等</strong>。</p>
<p>配置好后，将storm文件夹传到其他机器上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r storm 1.1.1.1:/home/jinzhongxu/.</span><br><span class="line">scp -r storm 1.1.1.2:/home/jinzhongxu/.</span><br></pre></td></tr></table></figure>

<h1 id="启动storm"><a href="#启动storm" class="headerlink" title="启动storm"></a>启动storm</h1><p>在机器1.1.1.0上，启动nimbus 和ui</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> storm</span><br><span class="line">./bin/storm nimbus</span><br><span class="line">./bin/storm ui</span><br></pre></td></tr></table></figure>

<p>在机器1.1.1.1和1.1.1.2上分别启动supervisor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> storm</span><br><span class="line">./bin/storm supervisor</span><br></pre></td></tr></table></figure>

<p>如果想要后台启动，可以运行如下类似命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup ./bin/storm supervisor &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>表示将日志文件（标准输出和标准错误）丢弃并在后台启动</p>
<h1 id="查看storm集群启动情况"><a href="#查看storm集群启动情况" class="headerlink" title="查看storm集群启动情况"></a>查看storm集群启动情况</h1><p>可以在各运行storm的集群上使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure>

<p>命令查看，如果发现有nimbus 或 supervisor则证明启动成功。</p>
<p>可以通过访问 1.1.1.0:8080 来查看storm UI</p>
<h1 id="关闭storm"><a href="#关闭storm" class="headerlink" title="关闭storm"></a>关闭storm</h1><p>可以使用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure>

<p>查看storm服务的pid，比如，pid=2384然后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> 2384</span><br></pre></td></tr></table></figure>

<p>杀死服务</p>
<h1 id="关于storm的调优"><a href="#关于storm的调优" class="headerlink" title="关于storm的调优"></a>关于storm的调优</h1><ol>
<li><p>关于配置项 supervisor.slots.ports 表示该集群上为storm 的worker进程开通的端口号，一般一个worker需要消耗768+64=832M内存，当然，可以通过设置<strong>worker.childopts: “-Xmx2048m”</strong> 为2048M内存等。到底开几个端口需要看本机器的内存和cpu核心数。</p>
</li>
<li><p>在定义一个拓扑时，可以通过 <strong>conf.setNumWorkers()</strong> 函数来指定一个 topolgoy 的 worker 数量，要小于（supervisor个数*每个supervisor的slots ports数）。如果worker数太大也不好，因为storm进程间通信比进程内耗费时间长，所以需要为topology设置一个合理的worker数。</p>
</li>
<li><p>当storm与Kafka集成时，最好设置<strong>Kafka Partition == Storm Spout</strong>。</p>
</li>
<li><p>当设置bolt 分组时，<strong>优先使用localOrShuffleGrouping</strong>代替shuffleGrouping，优先使用自带的分组而不是自己编写的分组方式。</p>
</li>
<li><p>如果代码执行时间长，则需要通过增加Worker数量来将压力分散到更多的节点上以提升并发能力。<strong>worker.heap.memory.mb、topology.worker.max.heap.size.mb</strong>用来调整分配给每个 Worker的内存。当运行程序的Worker报出内存溢出的情况下，比较管用。</p>
</li>
<li><p><strong>topology.max.spout.pending:</strong> 最大 Spout 挂起时间。一般Spout 的发射速度会快于下游的 Bolt 的消费速度，当下游的 Bolt 还有 pending中的 Tuple 没有消费完时，Spout 会停下来等待，该配置作用于 Spout 的每个 task。因此这个参数需要合理设置。conf.put(Config.TOPOLOGY_MAX_SPOUT_PENDING, 10000)。</p>
</li>
<li><p><strong>acker数量：</strong>默认情况下，Storm 会在每个 worker 进程里面启动1个 acker 线程，以为 spout/bolt 提供 ack/fail 服务，该线程通常不太耗费资源，因此也无须配置过多，大多数情况下1个就足够了。最好 numAckers == numWorkers.</p>
</li>
<li><p><strong>storm rebalance mytopology -n 5 -e blue-spout=3 -e yellow-bolt=10</strong> 表示为拓扑mytopology 设置workers=5， blue-spout=3， yellow-bolt=10，其10个进程中包含3个spout和10个bolt并行运行拓扑。</p>
</li>
<li><p>要找出并行度的最佳取值，主要结合 Storm UI 来做决策。</p>
</li>
<li><p>操作系统配置，使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -a</span><br></pre></td></tr></table></figure>

<p>查看</p>
<ol>
<li><p>open files：当前用户可以打开的文件描述符数；</p>
</li>
<li><p>max user processes：当前用户可以运行的进程数，此参数太小将引起storm的一个错误，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: unable to create new native thread</span><br><span class="line">       	at java.lang.Thread.start0 (Native Method) [na:xxx]</span><br><span class="line">	at java.lang.Thread.start (Thread.java: 640) [na:xxx]</span><br><span class="line">       	at java.lang.UNIXProcess$1.run (UNIXProcess.java:141) ~ [na:xxx]</span><br><span class="line">	at java.security.AccessController.doPrivileged (Native Method) ~ [na:xxx]</span><br></pre></td></tr></table></figure>





</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>big data</tag>
        <tag>storm</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper 和 storm 安装与启动</title>
    <url>/2020/01/16/storm-setup/</url>
    <content><![CDATA[<p>Storm的运行需要Zookeeper的协助，主要是为了协调Storm无状态的Master守护进程Nimbus和Worker守护进程Supervisor。所以启动Storm之前需要首先启动Zookeeper，下面分三步进行介绍，注意，这里以单机模式测试，关于Zookeeper的Standalone集群部署请参考我的另一篇文章：<a href="https://xujinzh.github.io/2020/03/03/zookeeper-cluster-deployment/">Zookeeper集群部署</a>, 关于storm的Standalone集群部署请参考我的文章：<a href="https://xujinzh.github.io/2020/03/08/storm-cluster-deployment/">storm集群部署</a> </p>
<a id="more"></a>

<h1 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h1><p>首先从Oracle官网<a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html">下载jdk</a></p>
<p>其次，解压该压缩包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzf jdk*</span><br></pre></td></tr></table></figure>

<p>最后，将Java路径添加到环境变量</p>
<h1 id="安装Zookeeper和Storm"><a href="#安装Zookeeper和Storm" class="headerlink" title="安装Zookeeper和Storm"></a>安装Zookeeper和Storm</h1><p>首先从官网<a href="http://zookeeper.apache.org/releases.html#download">下载Zookeeper</a> (<strong>注意：3.4.14版本测试通过，而3.5.6不成功</strong>)和<a href="https://storm.apache.org/">下载Storm</a></p>
<p>其次，解压两个压缩包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzf zookeeper-3.4.14.tar.gz</span><br><span class="line">tar -xzf apache-storm-2.1.0.tar.gz</span><br></pre></td></tr></table></figure>

<p>最后，配置Zookeeper和Storm</p>
<ol>
<li>配置Zookeeper</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> zookeeper</span><br><span class="line">mkdir data</span><br><span class="line"><span class="built_in">cd</span> conf/</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line">vim zoo.cfg</span><br></pre></td></tr></table></figure>

<p>修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dataDir=/home/jinzhongxu/zookeeper/data</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>配置Storm</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> storm</span><br><span class="line">mkdir data</span><br><span class="line"><span class="built_in">cd</span> conf/</span><br><span class="line">cp storm.yaml storm.yaml.bak</span><br><span class="line">vim storm.yaml</span><br></pre></td></tr></table></figure>

<p>修改（<strong>注意：‘-’ 与后面的参数值之间有一个空格</strong>）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storm.zookeeper.servers:</span><br><span class="line">    - &quot;localhost&quot;</span><br><span class="line">storm.local.dir: &quot;/home/jinzhongxu/storm/data&quot;</span><br><span class="line">nimbus.host: &quot;localhost&quot;</span><br><span class="line">supervisor.slots.ports:</span><br><span class="line">    - 6700</span><br><span class="line">    - 6701</span><br><span class="line">    - 6702</span><br><span class="line">    - 6703</span><br></pre></td></tr></table></figure>

<h1 id="启动zookeeper和storm"><a href="#启动zookeeper和storm" class="headerlink" title="启动zookeeper和storm"></a>启动zookeeper和storm</h1><h2 id="启动zookeeper"><a href="#启动zookeeper" class="headerlink" title="启动zookeeper"></a>启动zookeeper</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> zookeeper</span><br><span class="line">bin/zkServer.sh start</span><br></pre></td></tr></table></figure>



<h2 id="启动storm"><a href="#启动storm" class="headerlink" title="启动storm"></a>启动storm</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> storm</span><br><span class="line">bin/storm nimbus</span><br><span class="line">bin/storm supervisor</span><br><span class="line">bin/storm ui</span><br></pre></td></tr></table></figure>

<p>也可以使用如下方式，以后台方式打开</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> storm</span><br><span class="line">nohup ./bin/storm nimbus &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">nohup ./bin/storm supervisor &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">nohup ./bin/storm ui &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<ol>
<li>nohup: 表示no hang up，即一直运行</li>
<li>&gt; /dev/null: 表示将日志输出丢弃到/dev/null中，即直接丢弃，不存储到服务器上</li>
<li>2&gt;&amp;1: 表示将2的错误输出（stderr）和1的标准输出（stdout）只打开一个通道一起写入1即/dev/null中</li>
<li>最后一个&amp;: 表示以后台方式运行，而不在终端上打印日志信息</li>
</ol>
<p>打开本地浏览器，输入网址 <a href="http://localhost:8080/">http://localhost:8080</a></p>
<h1 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h1><p>可以使用命令jps显示是否运行成功，比如单台机器情况如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinzhongxu@jinzhongxu-PowerEdge-R740:~$ jps</span><br><span class="line">34530 Jps</span><br><span class="line">11305 Main</span><br><span class="line">25930 QuorumPeerMain</span><br><span class="line">33789 UIServer</span><br><span class="line">33373 Supervisor</span><br><span class="line">32910 Nimbus</span><br></pre></td></tr></table></figure>

<p>如果想关闭进行，可直接kill掉相应的pid</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> 32910</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>big data</tag>
        <tag>storm</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>因 sudoers 出错无法使用 sudo 的解决方法</title>
    <url>/2021/03/21/sudo-error/</url>
    <content><![CDATA[<p>Linux 上修改 /etc/sudoers 导致文件出错，此时只要能够修改该文件的错误即可，但是普通用户 jinzhongxu 无法使用 sudo 命令，且无法使用 root 用户登陆。因此，需要能够进行 /etc/sudoers 修改，并更正错误即可。以下给出一种解决方法。</p>
<a id="more"></a>

<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol>
<li><p>使用 ssh 连接普通用户 jinzhongxu，并打开两个终端 shell：t1, t2</p>
</li>
<li><p>在 t1 输入命令：</p>
<p><code>echo $$</code></p>
<p>并把返回的数字拷贝下来</p>
</li>
<li><p>在 t2 输入命令：</p>
<p><code>pkttyagent --process 拷贝的数字 </code></p>
</li>
<li><p>再在 t1 中输入</p>
<p><code>pkexec visudo</code></p>
<p>此时 t1也会卡住</p>
</li>
<li><p>再切换到 t2，输入用户 jinzhongxu 的密码</p>
</li>
<li><p>再次切换到 t1，发现此时正在打开 /etc/sudoers 等到修改，修改 /etc/sudoers 中出错的内容并保存。</p>
</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="https://juejin.cn/post/6844904070545670158">Ubuntu改坏sudoers后无法使用sudo的解决办法</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>sudo</tag>
      </tags>
  </entry>
  <entry>
    <title>上极限和下极限</title>
    <url>/2020/03/22/superior-limit-and-inferior-limit/</url>
    <content><![CDATA[<p>上极限和下极限是针对数列而言的，需谨慎考虑数集或点集。</p>
<p><strong>定义 1</strong> &emsp; 若在数$a$的任一领域内含有<font color='dd0000'>数列</font>$\{x_n\}$的无限多个项，则称$a$为数列$\{x_n\}$的一个聚点。</p>
<a id="more"></a>

<p><em>当不区分实数与数轴上的点的情况下，点列的聚点等同于数列的聚点，也称为极限点。需要说明的是，点集和数集的聚点不能叫作极限点</em>。</p>
<p><strong>点列的聚点就是其收敛子列的极限</strong>。</p>
<p><strong>定理 7.4</strong> &emsp; 有界点列（数列）$\{x_n\}$至少有一个聚点，且存在最大聚点和最小聚点。</p>
<p><strong>定义 2</strong> &emsp; 有界数列（点列）$\{x_n\}$的最大聚点$\overline{A}$与最小聚点$\underline{A}$分别称为$\{x_n\}$的上极限与下极限，记作<br>$$<br>\overline{A} = \varlimsup_{n \to \infty}x_n, \quad \underline{A} = \varliminf_{n \to \infty}x_n.<br>$$<br><strong>这里需要注意下极限的书写方法</strong>。</p>
<p><strong>定理 7.5</strong> &emsp; 对任何有界数列$\{x_n\}$有<br>$$<br>\varliminf_{n \to \infty}x_n \leq \varlimsup_{n \to \infty}x_n.<br>$$<br><strong>定理 7.6</strong> &emsp; 对于数列$\{x_n\}$，<br>$$<br>\lim_{n \to \infty}x_n = A<br>$$<br>的充要条件是<br>$$<br>\varlimsup_{n \to \infty}x_n = \varliminf_{n \to \infty}x_n = A<br>$$<br><strong>定理 7.7</strong> &emsp; 设$\{x_n\}$为有界数列，</p>
<ol>
<li><p>$\overline{A}$为$\{x_n\}$上极限的充要条件是：任给$\varepsilon &gt; 0$，</p>
<p>i. 存在$N &gt; 0$，使得当$n &gt; N$时有$x_n &lt; \overline{A} + \varepsilon$;</p>
<p>ii. 存在子列$\{x_{n_k}\}$满足$x_{n_k} &gt; \overline{A} - \varepsilon, \ k = 1, 2, \cdots.$</p>
</li>
<li><p>$\underline{A}$为$\{x_n\}$下极限的充要条件是：任给$\varepsilon &gt; 0$，</p>
<p>i. 存在$N &gt; 0$，使得当$n &gt; N$时有$x_n &gt; \underline{A} - \varepsilon$；</p>
<p>ii. 存在子列$\{x_{n_k}\}$满足$x_{n_k} &lt; \underline{A} + \varepsilon, \ k = 1, 2, \cdots.$</p>
</li>
</ol>
<p>该定理的另一种表述形式如下：</p>
<p><strong>定理 $7.7^{\prime}$</strong> &emsp; 设$\{x_n\}$为有界数列，</p>
<ol>
<li>$\overline{A}$为上极限的充要条件是对任何$\alpha &gt; \overline{A}$，$\{x_n\}$中大于$\alpha$的项至多有有限个；对任何$\beta &lt; \overline{A}$，$\{x_n\}$中大于$\beta$的项有无限个。</li>
<li>$\underline{A}$为下极限的充要条件是对任何$\alpha &lt; \underline{A}$，$\{x_n\}$中小于$\alpha$的项至多有有限个；对任何$\beta &gt; \underline{A}$，$\{x_n\}$中小于$\beta$的项有无限个。</li>
</ol>
<p><strong>定理 7.8</strong> &emsp; （上、下极限的保不等式性）&emsp; 设有界数列$\{a_n\}$, $\{b_n\}$满足：存在$N_0 &gt; 0$，当$n &gt; N_0$时，有$a_n \leq b_n$，则<br>$$<br>\varlimsup_{n \to \infty}a_n \leq \varlimsup_{n \to \infty}b_n, \ \varliminf_{n \to \infty}a_n \leq \varliminf_{n \to \infty}b_n.<br>$$<br>特别地，若$\alpha, \beta$为常数，又存在$N_0 &gt; 0$，当$n &gt; N_0$时有$\alpha \leq a_n \leq \beta$，则<br>$$<br>\alpha \leq \varliminf_{n \to \infty}a_n \leq \varlimsup_{n \to \infty}a_n \leq \beta.<br>$$<br>假设$\{a_n\}$,$\{b_n\}$为有界数列，则<br>$$<br>\varlimsup_{n \to \infty}(a_n + b_n) \leq \varlimsup_{n \to \infty}a_n + \varlimsup_{n \to \infty}b_n.<br>$$<br>下面给出一个非常重要的定理，该定理在实变函数中也会出现。</p>
<p><strong>定理 7.9</strong>&emsp; 设$\{x_n\}$为有界数列，</p>
<ol>
<li><p>$\overline{A}$为$\{x_n\}$上极限的充要条件是<br>$$<br>\overline{A} = \lim_{n \to \infty}\sup_{k \geq n}\{x_k\}<br>$$</p>
</li>
<li><p>$\underline{A}$为$\{x_n\}$下极限的充要条件是<br>$$<br>\underline{A} = \lim_{n \to \infty}\inf_{k \geq n}\{x_k\}<br>$$</p>
</li>
</ol>
<p>一些事实：</p>
<ol>
<li><p>设$\{a_n\}$, $\{b_n\}$为有界数列，则</p>
<ol>
<li><p>$$<br>\varliminf_{n \to \infty}a_n = - \varlimsup_{n \to \infty}(-a_n);<br>$$</p>
</li>
<li><p>$$<br>\varliminf_{n \to \infty}a_n + \varliminf_{n \to \infty}b_n \leq \varliminf_{n \to \infty}(a_n + b_n);<br>$$</p>
</li>
<li><p>若$a_n &gt; 0, b_n &gt; 0 \ (n = 0, 1, 2, \cdots)$，则<br>$$<br>\varliminf_{n \to \infty}a_n \cdot \varliminf_{n \to \infty}b_n \leq \varliminf_{n \to \infty}(a_n \cdot b_n);<br>$$</p>
<p>$$<br>\varlimsup_{n \to \infty}a_n \cdot \varlimsup_{n \to \infty}b_n \geq \varlimsup_{n \to \infty}(a_n \cdot b_n);<br>$$</p>
</li>
<li><p>若$a_n &gt; 0, \ \varliminf_{n \to \infty}a_n &gt; 0$，则<br>$$<br>\varliminf_{n \to \infty}\frac{1}{a_n} = \frac{1}{\varliminf_{n \to \infty}a_n}.<br>$$</p>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>若$\{a_n\}$为递增数列，则$\varlimsup_{n \to \infty}a_n = \lim_{n \to \infty}a_n$.</p>
</li>
<li><p>若$a_n &gt; 0 \ (n = 1, 2, \cdots)$ 且$\varlimsup_{n \to \infty}a_n \cdot \varlimsup_{n \to \infty}\frac{1}{a_n} = 1$，则数列$\{a_n\}$收敛。</p>
</li>
</ol>
<p>例题</p>
<p>设$\varliminf_{n \to \infty}x_n = A &lt; B = \varlimsup_{n \to \infty}x_n$且$\lim_{n \to \infty}(x_{n + 1} - x_n) = 0$，则$x_n$的聚点全体恰为闭区间$[A, B]$.</p>
<p>提示：采用反证法。</p>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>limit</tag>
        <tag>superior</tag>
        <tag>inferior</tag>
      </tags>
  </entry>
  <entry>
    <title>可积性理论补叙</title>
    <url>/2020/09/27/supplement-to-integrability-theory/</url>
    <content><![CDATA[<p>在前面，介绍了上和$S(T)$和下和$s(T)$，即对于分割$T:a=x_0 &lt; x_1 &lt; \cdots &lt; x_n = b$，以及$\Delta_i = [x_{i-1}, x_i], \Delta x_i = x_i - x_{i-1}$，有<br>$$<br>S(T) = \sum_{i=1}^n M_i \Delta x_i<br>$$<br>$$<br>s(T) = \sum_{i=1}^n m_i \Delta x_i<br>$$</p>
<a id="more"></a>

<p>其中$M_i = \sup_{x \in \Delta_i} f(x), m_i = \inf_{x \in \Delta_i} f(x), i = 1, 2, \cdots, n$. 因为可积必有界，假设$f$在$[a, b]$上有界，因此，$M_i, m_i$分别有上、下确界$M, m$，而且对于任何$\xi_i \in \Delta_i$，有<br>$$<br>m(b - a) \leq s(T) \leq \sum_{i=1}^n f(\xi_i) \Delta x_i \leq S(T) \leq M(b - a).<br>$$</p>
<h1 id="上和与下和的性质"><a href="#上和与下和的性质" class="headerlink" title="上和与下和的性质"></a>上和与下和的性质</h1><p><strong>性质 1</strong>    对同一个分割$T$，相对于任何点集${\xi_i}$而言，上和是所有积分和的上确界，下和是所有积分和的下确界，即<br>$$<br>S(T) = \sup_{|\xi_i|} \sum_{i=1}^n f(\xi_i) \Delta x_i, \\<br>s(T) = \inf_{|\xi_i|} \sum_{i=1}^n f(\xi_i) \Delta x_i.<br>$$<br><strong>性质 2</strong>    设$T^{\prime}$为分割$T$添加$p$个新分点后所得到的分割，则有<br>$$<br>S(T) \geq S(T^{\prime}) \geq S(T) - (M - m)p |T|, \\<br>s(T) \leq s(T^{\prime}) \leq s(T) + (M - m)p |T|.<br>$$<br>增加分点后，上和不增，下和不减。</p>
<p><strong>性质 3</strong>    若$T^{\prime}$与$T^{\prime\prime}$为任意两个分割，$T = T^{\prime} + T^{\prime\prime}$ 表示把$T^{\prime}$与$T^{\prime\prime}$的所有分点合并而得到的分割（注意：重复的分点只取一次），则<br>$$<br>S(T) \leq S(T^{\prime})， s(T) \geq s(T^{\prime}), \\<br>S(T) \leq S(T^{\prime\prime}), s(T) \geq s(T^{\prime\prime}).<br>$$<br><strong>性质 4</strong>    对任意两个分割$T^{\prime}$与$T^{\prime\prime}$，总有<br>$$<br>s(T^{\prime}) \leq s(T) \leq S(T) \leq S(T^{\prime\prime}).<br>$$<br><strong>性质 5</strong>    $m(b - a) \leq s \leq S \leq M(b - a).$</p>
<p><strong>性质 6</strong>    （达布定理）上、下积分也是上和与下和在$|T| \to 0$时的极限，即<br>$$<br>\lim_{|T| \to 0} S(T) = S, \lim_{|T| \to 0} s(T) = s.<br>$$</p>
<h1 id="可积的充要条件"><a href="#可积的充要条件" class="headerlink" title="可积的充要条件"></a>可积的充要条件</h1><p><strong>定理 9.14</strong>    （可积的第一充要条件）函数$f$在$[a, b]$上可积的充要条件是$f$在$[a, b]$上的上积分与下积分相等，即<br>$$<br>S = s.<br>$$<br><strong>定理 9.15</strong>    （可积的第二充要条件）函数$f$在$[a, b]$上可积的充要条件是任给$\varepsilon &gt; 0$，总存在某一分割$T$，使得<br>$$<br>S(T) - s(T) &lt; \varepsilon,<br>$$<br>即<br>$$<br>\sum_{i=1}^n \omega_i \Delta x_i &lt; \varepsilon.<br>$$<br><strong>定理 9.16</strong>    （可积的第三充要条件）函数$f$在$[a, b]$上可积的充要条件是任给正数$\varepsilon, \eta$，总存在某一分割$T$，使得属于$T$的所有小区间中，对应于振幅$\omega_{k^{\prime}} \geq \varepsilon$的那些小区间$\Delta_{k^{\prime}}$的总长$\sum_{k^{\prime}} \Delta x_{k^{\prime}} &lt; \eta.$</p>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>integral</tag>
        <tag>definite integral</tag>
      </tags>
  </entry>
  <entry>
    <title>为Centos 或Ubuntu添加交换分区swap</title>
    <url>/2020/03/10/swap-linux/</url>
    <content><![CDATA[<p>Centos 或者 Ubuntu的交换分区swap，类似于Windows系统的虚拟内存，能够在系统内存不足时，利用一部分硬盘空间虚拟出内存空间，解决内存不足的问题。下面分别给出如何为Centos 和 Ubuntu增加交换分区。</p>
<a id="more"></a>

<h1 id="Centos-添加交换分区"><a href="#Centos-添加交换分区" class="headerlink" title="Centos 添加交换分区"></a>Centos 添加交换分区</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dd <span class="keyword">if</span>=/dev/zero of=/swapfile count=2048 bs=1MiB</span><br><span class="line">sudo chmod 600 /swapfile</span><br><span class="line">sudo mkswap /swapfile</span><br><span class="line">sudo swapon /swapfile</span><br><span class="line">sudo cp /etc/fstab /etc/fstab.bak</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;/swapfile none swap sw 0 0&#x27;</span> | sudo tee -a /etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;vm.swappiness=10&#x27;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;vm.vfs_cache_pressure=50&#x27;</span> &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure>

<p>这里count=2048，表示2G的交换分区。</p>
<h1 id="Ubuntu添加交换分区"><a href="#Ubuntu添加交换分区" class="headerlink" title="Ubuntu添加交换分区"></a>Ubuntu添加交换分区</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo fallocate -l 2G /swapfile</span><br><span class="line">sudo chmod 600 /swapfile</span><br><span class="line">sudo mkswap /swapfile</span><br><span class="line">sudo swapon /swapfile</span><br><span class="line">sudo cp /etc/fstab /etc/fstab.bak</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;/swapfile none swap sw 0 0&#x27;</span> | sudo tee -a /etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;vm.swappiness=10&#x27;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;vm.vfs_cache_pressure=50&#x27;</span> &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure>

<p>这里的2G表示分配交换分区的硬盘大小为2G。</p>
<h1 id="查看交换分区情况"><a href="#查看交换分区情况" class="headerlink" title="查看交换分区情况"></a>查看交换分区情况</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -h</span><br><span class="line">htop</span><br></pre></td></tr></table></figure>

<p>以上两个命令都可以查看是否成功创建了交换分区。</p>
<h1 id="增减swap分区的大小"><a href="#增减swap分区的大小" class="headerlink" title="增减swap分区的大小"></a>增减swap分区的大小</h1><p>以centos为例，将swap分区从2G减小到1G。一般swap分区的大小适合设置为内存memory的2倍。下面分步骤给出运行代码演示，以root用户操作。</p>
<ol>
<li>停用swap</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapoff /swapfile</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>删除旧swapfile，并重新创建一个新的，这里count设置为你需要的大小，以M为单位</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -f /swapfile &amp;&amp; dd <span class="keyword">if</span>=/dev/zero of=/swapfile count=1024 bs=1MiB</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>安装swap</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkswap /swapfile</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>激活swap</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapon /swapfile</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>最好将swapfile的访问权限设置为root私享</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 600 /swapfile</span><br></pre></td></tr></table></figure>

<p>通过以上步骤设置完后，就可以使用命令free -h查看交换分区的大小了。</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>swap</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>同步与异步</title>
    <url>/2020/03/18/synchronous-asynchronous/</url>
    <content><![CDATA[<p>Synchronous（同步）和Asynchronous（异步）是编程时比较重要的一个概念。而且，同步与异步的概念与我们日常生活中的含义不同，容易导致误解。这里给出计算机科学上两者的解释。</p>
<a id="more"></a>

<h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p>同步类似于实时打电话。什么意思，就是必须同时在线。用计算机术语就是单线程模式，函数或方法调用后，必须等待直接结束，等到返回值后才能释放资源。</p>
<p>同步属于阻塞模式。</p>
<p>一个实际的例子是，用户登录，需要对用户验证完成后才能登录系统。</p>
<p>效率低。</p>
<h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><p>异步类似于分时发短信。就是可以不用同时在线，有空闲时再处理。用计算机术语就是多线程模式，函数或方法调用后，无需等待，可以去执行其他任务。</p>
<p>异步属于非阻塞模式。</p>
<p>一个实际的例子是，页面数据加载过程，不需要等所有数据获取后再显示页面。</p>
<p>效率高。</p>
<p><strong>参考资料：</strong></p>
<ol>
<li><a href="https://blog.csdn.net/tennysonsky/article/details/45111623">同步和异步的区别</a></li>
<li><a href="https://blog.csdn.net/shiyong1949/article/details/80854656">计算机领域中的同步（Synchronous）和异步（Asynchronous）</a></li>
<li><a href="https://www.jianshu.com/p/ee2dcd1ccfc6">简述同步和异步的区别</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>computer</tag>
        <tag>compile</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 压缩与解压缩命令 tar and zip</title>
    <url>/2019/12/20/tar-zip/</url>
    <content><![CDATA[<h1 id="tar-gz"><a href="#tar-gz" class="headerlink" title="tar.gz"></a>tar.gz</h1><h2 id="text文件-目录"><a href="#text文件-目录" class="headerlink" title="text文件/目录"></a>text文件/目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -czvf text.tar.gz text   %压缩text成text.tar.gz</span><br><span class="line">tar -xzvf text.tar.gz           %解压缩text.tar.gz</span><br></pre></td></tr></table></figure>
<p>note: c为压缩, x为解压缩, z为gz格式, v为显示解、压缩过程,  f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</p>
<a id="more"></a>

<h1 id="tar-bz2"><a href="#tar-bz2" class="headerlink" title="tar.bz2"></a>tar.bz2</h1><h2 id="text文件-目录-1"><a href="#text文件-目录-1" class="headerlink" title="text文件/目录"></a>text文件/目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -cjvf text.tar.bz2 text       %压缩text成text.tar.bz2</span><br><span class="line">tar -xjvf text.tar.bz2           %解压缩text.tar.bz2</span><br></pre></td></tr></table></figure>
<p>note: c为压缩, x为解压缩, j为bz2格式, v为显示解、压缩过程,  f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</p>
<h1 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h1><h2 id="text文件-目录-2"><a href="#text文件-目录-2" class="headerlink" title="text文件/目录"></a>text文件/目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip text.zip text     %压缩text为zip格式</span><br><span class="line">unzip text.zip        %解压缩text.zip为text</span><br></pre></td></tr></table></figure>

<h1 id="tgz"><a href="#tgz" class="headerlink" title="tgz"></a>tgz</h1><p><code>tar zxvf backups.tgz</code><br>or<br><code>gunzip -c backups.tgz | tar xvf -</code></p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>tar</tag>
        <tag>zip</tag>
      </tags>
  </entry>
  <entry>
    <title>泰勒公式</title>
    <url>/2020/03/18/taylor-formula/</url>
    <content><![CDATA[<p>Taylor’s Formula (泰勒公式) 本节为参考华东师范大学《数学分析 上册》，学习本书的心得以及重点知识点总结。</p>
<ol>
<li>泰勒公式源于多项式的简单性，多项式逼近函数用于近似计算和理论分析；</li>
<li>在$x = 0$处展开的泰勒公式又称为 Maclaurin(麦克劳林) 公式；</li>
<li>本节讨论了两种余项的泰勒公式，分别是用于定性分析的佩亚诺余项和用于定量分析的拉格朗日余项；</li>
<li>带有佩亚诺余项的泰勒公式多用于求函数极限，一般先考虑等价无穷小，然后对于复杂函数考虑泰勒公式；</li>
<li>利用泰勒公式可以近似计算无理数等的近似值。</li>
</ol>
<a id="more"></a>

<h1 id="带有佩亚诺型余项的泰勒公式"><a href="#带有佩亚诺型余项的泰勒公式" class="headerlink" title="带有佩亚诺型余项的泰勒公式"></a>带有佩亚诺型余项的泰勒公式</h1><p><strong>定理6.9</strong> 若函数$f$在点$x_0$存在直至$n$阶导数，则有$f(x) = T_n(x) + o((x - x_0)^n)$，这里<br>$$<br>T_n(x) = f(x_0) + f^{\prime}(x_0)(x - x_0) + \frac{f^{(2)}(x_0)}{2!}(x - x_0)^2 + \cdots + \frac{f^{(n)}(x_0)}{n!}(x - x_0)^n.<br>$$<br>称为函数$f$在点$x_0$处的泰勒多项式，$T_n(x)$的各项系数$\frac{f^{(k)}(x_0)}{k!}\ (k = 1, 2, \cdots, n)$称为泰勒系数。具有性质<br>$$<br>f^{(k)}(x_0) = T^{(k)}_n(x_0), \ k = 0, 1, 2, \cdots, n.<br>$$</p>
<p><strong>注意，这里只要求在一点$x_0$处$n$阶可导，所以，$n - 1$阶导函数后不能使用柯西中值定理</strong> </p>
<p>$R_n(x) = f(x) - T_n(x)$称为泰勒公式的余项，形如$o((x - x_0)^n)$的余项称为佩亚诺（Peano）型余项，所以上面公式又称为带有佩亚诺型余项的泰勒公式。  </p>
<p>称如下<br>$$<br>f(x) = f(0) + f^{\prime}(0)x + \frac{f^{\prime\prime}(0)}{2!} x^2 + \cdots + \frac{f^{(n)}(0)}{n!} x^n + o(x^n).<br>$$</p>
<p>为（带有佩亚诺型余项的）麦克劳林（Maclaurin）公式。</p>
<p><strong>下面列出一些常用的带有佩亚诺型余项的麦克劳林公式</strong>：</p>
<ol>
<li><p>$$<br>e^x = 1 + x + \frac{x^2}{2!} + \cdots + \frac{x^n}{n!} + o(x^n);<br>$$</p>
</li>
<li><p>$$<br>\sin x = x - \frac{x^3}{3!} + \frac{x^5}{5!} + \cdots + (-1)^{m-1}\frac{x^{2m - 1}}{(2m - 1)!} + o(x^{2m});<br>$$</p>
</li>
<li><p>$$<br>\cos x = 1 - \frac{x^2}{2!} + \frac{x^4}{4!} + \cdots + (-1)^m \frac{x^{2m}}{(2m)!} + o(x^{2m + 1});<br>$$</p>
</li>
<li><p>$$<br>\ln(1 + x) = x - \frac{x^2}{2} + \frac{x^3}{3} + \cdots + (-1)^{n-1}\frac{x^n}{n} + o(x^n);<br>$$</p>
</li>
<li><p>$$<br>(1 + x)^{\alpha} = 1 + \alpha x + \frac{\alpha(\alpha - 1)}{2!} x^2 + \frac{\alpha(\alpha - 1)\cdots(\alpha - n + 1)}{n!} x^n + o(x^n);<br>$$</p>
</li>
<li><p>$$<br>\frac{1}{1 - x} = 1 + x + x^2 + \cdots + x^n + o(x^n).<br>$$</p>
</li>
</ol>
<p><strong>记忆方法：</strong></p>
<ol>
<li>$e^x$ 各阶导数相同，因此$f^{\prime}(0) = f^{\prime\prime}(0) = \cdots = f^{(n)}(0) = e^0 = 1$，形式上最解决泰勒公式。</li>
<li>$\sin x \sim x, \ x \to 0$，且为基函数，只能取奇数幂项。</li>
<li>$\cos x \sim 1, x \to 0$，且为偶函数，只能取偶次幂项。</li>
<li>$\frac{1}{1 - x}$为等比数列极限$\frac{a_1}{1 - q}$的特殊形式。</li>
<li>$\ln(1 + x)$的一次导数为$\frac{1}{1 - (-x)}$，因此是导数展开的一次积分。另外，$\ln(1 + x) \sim x,\ x \to 0.$</li>
<li>$(1 + x)^{\alpha}$可以参考$(1 + x)^n$的二项式展开，即每项为$C^i_n x^{i}$.</li>
</ol>
<h1 id="带有拉格朗日型余项的泰勒公式"><a href="#带有拉格朗日型余项的泰勒公式" class="headerlink" title="带有拉格朗日型余项的泰勒公式"></a>带有拉格朗日型余项的泰勒公式</h1><p>拉格朗日型余项是一种定量形式的余项，便于对逼近误差进行具体的计算或估计。</p>
<p><strong>定理 6.10</strong> &emsp; (泰勒定理) &emsp; 若函数$f$在$[a, b]$上存在直至$n$阶的连续导函数，在$(a, b)$上存在$(n + 1)$阶导函数，则对任意给定的$x, x_0 \in [a, b]$，至少存在一点$\xi \in (a, b)$，使得<br>$$<br>f(x) = f(x_0) + f^{\prime}(x_0)(x - x_0) + \frac{f^{\prime\prime}(x_0)}{2!}(x - x_0)^2 + \cdots + \frac{f^{(n)}(x_0)}{n!}(x - x_0)^n + \frac{f^{(n + 1)}(\xi)}{(n + 1)!}(x - x_0)^{n + 1}.<br>$$<br><font color='dd0000'>注意：这里是在区间上存在$n$阶连续导函数，可以使用柯西中值定理</font>。  </p>
<p>上面公式称为带有拉格朗日型余项的泰勒公式，当取$x_0 = 0$时，称下式<br>$$<br>f(x) = f(0) + f^{\prime}(0)x + \frac{f^{\prime\prime}(0)}{2!}x^2 + \cdots + \frac{f^{(n)}(0)}{n!}x^n + \frac{f^{(n + 1)}(\theta x)}{(n + 1)!}x^{n + 1} \\<br>(0 &lt; \theta &lt; 1)<br>$$</p>
<p>为带有拉格朗日型余项的麦克劳林公式。  </p>
<p><strong>下面列出一些常用的带有拉格朗日型余项的麦克劳林公式：</strong></p>
<ol>
<li><p>$$<br>e^x = 1 + x + \frac{x^2}{2!} + \cdots + \frac{x^n}{n!} + \frac{e^{\theta x}}{(n + 1)!}x^{n + 1}, \ 0 &lt; \theta &lt; 1, \ x \in (-\infty, +\infty).<br>$$</p>
</li>
<li><p>$$<br>\sin x = x - \frac{x^3}{3!} + \frac{x^5}{5!} + \cdots + (-1)^{m - 1}\frac{x^{2m - 1}}{(2m - 1)!} + (-1)^m \frac{\cos \theta x}{(2m + 1)!}x^{2m + 1}, \\<br>0 &lt; \theta &lt; 1, \ x \in (-\infty, +\infty).<br>$$</p>
</li>
<li><p>$$<br>\cos x = 1 - \frac{x^2}{2!} + \frac{x^4}{4!} + \cdots + (-1)^m \frac{x^{2m}}{(2m)!} + (-1)^{m + 1}\frac{\cos \theta x}{(2m + 2)!}x^{2m + 2}, \\<br>0 &lt; \theta &lt; 1, \ x \in (-\infty, +\infty).<br>$$</p>
</li>
<li><p>$$<br>\ln(1 + x) = x - \frac{x^2}{2} + \frac{x^3}{3} + \cdots + (-1)^{n - 1}\frac{x^n}{n} + (-1)^n \frac{x^{n + 1}}{(n + 1)(1 + \theta x)^{n + 1}}, \\<br>0 &lt; \theta &lt; 1, \ x &gt; -1.<br>$$</p>
</li>
<li><p>$$<br>(1 + x)^{\alpha} = 1 + \alpha x + \frac{\alpha(\alpha - 1)}{2!}x^2 + \cdots + \frac{\alpha(\alpha - 1) \cdots (\alpha - n + 1)}{n!}x^n + \\<br>\frac{\alpha(\alpha - 1)\cdots(\alpha - n)}{(n + 1)!}(1 + \theta x)^{\alpha - n - 1}x^{n + 1}, \  0 &lt; \theta &lt; 1, \ x &gt; -1.<br>$$</p>
</li>
<li><p>$$<br>\frac{1}{1 - x} = 1 + x + x^2 + \cdots + x^n + \frac{x^{n + 1}}{(1 - \theta x)^{n + 2}}, \ 0 &lt; \theta &lt; 1, \ |x| &lt; 1.<br>$$</p>
</li>
</ol>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>taylor&#39;s formula</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow 分布式简单介绍</title>
    <url>/2020/11/06/tensorflow-distribution/</url>
    <content><![CDATA[<p>TensorFlow 能够方便的进行深度学习实践，特别是拥有多GPU的服务器或拥有多台GPU服务器时，如何使用 TensorFlow 进行快速训练，节约宝贵时间呢，下面介绍 TensorFlow 给出的分布式训练方法。</p>
<a id="more"></a>

<h1 id="单台服务器多GPU情况下"><a href="#单台服务器多GPU情况下" class="headerlink" title="单台服务器多GPU情况下"></a>单台服务器多GPU情况下</h1><p>对于单台服务器下有多个GPU，TensorFlow 给出了镜像分布式策略 tensorflow.distribute.MirroredStrategy ，具体的使用是只需要实例化一个 MirroredStrategy 策略 （strategy = tensorflow.distribute.MirroredStrategy()），并把模型构建代码放置在 strategy.scope() 下就可以。</p>
<p>注意，在该策略下，可以指定参与计算的GPU，方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定计算的GPU为0,1</span></span><br><span class="line">strategy = tensorflow.distribute.MirroredStrategy(devices=[<span class="string">&quot;/gpu:0&quot;</span>, <span class="string">&quot;/gpu:1&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>使用该策略进行模型 MobileNetV2  训练：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 TensorFlow: pip install tensorflow</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装数据集工具: pip install tensorflow-datasets</span></span><br><span class="line"><span class="keyword">import</span> tensorflow_datasets <span class="keyword">as</span> tfds</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定周期数和每个GPU上的批数据大小</span></span><br><span class="line">num_epochs = <span class="number">5</span></span><br><span class="line">batch_size_per_replica = <span class="number">64</span></span><br><span class="line">learning_rate = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化镜像分布式策略</span></span><br><span class="line">strategy = tf.distribute.MirroredStrategy()</span><br><span class="line">print(<span class="string">&quot;Number of devices: %d&quot;</span> % strategy.num_replicas_in_sync)</span><br><span class="line"><span class="comment"># 模型总的批数量两为每个GPU的总和</span></span><br><span class="line">batch_size = batch_size_per_replica * strategy.num_replicas_in_sync</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预处理数据集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize</span>(<span class="params">image, label</span>):</span></span><br><span class="line">    image = tf.image.resize(image, [<span class="number">224</span>, <span class="number">224</span>]) / <span class="number">255.0</span></span><br><span class="line">    <span class="keyword">return</span> image, label</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据集</span></span><br><span class="line">dataset = tfds.load(<span class="string">&quot;cats_vs_dogs&quot;</span>, split=tfds.Split.TRAIN, as_supervised=<span class="literal">True</span>)</span><br><span class="line">dataset = dataset.map(resize).shuffle(<span class="number">1024</span>).batch(batch_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把模型构建和编译放在镜像分布式策略下</span></span><br><span class="line"><span class="keyword">with</span> strategy.scope():</span><br><span class="line">    model = tf.keras.applications.MobileNetV2(weights=<span class="literal">None</span>, classes=<span class="number">2</span>)</span><br><span class="line">    model.compile(</span><br><span class="line">        optimizer=tf.keras.optimizers.Adam(learning_rate=learning_rate),</span><br><span class="line">        loss=tf.keras.losses.sparse_categorical_crossentropy,</span><br><span class="line">        metrics=[tf.keras.metrics.sparse_categorical_accuracy],</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行模型训练</span></span><br><span class="line">model.fit(dataset, epochs=num_epochs)</span><br></pre></td></tr></table></figure>

<p>注意，MirroredStrategy 的步骤如下：</p>
<ul>
<li>训练开始前，该策略在所有 N 个计算设备上均各复制一份完整的模型；</li>
<li>每次训练传入一个批次的数据时，将数据分成 N 份，分别传入 N 个计算设备（即数据并行）；</li>
<li>N 个计算设备使用本地变量（镜像变量）分别计算自己所获得的部分数据的梯度；</li>
<li>使用分布式计算的 All-reduce 操作，在计算设备间高效交换梯度数据并进行求和，使得最终每个设备都有了所有设备的梯度之和；</li>
<li>使用梯度求和的结果更新本地变量（镜像变量）；</li>
<li>当所有设备均更新本地变量后，进行下一轮训练（即该并行策略是同步的）。</li>
</ul>
<p>默认情况下，TensorFlow 中的 MirroredStrategy 策略使用 NVIDIA NCCL 进行 All-reduce (cross_device_ops=tf.distribute.HierarchicalCopyAllReduce())操作。除此之外，还有 tf.distribute.HierarchicalCopyAllReduce(), tf.distribute.ReductionToOneDevice(). devices=[“/gpu:0”, “/gpu:1”]，指定特定的GPU，默认是所有GPU同时使用。一种个性化策略如下：（更多参考 <a href="https://www.tensorflow.org/guide/distributed_training">TensorFlow 官网</a>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">strategy = tf.distribute.MirroredStrategy(devices=[<span class="string">&quot;/gpu:0&quot;</span>, <span class="string">&quot;/gpu:1&quot;</span>], cross_device_ops=tf.distribute.HierarchicalCopyAllReduce)</span><br></pre></td></tr></table></figure>

<p> 通常，当机器上GPU性能持平时，训练时间和GPU数量近似反比。</p>
<h1 id="多台服务器情况下"><a href="#多台服务器情况下" class="headerlink" title="多台服务器情况下"></a>多台服务器情况下</h1><p>对于多台服务器，TensorFlow 给出了 MultiWorkerMirroredStrategy，同时因为需要多服务器间通信，因此还需要其他的设置。主要是设置环境变量：TF_CONFIG，具体如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.environ[<span class="string">&quot;TF_CONFIG&quot;</span>] = json.dumps(&#123;</span><br><span class="line">    <span class="string">&quot;cluster&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;worker&quot;</span>: [<span class="string">&quot;host1:port&quot;</span>, <span class="string">&quot;host2:port&quot;</span>, <span class="string">&quot;host3:port&quot;</span>],</span><br><span class="line">        <span class="string">&quot;ps&quot;</span>: [<span class="string">&quot;host4:port&quot;</span>, <span class="string">&quot;host5:port&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">   <span class="string">&quot;task&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;worker&quot;</span>, <span class="string">&quot;index&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其中，cluster 表示服务器，里面包含 worker(用于计算梯度) 和 ps(Parameter Server，用于更新参数)，分别用IP地址和端口指定。task 指定运行的服务器，不同服务器上代码里的 task index 不同。其中 index 指明该服务器的角色，如上面试例代码中 task index = 1，表示 worker 里的 host2:port. 除此之外，多服务器还需要注意防火墙的配置，最好关闭防火墙。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.distribute.experimental.MultiWorkerMirroredStrategy(</span><br><span class="line">    communication=tf.distribute.experimental.CollectiveCommunication.AUTO,</span><br><span class="line">    cluster_resolver=<span class="literal">None</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p> communication 一共有三种方法可以选择，分别是 AUTO，RING 和 NCCL，默认是 AUTO.</p>
<p>实际运行时，服务器的代码都是一样的，除了TF_CONFIG 中的 task 配置，当在一台机器上运行代码后，它会进入监听状态，当所有服务器通信成功后，会自动进行训练。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> tensorflow_datasets <span class="keyword">as</span> tfds</span><br><span class="line"></span><br><span class="line">num_epochs = <span class="number">5</span></span><br><span class="line">batch_size_per_replica = <span class="number">64</span></span><br><span class="line">learning_rate = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line">num_workers = <span class="number">3</span></span><br><span class="line">os.environ[<span class="string">&quot;TF_CONFIG&quot;</span>] = json.dumps(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;cluster&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;worker&quot;</span>: [<span class="string">&quot;localhost:20000&quot;</span>, <span class="string">&quot;localhost:20001&quot;</span>],</span><br><span class="line">            <span class="string">&quot;ps&quot;</span>: [<span class="string">&quot;localhost:20002&quot;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;task&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;worker&quot;</span>, <span class="string">&quot;index&quot;</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">strategy = tf.distribute.experimental.MultiWorkerMirroredStrategy()</span><br><span class="line">batch_size = batch_size_per_replica * num_workers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize</span>(<span class="params">image, label</span>):</span></span><br><span class="line">    image = tf.image.resize(image, [<span class="number">224</span>, <span class="number">224</span>]) / <span class="number">255.0</span></span><br><span class="line">    <span class="keyword">return</span> image, label</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dataset = tfds.load(<span class="string">&quot;cats_vs_dogs&quot;</span>, split=tfds.Split.TRAIN, as_supervised=<span class="literal">True</span>)</span><br><span class="line">dataset = dataset.map(resize).shuffle(<span class="number">1024</span>).batch(batch_size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> strategy.scope():</span><br><span class="line">    model = tf.keras.applications.MobileNetV2(weights=<span class="literal">None</span>, classes=<span class="number">2</span>)</span><br><span class="line">    model.compile(</span><br><span class="line">        optimizer=tf.keras.optimizers.Adam(learning_rate=learning_rate),</span><br><span class="line">        loss=tf.keras.losses.sparse_categorical_crossentropy,</span><br><span class="line">        metrics=[tf.keras.metrics.sparse_categorical_accuracy],</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">model.fit(dataset, epochs=num_epochs)</span><br></pre></td></tr></table></figure>

<p>可以对比单服务器多GPU情况，代码只是稍微进行改动。训练效率也能达到上面多GPU的情况。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><p><a href="https://tf.wiki/zh_hans/appendix/distributed.html">TensorFlow 分布式训练</a></p>
</li>
<li><p><a href="https://tf.wiki/en/appendix/distributed.html">Distributed training with TensorFlow</a></p>
</li>
<li><p><a href="https://www.tensorflow.org/guide/distributed_training#multiworkermirroredstrategy">TensorFlow: Distributed training with TensorFlow</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/35083779">分布式TensorFlow入门教程</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>research</category>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>dl</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>终端代理方法</title>
    <url>/2021/04/02/terminal-proxy-method/</url>
    <content><![CDATA[<p>Linux 系统上终端的使用非常频繁，当需要使用终端进行快速下载软件时（如 conda, pip 命令），对终端进行代理显得非常重要。本篇以 Debian 类系统和 Mac 为例。</p>
<a id="more"></a>

<h1 id="proxychains"><a href="#proxychains" class="headerlink" title="proxychains"></a>proxychains</h1><p>安装和配置如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt-get install proxychains</span><br><span class="line">sudo vim /etc/proxychains.conf</span><br><span class="line"><span class="comment"># 在最后的 ProxyList 下面设置：（根据个人的参数进行）</span></span><br><span class="line"></span><br><span class="line">socks5    127.0.0.1    1080</span><br></pre></td></tr></table></figure>

<p>使用方法如下（在需要的命令前加上 <code>proxychains</code> 即可）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxychains curl cip.cc</span><br></pre></td></tr></table></figure>

<h1 id="privoxy"><a href="#privoxy" class="headerlink" title="privoxy"></a><strong>privoxy</strong></h1><p>安装和配置如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Debian 安装方法</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install privoxy</span><br><span class="line">sudo vim /etc/privoxy/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mac 安装方法</span></span><br><span class="line">brew search privoxy</span><br><span class="line">brew install privoxy</span><br><span class="line">sudo vim /usr/<span class="built_in">local</span>/etc/privoxy/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改如下，注意最后面的点号</span></span><br><span class="line">listen-address  127.0.0.1:8118</span><br><span class="line">listen-address  [::1]:8118</span><br><span class="line"></span><br><span class="line">forward-socks5t   /               127.0.0.1:1080 .</span><br><span class="line"></span><br><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="built_in">alias</span> setproxy=<span class="string">&quot;export ALL_PROXY=127.0.0.1:8118&quot;</span></span><br><span class="line"><span class="built_in">alias</span> unsetproxy=<span class="string">&quot;unset ALL_PROXY&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用方法如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Debian 启动</span></span><br><span class="line">sudo /etc/init.d/privoxy start</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mac 启动</span></span><br><span class="line">brew services start privoxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使环境变量生效</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启</span></span><br><span class="line">setproxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测</span></span><br><span class="line">curl cip.cc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">unsetproxy</span><br></pre></td></tr></table></figure>

<p>对终端进行代理设置后，就可以使用 conda 或 pip 从官方源下载最新的包了，而不用使用更新较迟的国内源。</p>
]]></content>
      <categories>
        <category>technology</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>proxy</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转曲面的面积</title>
    <url>/2021/11/07/the-area-of-the-surface-of-revolution/</url>
    <content><![CDATA[<p>定积分的所有应用一般总可以安装“分割, 近似求和, 去极限”三个步骤导出所求量的积分形式. 但为简便实用起见, 也常采用本篇介绍的“微元法”. 其实在求旋转体的体积时我们采用微小区间上柱体近似旋转体体积, 但是在求旋转曲面的面积时却不能用旋转体的侧面积近似旋转曲面的侧面积. 就像求弧长时需要用微小区间的弦长近似弧长, 不能用弦长直角边近似一样, 求旋转曲面的表面积不能用圆柱侧面积需要用圆台侧面积近似.</p>
 <a id="more"></a>

<h1 id="微元法"><a href="#微元法" class="headerlink" title="微元法"></a>微元法</h1><p>在上一篇中我们知道, 若令 $\Phi(x) = \int^x_a f(t) \mathrm{d}t$, 则当 $f$ 为连续函数时, $\Phi^{\prime}(x) = f(x)$, 或 $\mathrm{d}\Phi = f(x)\mathrm{d}x$, 且<br>$$<br>\Phi(a) = 0, \Phi(b) = \int^b_a f(x) \mathrm{d}x.<br>$$<br>现在问题恰好反过来: 如果所求量 $\Phi$ 是某区间 $[a, x]$ 上的,或者说它是该区间端点 $x$ 的函数, 即 $\Phi = \Phi(x), x\in [a, b]$, 而且当 $x = b$ 时, $\Phi(b)$ 适为最终所求的值.</p>
<p>在任意小区间 $[x, x + \Delta x] \subset [a, b]$ 上, 恰当选取 $\Phi$ 的微小增量 $\Delta \Phi$ 的近似可求量 $\Delta^{\prime} \Phi$ (所谓近似可求量是指用来近似代替 $\Delta \Phi$ 的有确定意义且可以计算的量). 若能把 $\Delta^{\prime} \Phi$ 近似表示为 $\Delta x$ 的线性形式<br>$$<br>\Delta^{\prime} \Phi \approx f(x) \Delta x,<br>$$<br>其中 $f$ 为某一连续函数,而且当 $\Delta x \to 0$ 时, $\Delta^{\prime} \Phi - f(x)\Delta x = o(\Delta x)$, 则记<br>$$<br>\mathrm{d} \Phi = f(x) \mathrm{d}x,<br>$$<br>那么只有定积分 $\int^b_a f(x) \mathrm{d}x$ 计算出来,就是该问题所求的结果.</p>
<p>上述方法通常称为 <strong>微元法</strong>. 在采用微元法时, 必须注意如下三点:</p>
<ul>
<li>所求量 $\Phi$ 关于分布区间必须代数可加;</li>
<li>微元法的关键是正确给出 $\Delta \Phi$ 的近似可求量 $\Delta^{\prime} \Phi$. 一般来说, 近似可求量的选取不唯一;</li>
<li>当我们将 $\Delta^{\prime}\Phi$ 用线性形式 $f(x) \Delta x$ 代替时, 要严格检验 $\Delta^{\prime} \Phi - f(x) \Delta x$ 是否为 $\Delta x$ 的高阶无穷小量, 以保证其对应的积分和的极限是相等的.</li>
</ul>
<h1 id="旋转曲面的面积"><a href="#旋转曲面的面积" class="headerlink" title="旋转曲面的面积"></a>旋转曲面的面积</h1><p>设平面光滑曲线 $C$ 的方程为<br>$$<br>y = f(x), x \in [a, b] \ (\text{不妨设} f(x) \geq 0).<br>$$<br>这段曲线绕 $x$ 轴旋转一周得到旋转曲面.</p>
<p>通过 $x$ 轴上点 $x$ 与 $x + \Delta x$ 分别作垂直于 $x$ 轴的平面,它们在旋转曲面上截下一条夹在两个圆形截线间的狭带. 当 $\Delta x$ 很小时,此狭带的面积 $\Delta S$ 近似于由这两个圆所确定的圆台的侧面积 $\Delta^{\prime} S$, 即<br>$$<br>\Delta^{\prime} S = \pi [f(x) + f(x + \Delta x)] \sqrt{\Delta x^2 + \Delta y^2} \\<br>= \pi [2f(x) + \Delta y] \sqrt{1 + (\frac{\Delta y}{\Delta x})^2} \Delta x,<br>$$<br>(假设圆柱高$h$, 上下圆面半径$r$, 则圆柱侧面积$S = 2 \pi r h$; 圆台斜边长 $s$, 上圆面半径 $r_1$, 下圆面半径 $r_2$, 则圆台侧面积 $S = 2 \pi \frac{r_1 + r_2}{2} s = \pi (r_1 + r_2) s$)</p>
<p>其中 $\Delta y = f(x + \Delta x) - f(x)$. 由于<br>$$<br>\lim_{\Delta x \to 0} \Delta y = 0, \\<br>\lim_{\Delta x \to 0} \sqrt{1 + (\frac{\Delta y}{\Delta x})^2} = \sqrt{1 + {f^{ \prime } }^2(x)},<br>$$<br>因此,由 $f^{\prime}(x)$ 的连续性可以保证<br>$$<br>\pi [2f(x) + \Delta y]\sqrt{1 + (\frac{\Delta y}{\Delta x})^2} \Delta x - 2 \pi f(x) \sqrt{1 + {f^{ \prime } }^2(x)} \Delta x = o(\Delta x).<br>$$<br>所以得到<br>$$<br>\Delta^{\prime} S \approx 2 \pi f(x) \sqrt{1 + {f^{ \prime } }^2 (x)} \Delta x,<br>$$</p>
<p>$$<br>\mathrm{d} S = 2 \pi f(x) \sqrt{1 + {f^{\prime } }^2} \mathrm{d}x,<br>$$</p>
<p>$$<br>S = 2 \pi \int^b_a f(x) \sqrt{1 + {f^{\prime} }^2} \mathrm{d}x.<br>$$</p>
<h2 id="参数方程"><a href="#参数方程" class="headerlink" title="参数方程"></a>参数方程</h2><p>如果光滑曲线 $C$​​ 由参数方程<br>$$<br>x = x(t), y = y(t), t \in [\alpha, \beta]<br>$$<br>给出, 且 $y(t) \geq 0$, 那么由弧微分知识知道曲线 $C$ 绕 $x$ 轴旋转所得旋转曲面的面积为<br>$$<br>S = 2 \pi \int^{\beta}_{\alpha} y(t) \sqrt{ {x^{\prime} }^2(t) + {y^{\prime} }^2(t)} \mathrm{d}t.<br>$$</p>
<h2 id="极坐标方程"><a href="#极坐标方程" class="headerlink" title="极坐标方程"></a>极坐标方程</h2><p>如果光滑曲线 $C$​ 由极坐标方程<br>$$<br>r = r(\theta), a \leq \theta \leq \alpha ([\alpha, \beta] \subset [0, \pi], r(\theta) \geq 0)<br>$$<br>给出, 则由曲线 $C$ 绕极轴旋转所得旋转曲面的面积为<br>$$<br>S = 2 \pi \int^{\beta}_{\alpha} r \sin{\theta} \sqrt{r^2 + {r^{\prime} }^2} \mathrm{d} \theta.<br>$$</p>
]]></content>
      <categories>
        <category>maths</category>
        <category>mathematical analysis</category>
      </categories>
      <tags>
        <tag>maths</tag>
        <tag>definite integral</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer</title>
    <url>/2021/11/05/transformer-concept/</url>
    <content><![CDATA[<p>Transformer 是一种 Seq2seq 模型，即 input a sequence, output a sequence. 应用包括语音识别（输入语音，输出文本）、机器翻译（输入一种语言文本，输出另一种语言文本）、语言翻译（输入一种语言的语音，输出是另一种语言的文本，如字幕）、语音合成（输入一种语言文本，输出另一种语言的语音）、聊天机器人（对话）等，这些都可以看作 QA（Question &amp; Answering）问题，都可以使用 Seq2seq 模型解决。</p>
<a id="more"></a>

<h1 id="Seq2seq"><a href="#Seq2seq" class="headerlink" title="Seq2seq"></a>Seq2seq</h1><p>一般的 Seq2seq 模型的一般框架</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">input sequence -&gt; Encoder -&gt; Decoder -&gt; output sequence</span><br></pre></td></tr></table></figure>

<p>如 Transformer 就是该模型的一种。李宏毅老师的课件：<a href="https://speech.ee.ntu.edu.tw/~hylee/ml/ml2021-course-data/seq2seq_v9.pdf">Transformer</a></p>
<h1 id="Self-attention"><a href="#Self-attention" class="headerlink" title="Self-attention"></a>Self-attention</h1><p>self-attention 中文是自注意力，它对于输入的一列向量输出相同数量的一列向量。</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/transformer/self-attention.png"></p>
<p>如上图所示，$a^i, i = 1, 2, 3, 4$ 为输入向量（如词嵌入向量），$q^i, i = 1, 2, 3, 4$ 为 query，$k^i, i = 1, 2, 3, 4$ 为 key，$v^i, i=1, 2, 3, 4$ 为 value，后三者分别有输入向量 $a^i$ 得到<br>$$<br>q^i = W^q a^i<br>$$</p>
<p>$$<br>k^i = W^k a^i<br>$$</p>
<p>$$<br>v^i = W^v a^i<br>$$</p>
<p>这里，矩阵 $W^q, W^k, W^v$ 是矩阵，但不一定是方阵，一般是行大于列。行数代表输入向量的维数，列代表乘积后输出的向量 $q^i, k^i, v^i$ 维数。</p>
<p>而 $\alpha_{2, 1}$ 是由 $q^2$ 与 $k^1$ 做 dot product 而得到的，其他依次类推 $\alpha_{2,2}, \alpha_{2, 3}, \alpha_{2, 4}$. 然后，通过 Softmax 激活函数，得到  $\alpha^{\prime}_{2, i}, i = 1, 2, 3, 4$ 作为系数与 $v^i, i = 1, 2, 3, 4$ 相乘得到 $b^2 = \sum_i \alpha^{\prime}_{2, i} v^i$，对于其他 $b^1, b^3, b^4$ 依次类推。</p>
<p>其实，Self-attention 能够利用矩阵简洁表示如下，这也是其并行化计算的原因</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/transformer/self-attention-matrix.png"></p>
<p>这里 $I = (a^i), i = 1, 2, 3, 4$ 为输入向量列，$W^q, W^k, W^v$ 为需要学习的参数矩阵，$Q, K, V$ 分别为 query, key, value 矩阵，$A$ 为 attention 系数，$A^{\prime}$ 为经过 Sigmoid 归一化后的 attention matrix. $O = (b^i), i = 1, 2, 3, 4$ 为 self-attention 输出的向量列。</p>
<p>在实际使用中，常常采用 multi-head self-attention，如下图所示</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/transformer/multi-head-self-attention.png"></p>
<p>与上面的 self-attention 类似，先通过 $W^q, W^k, W^v$ 得到 $q^i, k^i, v^i$，然后再分别经过 2 个（这里例子 multi-head 为 2 头的）矩阵得到 2 个<br>$$<br>q^{i, 1} = W^{q, 1}q^i, q^{i,2} = W^{q,2}q^i<br>$$</p>
<p>$$<br>k^{i, 1} = W^{k, 1}k^i, k^{i,2} = W^{k,2}k^i<br>$$</p>
<p>$$<br>v^{i, 1} = W^{v, 1}v^i, v^{i,2} = W^{v,2}v^i<br>$$</p>
<p>那计算 $b^{i,2}$ 时，只需要 $q^{i,2}$ 与 $k^{j,2}, j = 1, 2, 3, 4$ 相乘后然后经过 Sigmoid 归一化后得到 attention 系数，然后组合 $v^{i,2}$ 相乘得到<br>$$<br>b^{i,2} = \sum_j \alpha^{\prime}_{i, 2, j} v^{j, 2}<br>$$<br>注意，这里只需要计算相同头（如 $(q^{i,1}, k^{i,1}, v^{i,1}), (q^{j,1}, k^{j,1}, v^{j,1})$，相同标号 1）的值，计算方法同上面的 selft-attention.</p>
<p>最后，$b^i = W^0 (b^{i,1}, b^{i,2})^T$ .</p>
<p>这样，就从 $a^i, i = 1, 2, 3, 4$ 得到 $b^i, i = 1, 2, 3, 4$.</p>
<p>CNN 和 Self-attention 的关系：<a href="https://arxiv.org/pdf/1911.03584.pdf">On The Relationship Between Self-attention And Convolutional Layers</a></p>
<h1 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h1><p>输入一排向量，输出另一排同样长度的向量。在 Transformer 中的 Encoder 里用的是 <a href="https://speech.ee.ntu.edu.tw/~hylee/ml/ml2021-course-data/self_v7.pdf">Self-attention</a>.</p>
<p> BERT 是仅仅使用 Transformer 的 Encoder 构建起来的。</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/transformer/encoder.png"></p>
<p>Encoder 是由 $N$ 个 self-attention 模块线性拼接而成，输入向量列增加了位置信息。</p>
<h1 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h1><p>输入是 Encoder 的输出向量和一个 special token （标识开始 BEGIN）。</p>
<p> GPT-2, GPT-3 是仅仅使用 Transformer 的 Decoder 构建起来的，属于 Unsupervised Pre-training model。 在 300 billion tokens of text 上训练得到，它的目标（能够做）Predict the next word.</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/transformer/decoder.png"></p>
<p>Decoder 与 Encoder  的区别是调整为 masked multi-head attention，并在中间增加 cross attention，引入 encoder 的信息。而 masked multi-head attention 是因为后面的单词或向量还未得到，不能像 encoder 里的 multi-head attention 那样使用全面的向量的信息，只能使用已经得到的向量的信息。</p>
<p>在 cross attention 中，对于 decoder 中 masked multi-head attenion 得到的每一个 $q$ 分别于 encoder 中的 $k^i = W^k a^i, v^i = W^v a^i$ 做 self-attention 操作得到 $v$，如图所示</p>
<p><img src="https://raw.githubusercontent.com/xujinzh/archive/master/images/transformer/cross-attention.png"></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>TensorFlow: <a href="https://github.com/tensorflow/tensor2tensor">tensor2tensor</a></p>
<p>pyTorch: <a href="http://nlp.seas.harvard.edu/2018/04/03/attention.html">The Annotated Transformer</a></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://www.seldon.io/what-is-covariate-shift/">What is Covariate Shift?</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/48508221">详解Transformer （Attention Is All You Need）</a></li>
<li><a href="http://jalammar.github.io/illustrated-transformer/">The Illustrated Transformer</a></li>
</ol>
]]></content>
      <categories>
        <category>research</category>
        <category>object tracking</category>
      </categories>
      <tags>
        <tag>dl</tag>
        <tag>cv</tag>
        <tag>transformer</tag>
        <tag>nlp</tag>
        <tag>ot</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian or Ubuntu 修改主机名</title>
    <url>/2019/12/20/ubuntu-change-hostname/</url>
    <content><![CDATA[<p>首先，运行命令查看主机名</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hostnamectl</span><br></pre></td></tr></table></figure>

<blockquote class="wp-block-quote"><p>Static hostname: debian-virtualbox<br>          Icon name: computer-vm<br>            Chassis: vm<br>         Machine ID: aaaaaaaaaaaaaaaaaaaaaaaa<br>            Boot ID: bbbbbbbbbbbbbbbbbbbb<br>     Virtualization: oracle<br>   Operating System: Debian GNU/Linux 10 (buster)<br>             Kernel: Linux 4.19.0-6-amd64<br>       Architecture: x86-64</p></blockquote>
<p>其次，运行如下命令修改主机名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hostnamectl <span class="built_in">set</span>-hostname debian</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure>

<p>修改 /etc/hosts 中的 debian-virtualbox 主机名为 debian，重启一个 terminal，发现已经修改成功。</p>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>debian</tag>
        <tag>hostname</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 安装杀毒软件 clamav</title>
    <url>/2019/12/20/ubuntu-install-clamav/</url>
    <content><![CDATA[<p>有些时候，基于某些特殊要求需要给 Ubuntu 安装杀毒软件，这里介绍一个非常有效的杀毒软件：clamav，它还有 GUI 界面 clamtk.</p>
<p>命令行安装杀毒软件：</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line">sudo install clamav clamtk</span><br></pre></td></tr></table></figure>

<p>使用 clamav 扫描某个文件夹下的所有文件，并把扫描结果写到 antivirus.history文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo clamscan -r /home/jayzonxu/Downloads | tee antivirus.history</span><br></pre></td></tr></table></figure>

<p>如果不喜欢使用命令行，也可以使用 GUI 界面的 clamtk;</p>
<p>更多有关 clamav 请参看其中文<a rel="noreferrer noopener" aria-label="wiki（在新窗口打开）" href="https://wiki.ubuntu.org.cn/ClamAV" target="_blank">wiki</a>.</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>clamav</tag>
      </tags>
  </entry>
  <entry>
    <title>如何查询 Ubuntu 系统安装时间</title>
    <url>/2019/12/20/ubuntu-installation-time/</url>
    <content><![CDATA[<p>为了某些目的，有时候我们需要知道 Ubuntu 系统的安装时间，那么如何通过terminal 查询系统安装时间呢，这里给出两种查询方法：</p>
<p>第一种方法：运行如下命令直接查询日志文件获取系统安装时间：</p>
<ul><li>ls -ld /var/log/installer</li></ul>
<p>第二种方法：</p>
<p>1、首先，运行如下命令查询系统有哪些分区</p>
<ul><li>ls /dev | grep sd</li></ul>
<p>2、然后，运行如下命令查询系统盘格式化时间，就是系统安装时间</p>
<ul><li>sudo dumpe2fs /dev/sda | grep 'Filesystem created'</li></ul>
<p>在第一步种，可能有些是 /dev/sdb，但大多数是 /dev/sda</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>debian</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Ubuntu 上挂载 ISO 文件</title>
    <url>/2021/07/27/ubuntu-mount-iso/</url>
    <content><![CDATA[<p>我这里需要安装 MATLAB，但是下载的软件是 ISO 文件，无法直接读取，需要挂在到 Ubuntu 上才能读取，因此，使用如下方法挂载和卸载 ISO 文件</p>
<a id="more"></a>

<h1 id="创建挂在点文件夹"><a href="#创建挂在点文件夹" class="headerlink" title="创建挂在点文件夹"></a>创建挂在点文件夹</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir /media/iso</span><br></pre></td></tr></table></figure>

<h1 id="挂载-ISO-文件到挂载点"><a href="#挂载-ISO-文件到挂载点" class="headerlink" title="挂载 ISO 文件到挂载点"></a>挂载 ISO 文件到挂载点</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount -o loop /home/jinzhongxu/Matlab98R2020a_Lin64.iso /media/jinzhongxu</span><br></pre></td></tr></table></figure>

<h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo umount /media/iso</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://askubuntu.com/questions/164227/how-to-mount-an-iso-file">How to mount an ISO file?</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>iso</tag>
        <tag>mount</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu上设置Pycharm快捷启动</title>
    <url>/2020/02/22/ubuntu-pycharm-desktop-ico/</url>
    <content><![CDATA[<p>在使用 Ubuntu 进行 python 编程时，Pycharm 是一个非常方便的开发工具，但是，首次从官网下载并安装 Pycharm时，必须使用命令行运行 Pycharm。这在下次使用或启动 Pycharm 时非常不方便。最好能够在状态栏上或启动界面上能够保留或搜索到 Pycharm 图标。如何设置呢，按照如下步骤即可实现。</p>
<a id="more"></a>

<h1 id="1-首先在命令行第一次启动Pycharm"><a href="#1-首先在命令行第一次启动Pycharm" class="headerlink" title="1. 首先在命令行第一次启动Pycharm"></a>1. 首先在命令行第一次启动Pycharm</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./pycharm.sh</span><br></pre></td></tr></table></figure>

<h1 id="2-将Pycharm添加到桌面"><a href="#2-将Pycharm添加到桌面" class="headerlink" title="2. 将Pycharm添加到桌面"></a>2. 将Pycharm添加到桌面</h1><ol>
<li>在 Pycharm 中找到 Tools</li>
<li>在 Tools 中点击 Create Desktop Entry</li>
</ol>
<p>到此，即实现了启动界面上搜索到 Pycharm 图标。</p>
<h1 id="3-将Pycharm添加到状态栏"><a href="#3-将Pycharm添加到状态栏" class="headerlink" title="3. 将Pycharm添加到状态栏"></a>3. 将Pycharm添加到状态栏</h1><ol>
<li>从启动界面，搜索 Pycharm 图标，并点击启动</li>
<li>在状态栏点击右键，选择 Add to Favorates</li>
</ol>
<p>到此，即实现了在状态栏上保留 Pycharm 启动图标</p>
<p>如果喜欢在终端运行Pycharm来启动，那么，可以将 pycharm.sh 连接到环境变量可以搜索的地方，方便启动，具体的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ln -s /home/jayzonxu/Documents/pycharm-community-2019.3.3/bin/pycharm.sh /usr/bin/pycharm</span><br></pre></td></tr></table></figure>

<p>在终端中，输入 pycharm，即可启动</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 包管理工具 snap</title>
    <url>/2019/12/20/ubuntu-snap/</url>
    <content><![CDATA[<p>在 Ubuntu 系统上，命令行利用 apt 作为包管理工具已经是非常不错的，但是，有些包，比如 youtube-dl 却不能很好的安装和更新，但是，通过 snap 我们可以非常完美的解决这类包的安装与管理。</p>
<p>利用 apt 安装 snap，命令如下</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install snapd</span><br></pre></td></tr></table></figure>

<p>查找需要安装的包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap find search_text</span><br></pre></td></tr></table></figure>

<p>安装包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo snap install package</span><br></pre></td></tr></table></figure>

<p>查看安装了哪些包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap list</span><br></pre></td></tr></table></figure>

<p>查看安装的包的历史</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap changes</span><br></pre></td></tr></table></figure>

<p>更新安装的包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo snap refresh package</span><br></pre></td></tr></table></figure>

<p>也可以查看更新列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo snap refresh --list</span><br></pre></td></tr></table></figure>

<p>返回包的更新到上一个版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo snap revert package</span><br></pre></td></tr></table></figure>

<p>卸载包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo snap remove package</span><br></pre></td></tr></table></figure>

<p>通过 snap下载离线 app</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap download package_name</span><br></pre></td></tr></table></figure>

<p>安装app</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap ack package_name</span><br><span class="line">snap install package_name</span><br></pre></td></tr></table></figure>

<p>如果忘记 sudo，导致命令不能执行，可以运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo !!</span><br></pre></td></tr></table></figure>

<p>或者，添加 sudo，重新运行上一个命令</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>snap</tag>
      </tags>
  </entry>
  <entry>
    <title>重启Ubuntu后Teamviewer无法连接问题</title>
    <url>/2020/02/22/ubuntu18-teamviewer-not-connect/</url>
    <content><![CDATA[<p>在使用 teamviewer 连接 Ubuntu18.04 桌面系统时，总是出现重启 Ubuntu 系统后，通过 teamviewer 连接不上的问题。但是，当登录上 Ubuntu 系统后，发现可以用 teamviewer 连接。（After reboot, I cannot connect via Teamviewer. Following manual login, Teamviewer is able to connect at the login screen until the next reboot.）</p>
<a id="more"></a>

<p>这是因为，teamviewer 服务需要用户登陆系统后才能打开，因此，可以通过修改配置让 teamviewer 服务自动打开，这样就可以再重启 Ubuntu 系统后，直接用 teamviewer 连接。具体的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/gdm3/custom.conf</span><br></pre></td></tr></table></figure>

<p>把</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">WaylandEnable=false</span><br></pre></td></tr></table></figure>

<p>注销掉</p>
<p>然后，重启系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>

<p>重启 Ubuntu 系统后，就可以使用 teamviewer 进行连接。</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>teamviewer</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习中的欠拟合和过拟合</title>
    <url>/2021/06/18/underfitting-overfitting/</url>
    <content><![CDATA[<p>人类专家在完成某项任务的准确性可以作为深度学习完成同样任务合理目标的参考。由于人类专家人类专家也有犯错的概率，因此，利用他们准备的数据集训练模型，不能期望100%的准确率。在深度学习模型训练中常遇到欠拟合和过拟合，我认为这主要是因为数据量和模型不匹配导致的。当模型简单时，如线性模型、参数量少等，训练数据量需求相对较少；当模型复杂时，如指数、参数量多等，训练数据量需求就会相对较多。</p>
<a id="more"></a>

<h1 id="欠拟合"><a href="#欠拟合" class="headerlink" title="欠拟合"></a>欠拟合</h1><p>当模型的训练误差明显大于理想模型的预期误差时，说明发生了欠拟合。在深度学习中，当模型在训练集上表现不佳时，称模型具有高偏差（bias）。</p>
<h2 id="解决欠拟合"><a href="#解决欠拟合" class="headerlink" title="解决欠拟合"></a>解决欠拟合</h2><p>处理欠拟合模型的最佳方法是尝试更大的神经网络（添加新层或增加现有层中的神经元数量）或对模型进行更长时间的训练。</p>
<ol>
<li><p>更大的神经网络</p>
<p><strong>这是因为欠拟合的神经网络可能不足以捕捉训练数据集中的模式。在这种情况下，添加更多层或增加神经元数量可能有助于解决问题。</strong></p>
</li>
<li><p>更长时间的训练</p>
<p>欠拟合的模型是尚未找到参数最佳值，增加训练时间可能会有帮助。</p>
</li>
</ol>
<h1 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h1><p>当模型在训练集上表现良好，但在使用验证集或测试数据集时无法达到良好的准确性时，就会发生过拟合。这类问题称为高方差（variance），通常意味着模型无法概括训练数据集的见解。</p>
<h2 id="解决过拟合"><a href="#解决过拟合" class="headerlink" title="解决过拟合"></a>解决过拟合</h2><p>过拟合的最佳解决方案是获取更多数据并使用正则化。总结解决过拟合的方法如下：</p>
<ol>
<li>$L_1$ 和 $L_2$ 正则化方法用于以惩罚更复杂模型的方式修改代价函数</li>
<li>Dropout 用于防止模型过分依赖一个输入，因为输入可能会消失</li>
<li>提前停止来防止“记忆”训练样本</li>
<li>数据增强 — 使训练数据集更加多样化</li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://www.mikulskibartosz.name/how-to-deal-with-underfitting-and-overfitting-in-deep-learning/">How to deal with underfitting and overfitting in deep learning</a></li>
</ol>
]]></content>
      <categories>
        <category>research</category>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>dl</tag>
        <tag>ml</tag>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title>手动更新 oh-my-zsh</title>
    <url>/2021/10/08/update-oh-my-zsh/</url>
    <content><![CDATA[<p>我比较喜欢使用 zsh，特别是搭配 <a href="https://ohmyz.sh/">Oh My ZSH</a>，它有很多方便的功能以及各种主题。但它不会自动更新，特别是 Mac 上很少关闭 Terminal 导致oh-my-zsh 不是最新的。下面介绍一种手动更新 oh-my-zsh 的方法。</p>
<a id="more"></a>

<h1 id="手动更新"><a href="#手动更新" class="headerlink" title="手动更新"></a>手动更新</h1><p>使用如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">omz update</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.oh-my-zsh/tools</span><br><span class="line">zsh upgrade.sh</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://blog.digital-craftsman.de/manually-update-oh-my-zsh/">Manually update oh-my-zsh</a></li>
<li><a href="https://futurestud.io/tutorials/how-to-manually-update-oh-my-zsh">How to Manually Update Oh-My-ZSH</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu卸载cuda</title>
    <url>/2020/02/20/uninstall-cuda/</url>
    <content><![CDATA[<p>当使用Ubuntu运行深度学习模型时，有时候会出现一些错误，有可能是因为cuda版本不匹配或较旧导致的，所以需要我们卸载Ubuntu系统安装的cuda驱动，重新安装，下面一些代码是以Ubuntu18.04为例来卸载cuda</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt --purge remove cuda</span><br><span class="line">sudo apt autoremove</span><br><span class="line">sudo apt --purge remove cuda*</span><br></pre></td></tr></table></figure>

<p>有时，还需要进入路径/usr/local，并删除文件夹cuda</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -rf /usr/<span class="built_in">local</span>/cuda*</span><br></pre></td></tr></table></figure>

<p>至此，就完全卸载了cuda。</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>cuda</tag>
      </tags>
  </entry>
  <entry>
    <title>矢量图和位图</title>
    <url>/2019/12/20/vector-bitmap-image/</url>
    <content><![CDATA[<p>矢量图是由线段或曲线来描述图像，同时包含有色彩和位置信息;</p>
<p>位图是由像素点来描述图像，也称为点阵图;</p>
<a id="more"></a>



<h2 id="两者有什么特点："><a href="#两者有什么特点：" class="headerlink" title="两者有什么特点："></a>两者有什么特点：</h2><p>矢量图：可以无限放大或缩小，而不失真，一般体积或占用空间比较小；但，色彩丰富度不如位图；</p>
<p>位图：色彩丰富，但放大后容易不清晰，一般体积比较大</p>
<h2 id="两者常见的格式："><a href="#两者常见的格式：" class="headerlink" title="两者常见的格式："></a>两者常见的格式：</h2><p>矢量图： AdobeIllustrator的 <em>.AI、</em>.EPS和SVG、EMF、AutoCAD的 *.dwg和dxf、Corel DRAW的 *.cdr等；</p>
<p>位图： <em>.bmp、</em>.pcx、*.gif、*.jpg、*.tif、*.png、photoshop的 *.psd等</p>
<h2 id="两者常见使用场景："><a href="#两者常见使用场景：" class="headerlink" title="两者常见使用场景："></a>两者常见使用场景：</h2><p>矢量图：常用于图标、logo、标识等（ SVG适合于浏览器，EPS适合于LaTeX，EMF才适合Word ）</p>
<p>位图：常用于打印或论文印刷（tif格式，虽体积大但基本不损失信息）、网络传播（jpeg格式和gif格式，压缩比高，体积小但损失信息，可用于一般资料保存；png格式，能够透明或半透明图像，比JPEG大但不适宜印刷）</p>
<p>矢量图可以轻松转化为位图，但是位图转化为矢量图需要大量的计算（可通过网站<a href="https://zh.vectormagic.com/" target="_blank" rel="noreferrer noopener" aria-label="Vector Magic（在新窗口打开）">Vector Magic</a> 转换)</p>
<p>参考自<a href="https://zhuanlan.zhihu.com/p/52047447" target="_blank" rel="noreferrer noopener" aria-label="位图与矢量图的区别（在新窗口打开）">位图与矢量图的区别

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>cv</tag>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 快捷键</title>
    <url>/2020/03/17/vim-command/</url>
    <content><![CDATA[<p>Vim 是一个非常好用的软件，更新自vi命令，添加了各种颜色显示，方便编写程序。这里给出一些vim常用的快捷方式。</p>
<p>vim有三种模式：<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong></p>
<a id="more"></a>

<h3 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h3><p>刚进入是的模式。此时，输入的字符为命令。</p>
<ul>
<li><strong>i</strong> 切换到输入模式，以输入字符。</li>
<li><strong>x</strong> 删除当前光标所在处的字符。</li>
<li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li>
</ul>
<h3 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h3><p>输入模式可以进行文字输入。</p>
<ul>
<li><p><strong>字符按键以及Shift组合</strong>，输入字符</p>
</li>
<li><p><strong>ENTER</strong>，回车键，换行</p>
</li>
<li><p><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</p>
</li>
<li><p><strong>DEL</strong>，删除键，删除光标后一个字符</p>
</li>
<li><p><strong>方向键</strong>，在文本中移动光标</p>
</li>
<li><p><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</p>
</li>
<li><p><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</p>
</li>
<li><p><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</p>
<p><strong>ESC</strong>，退出输入模式，切换到命令模式</p>
</li>
</ul>
<h3 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h3><p>在命令模式下，用英文冒号”:”进入底线模式</p>
<ul>
<li><p>q 退出程序</p>
</li>
<li><p>w 保存文件</p>
</li>
<li><p>q! 强制退出不保存</p>
</li>
<li><p>wq 退出并保存文件</p>
<p>按<strong>ESC</strong>键退出底线模式。</p>
</li>
</ul>
<h2 id="vi-vim-按键说明"><a href="#vi-vim-按键说明" class="headerlink" title="vi/vim 按键说明"></a>vi/vim 按键说明</h2><p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p>
<h3 id="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"><a href="#第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等" class="headerlink" title="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"></a>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</h3><table>
<thead>
<tr>
<th align="left">移动光标的方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">h 或 向左箭头键(←)</td>
<td>光标向左移动一个字符</td>
</tr>
<tr>
<td align="left">j 或 向下箭头键(↓)</td>
<td>光标向下移动一个字符</td>
</tr>
<tr>
<td align="left">k 或 向上箭头键(↑)</td>
<td>光标向上移动一个字符</td>
</tr>
<tr>
<td align="left">l 或 向右箭头键(→)</td>
<td>光标向右移动一个字符</td>
</tr>
<tr>
<td align="left">如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！</td>
<td></td>
</tr>
<tr>
<td align="left">[Ctrl] + [f]</td>
<td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td>
</tr>
<tr>
<td align="left">[Ctrl] + [b]</td>
<td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td>
</tr>
<tr>
<td align="left">[Ctrl] + [d]</td>
<td>屏幕『向下』移动半页</td>
</tr>
<tr>
<td align="left">[Ctrl] + [u]</td>
<td>屏幕『向上』移动半页</td>
</tr>
<tr>
<td align="left">+</td>
<td>光标移动到非空格符的下一行</td>
</tr>
<tr>
<td align="left">-</td>
<td>光标移动到非空格符的上一行</td>
</tr>
<tr>
<td align="left">n<space></td>
<td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td>
</tr>
<tr>
<td align="left">0 或功能键[Home]</td>
<td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td>
</tr>
<tr>
<td align="left">$ 或功能键[End]</td>
<td>移动到这一行的最后面字符处(常用)</td>
</tr>
<tr>
<td align="left">H</td>
<td>光标移动到这个屏幕的最上方那一行的第一个字符</td>
</tr>
<tr>
<td align="left">M</td>
<td>光标移动到这个屏幕的中央那一行的第一个字符</td>
</tr>
<tr>
<td align="left">L</td>
<td>光标移动到这个屏幕的最下方那一行的第一个字符</td>
</tr>
<tr>
<td align="left">G</td>
<td>移动到这个档案的最后一行(常用)</td>
</tr>
<tr>
<td align="left">nG</td>
<td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td>
</tr>
<tr>
<td align="left">gg</td>
<td>移动到这个档案的第一行，相当于 1G 啊！ (常用)</td>
</tr>
<tr>
<td align="left">n<Enter></td>
<td>n 为数字。光标向下移动 n 行(常用)</td>
</tr>
<tr>
<td align="left">搜索替换</td>
<td></td>
</tr>
<tr>
<td align="left">/word</td>
<td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)</td>
</tr>
<tr>
<td align="left">?word</td>
<td>向光标之上寻找一个字符串名称为 word 的字符串。</td>
</tr>
<tr>
<td align="left">n</td>
<td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td>
</tr>
<tr>
<td align="left">N</td>
<td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td>
</tr>
<tr>
<td align="left">使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</td>
<td></td>
</tr>
<tr>
<td align="left">:n1,n2s/word1/word2/g</td>
<td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用)</td>
</tr>
<tr>
<td align="left"><strong>:1,$s/word1/word2/g</strong> 或 <strong>:%s/word1/word2/g</strong></td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td>
</tr>
<tr>
<td align="left"><strong>:1,$s/word1/word2/gc</strong> 或 <strong>:%s/word1/word2/gc</strong></td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td>
</tr>
<tr>
<td align="left">删除、复制与贴上</td>
<td></td>
</tr>
<tr>
<td align="left">x, X</td>
<td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td>
</tr>
<tr>
<td align="left">nx</td>
<td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td>
</tr>
<tr>
<td align="left">dd</td>
<td>删除游标所在的那一整行(常用)</td>
</tr>
<tr>
<td align="left">ndd</td>
<td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td>
</tr>
<tr>
<td align="left">d1G</td>
<td>删除光标所在到第一行的所有数据</td>
</tr>
<tr>
<td align="left">dG</td>
<td>删除光标所在到最后一行的所有数据</td>
</tr>
<tr>
<td align="left">d$</td>
<td>删除游标所在处，到该行的最后一个字符</td>
</tr>
<tr>
<td align="left">d0</td>
<td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td>
</tr>
<tr>
<td align="left">yy</td>
<td>复制游标所在的那一行(常用)</td>
</tr>
<tr>
<td align="left">nyy</td>
<td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td>
</tr>
<tr>
<td align="left">y1G</td>
<td>复制游标所在行到第一行的所有数据</td>
</tr>
<tr>
<td align="left">yG</td>
<td>复制游标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td align="left">y0</td>
<td>复制光标所在的那个字符到该行行首的所有数据</td>
</tr>
<tr>
<td align="left">y$</td>
<td>复制光标所在的那个字符到该行行尾的所有数据</td>
</tr>
<tr>
<td align="left">p, P</td>
<td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td>
</tr>
<tr>
<td align="left">J</td>
<td>将光标所在行与下一行的数据结合成同一行</td>
</tr>
<tr>
<td align="left">c</td>
<td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td>
</tr>
<tr>
<td align="left">u</td>
<td>复原前一个动作。(常用)</td>
</tr>
<tr>
<td align="left">[Ctrl]+r</td>
<td>重做上一个动作。(常用)</td>
</tr>
<tr>
<td align="left">这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</td>
<td></td>
</tr>
<tr>
<td align="left">.</td>
<td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td>
</tr>
</tbody></table>
<h3 id="第二部分：一般模式切换到编辑模式的可用的按钮说明"><a href="#第二部分：一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="第二部分：一般模式切换到编辑模式的可用的按钮说明"></a>第二部分：一般模式切换到编辑模式的可用的按钮说明</h3><table>
<thead>
<tr>
<th align="left">进入输入或取代的编辑模式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">i, I</td>
<td>进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td>
</tr>
<tr>
<td align="left">a, A</td>
<td>进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td>
</tr>
<tr>
<td align="left">o, O</td>
<td>进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』； O 为在目前光标所在处的上一行输入新的一行！(常用)</td>
</tr>
<tr>
<td align="left">r, R</td>
<td>进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td>
</tr>
<tr>
<td align="left">上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</td>
<td></td>
</tr>
<tr>
<td align="left">[Esc]</td>
<td>退出编辑模式，回到一般模式中(常用)</td>
</tr>
</tbody></table>
<h3 id="第三部分：一般模式切换到指令行模式的可用的按钮说明"><a href="#第三部分：一般模式切换到指令行模式的可用的按钮说明" class="headerlink" title="第三部分：一般模式切换到指令行模式的可用的按钮说明"></a>第三部分：一般模式切换到指令行模式的可用的按钮说明</h3><table>
<thead>
<tr>
<th align="left">指令行的储存、离开等指令</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">:w</td>
<td>将编辑的数据写入硬盘档案中(常用)</td>
</tr>
<tr>
<td align="left">:w!</td>
<td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td>
</tr>
<tr>
<td align="left">:q</td>
<td>离开 vi (常用)</td>
</tr>
<tr>
<td align="left">:q!</td>
<td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td>
</tr>
<tr>
<td align="left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td>
<td></td>
</tr>
<tr>
<td align="left">:wq</td>
<td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td>
</tr>
<tr>
<td align="left">ZZ</td>
<td>这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</td>
</tr>
<tr>
<td align="left">:w [filename]</td>
<td>将编辑的数据储存成另一个档案（类似另存新档）</td>
</tr>
<tr>
<td align="left">:r [filename]</td>
<td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td>
</tr>
<tr>
<td align="left">:n1,n2 w [filename]</td>
<td>将 n1 到 n2 的内容储存成 filename 这个档案。</td>
</tr>
<tr>
<td align="left">:! command</td>
<td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td>
</tr>
<tr>
<td align="left">vim 环境的变更</td>
<td></td>
</tr>
<tr>
<td align="left">:set number</td>
<td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td>
</tr>
<tr>
<td align="left">:set nonu</td>
<td>与 set nu 相反，为取消行号！</td>
</tr>
</tbody></table>
<p>注意，在 vi/vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。</p>
<p>如，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。</p>
<p><strong>vim 中批量添加注释</strong></p>
<ol>
<li>块选择模式</li>
</ol>
<p><strong>批量注释：</strong></p>
<p><strong>Ctrl + v</strong> 进入块选择模式，然后移动光标选中你要注释的行，再按大写的 <strong>I</strong> 进入行首插入模式输入注释符号如 <strong>//</strong> 或 <strong>#**，输入完毕之后，按两下 **ESC</strong>，<strong>Vim</strong> 会自动将你选中的所有行首都加上注释，保存退出完成注释。</p>
<p><strong>取消注释：</strong></p>
<p><strong>Ctrl + v</strong> 进入块选择模式，选中你要删除的行首的注释符号，注意 <strong>//</strong> 要选中两个，选好之后按 <strong>d</strong> 即可删除注释，<strong>ESC</strong> 保存退出。</p>
<ol start="2">
<li>替换命令</li>
</ol>
<p><strong>批量注释：</strong></p>
<p>使用下面命令在指定的行首添加注释。</p>
<ul>
<li>使用名命令格式： <strong>:起始行号,结束行号s/^/注释符/g</strong>（注意冒号）</li>
</ul>
<p>或</p>
<ul>
<li>使用名命令格式： <strong>:起始行号,结束行号s#^#注释符#g</strong>（注意冒号）</li>
</ul>
<p><strong>取消注释：</strong></p>
<ul>
<li>使用名命令格式： <strong>:起始行号,结束行号s/^注释符//g</strong>（注意冒号）</li>
</ul>
<p>或</p>
<ul>
<li>使用名命令格式： <strong>:起始行号,结束行号s#^注释符##g</strong>（注意冒号）</li>
</ul>
<p>如：</p>
<ol>
<li><p>在 12 - 33 行添加 <strong>//</strong> 注释</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">:12,33s#^#//#g</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>在 12 - 33 行删除 <strong>//</strong> 注释</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">:12,33s#^//##g</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>在 11 - 22 行添加 <strong>#</strong> 注释</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">:11,22s/^/#/g</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>在 11 - 22 行删除 # 注释</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">:11,22s/^#//g</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>主要参考：<a href="https://www.runoob.com/linux/linux-vim.html">Linux vi/vim</a></p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 显示行号</title>
    <url>/2020/03/06/vim-show-number/</url>
    <content><![CDATA[<p>Vim 是Ubuntu系统及其他Linux系统比较常用的文件编辑工具，但是，默认系统上不会显示文本的行号，如何设置显示行号，可以按照如下的步骤进行，这里以Ubuntu18.04为例进行。</p>
<a id="more"></a>

<h1 id="拷贝vim配置文件到家目录"><a href="#拷贝vim配置文件到家目录" class="headerlink" title="拷贝vim配置文件到家目录"></a>拷贝vim配置文件到家目录</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /etc/vim/vimrc ~/.vimrc</span><br></pre></td></tr></table></figure>

<h1 id="修改vim配置文件"><a href="#修改vim配置文件" class="headerlink" title="修改vim配置文件"></a>修改vim配置文件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.vimrc</span><br></pre></td></tr></table></figure>

<p>在末尾增加一行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set number</span><br></pre></td></tr></table></figure>

<h1 id="重新用vim打开文件"><a href="#重新用vim打开文件" class="headerlink" title="重新用vim打开文件"></a>重新用vim打开文件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim <span class="built_in">test</span> </span><br></pre></td></tr></table></figure>

<p>即可发现已经显示行号</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机网络模式 NAT 桥接 Host-Only</title>
    <url>/2019/12/20/virtual-machine-network-nat-bridge-hostonly/</url>
    <content><![CDATA[<p>虚拟机网络模式有三种: NAT，桥接，Host-Only，其中前两种能够实现虚拟机连接互联网（当主机能够连接互联网的情况下）。那么它们有哪些区别呢？</p>
<a id="more"></a>

<p>NAT 模式让虚拟机借助 NAT (网络地址转换)功能，通过宿主机器所在的网络来访问公网。但是，虚拟机的网卡和宿主机的网卡不在同一个网络，而是所有虚拟机组成一个局域网，它们能够访问外网，而外网不能够发现它们。宿主机可以连接它们。</p>
<p>桥接模式使得虚拟机网卡和宿主机网卡处在对等的地位，使得虚拟机和宿主机处在同一个局域网内，和宿主机一样可以被宿主机所在的局域网内的其他机器发现。虚拟机的 IP 地址和宿主机处在同一个网址段。相对于 NAT 模式，前者更安全。</p>
<p>Host-Only 模式使得虚拟机网络是一个封闭的网络，它唯一能访问的是宿主机，不能够访问互联网。 其实 Host-Only 网络和 NAT 网络很相似，不同的地方就是Host-Only 网络没有 NAT 服务，所以虚拟网络不能连接到 Internet。<br>更多介绍请参考 <a href="https://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html">实例讲解虚拟机3种网络模式(桥接、nat、Host-only)</a> </p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>nat</tag>
        <tag>host-only</tag>
        <tag>vm</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtualbox 以NAT模式创建虚拟机并通过SSH连接</title>
    <url>/2020/03/07/virtualbox-nat-ssh-scp/</url>
    <content><![CDATA[<p>Virtualbox 创建虚拟机时，如果按照 NAT 方式进行创建，则各虚拟机之间可以进行 SSH 连接，虚拟机也可以 SSH 连接宿主机，但是，宿主机想要连接虚拟机却需要一些设置才可以连接。想知道虚拟机桥接、NAT、host-only之间的区别，可查看我之前的文章：<a href="https://xujinzh.github.io/2019/12/20/virtual-machine-network-nat-bridge-hostonly/">虚拟机网络模式 NAT 桥接 Host-Only</a>    </p>
<a id="more"></a>

<h1 id="设置端口映射"><a href="#设置端口映射" class="headerlink" title="设置端口映射"></a>设置端口映射</h1><p>打开设置 — Network — NAT — 高级 — 端口映射，添加如下内容</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Host IP</th>
<th>Host Port</th>
<th>Guest IP</th>
<th>Guest Port</th>
</tr>
</thead>
<tbody><tr>
<td>TCP</td>
<td>127.0.0.1</td>
<td>10002</td>
<td>10.0.2.15</td>
<td>22</td>
</tr>
</tbody></table>
<p>这里假设虚拟机的 ip 地址是 10.0.2.15，可以通过在虚拟机运行命令 ifconfig 查看</p>
<h1 id="SSH连接"><a href="#SSH连接" class="headerlink" title="SSH连接"></a>SSH连接</h1><p>在宿主机运行命令SSH连接虚拟机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh jinzhongxu@127.0.0.1 -p 10000</span><br></pre></td></tr></table></figure>

<h1 id="SCP-传输文件"><a href="#SCP-传输文件" class="headerlink" title="SCP 传输文件"></a>SCP 传输文件</h1><p>如果想从宿主机向虚拟机传送文件，可以使用如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -P 10000 jdk* 127.0.0.1:/home/jinzhongxu/.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>virtualbox</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉目标跟踪算法评估</title>
    <url>/2020/08/28/visual-object-tracking-algorithm-evaluation/</url>
    <content><![CDATA[<p>机器学习算法的评估指标常见的有精确率（Precision，精确率被定义为所有被预测成正样本的样本中真实的正样本比率）、召回率（Recall，召回率被定义为所有真实的正样本中被预测成正样本的样本比率）、F1值、ROC 和 AUC 等，但目标跟踪单根据这些指标是不能够满足跟踪器算法的评估的，它常使用帧率（FPS，每秒处理帧数）、IOU（Intersection Over Union），在 VOT 中提出的 Accuracy、Robustness、EAO 以及在 OTB 中提出的 Success plots of OPE、Precision plots of OPE、 SRE、TRE 来评价一个跟踪算法在一段视频上的跟踪性能等。</p>
<a id="more"></a>

<h1 id="IOU-的定义"><a href="#IOU-的定义" class="headerlink" title="IOU 的定义"></a>IOU 的定义</h1><p>目标跟踪各算法常用矩形边界框（Bounding Box）来标注跟踪的目标，使用 IOU 进行计算矩形边界框的正确性比较容易，这也是使用矩形边界框来标注目标的原因之一。IOU 的定义如下：<br>$$<br>IOU = \frac{bb_1 \cap bb_2}{bb_1 \cup bb_2}.<br>$$<br>交、并表示区域的像素数目，IOU 值越大表示两个矩形边界框重合度越高，即跟踪效果越好。</p>
<h1 id="Accuracy-的定义"><a href="#Accuracy-的定义" class="headerlink" title="Accuracy 的定义"></a>Accuracy 的定义</h1><p>很多目标跟踪的竞赛都采用 Accuracy（准确率，简写 A）作为评价指标，其定义如下：<br>$$<br>Accuracy = \frac{1}{N}\sum^N_i IOU_i.<br>$$<br>Accuracy 值表示了一段视频中每一帧预测的目标矩形边界框与当前帧的 Ground Truth 矩形边界框之间的 IOU 的算术平均值，其中 $N$ 表示视频总帧数，或多段视频的总帧数或测试多次。Accuracy 越大表示跟踪效果越好。</p>
<h1 id="Robustness-的定义"><a href="#Robustness-的定义" class="headerlink" title="Robustness 的定义"></a>Robustness 的定义</h1><p>目标跟踪很多时候会因为一些原因导致预测矩形边界框与 Ground Truth 矩形边界框没有交叠或交叠率达不到设定的阈值，此时，就是跟丢目标，好的跟踪算法需要防止这种情况发生，衡量标准就是 Robustness（鲁棒性，简写R），定义如下：<br>$$<br>Robustness = \frac{Number Of Failed Frames}{N}.<br>$$<br>Robustness 表示跟踪失败（当前预测目标的矩形边界框与 Ground Truth 矩形边界框的 IOU 值为0或小于某个设定的阈值）的帧数与总帧数的比值，该值越小表示跟踪算法越鲁棒或越稳健。</p>
<h1 id="EAO-的定义"><a href="#EAO-的定义" class="headerlink" title="EAO 的定义"></a>EAO 的定义</h1><p>很多公开赛（如 VOT，Visual-Object-Tracking Challenge，开始于 2013 年，由伯明翰大学、卢布尔雅那大学、布拉格捷克技术大学、奥地利科技学院联合创办，旨在评测在复杂场景下单目标跟踪的算法性能。）都会使用 EAO（Expected Average Overlap）来作为最终衡量跟踪算法的性能，它权衡了 Accuracy 和 Robustness，具体的计算公式如下：<br>$$<br>EAO = E(Accuracy) = \frac{1}{N}(\sum^N_i Accuracy_i) = \frac{1}{N}\sum^N_i(\frac{1}{N_i}\sum^{N_i}_j IOU_j)<br>$$</p>
<p>举个例子：假设一个视频就两帧，那么 $N=2$，因为第一帧的矩形边界框是给定的，则 $IOU_1 = 1$，假设第二帧的 $IOU_2 = 0.6$，那么该视频的 $Accuracy_1 = \frac{1}{1} \sum IOU_1 = 1$, $Accuracy_2 = \frac{1}{2}\sum_1^2(IOU_1 + IOU_2) = 0.8$，<br>$$<br>EAO = \frac{1}{2}\sum_1^2(Accuracy_1 + Accuracy_2) = 0.9.<br>$$<br>在 VOT 挑战赛中，跟丢的帧将被重新初始化，再次进行跟踪，计算 EAO 时也会将视频按照跟丢的帧切割为多个视频段，最终 EAO 为各视频段的平均 EAO. 当跟丢的帧数发生在视频帧前时计算的 EAO 会比发生在后面帧跟丢情况的更低。</p>
<h1 id="Success-plots-的定义"><a href="#Success-plots-的定义" class="headerlink" title="Success plots 的定义"></a>Success plots 的定义</h1><p>跟踪算法预测的矩形边界框与 Ground Truth 矩形边界框的重叠率，即上面定义的 $IOU$，当某一帧的重叠率大于设定的阈值，则认为该帧的跟踪是成功的。总成功帧占所有帧的百分比即为成功率（Success rate）。Success plots 是一张图，纵坐标为成功率，横坐标为重叠率阈值（Overlap threshold），从 $0$ 到 $1$。成功率随着阈值的变化而变化，一般是递减的，因此，得到一张图。一般在图例上会给出计算得到的成功率曲线下面积值。</p>
<h1 id="Precision-plots-的定义"><a href="#Precision-plots-的定义" class="headerlink" title="Precision plots 的定义"></a>Precision plots 的定义</h1><p>跟踪算法预测的矩形边界框的中心点与 Ground Truth 矩形边界框的中心点之间的距离为 D，当某一帧的距离 D 小于设定的位置错误阈值，则认为该帧的跟踪精度高。所有距离小于阈值的帧的总数占比视频总帧数的比值即为精确率（Precision rate）。Precision plots 是一张图，纵坐标为精确率，横坐标为位置错误阈值（Location error threshold）。精确率随着位置错误阈值的变化而变化，一般是递增的，因此，得到一张图。一般在图例上会给出计算得到的精确率曲线下面积值。</p>
<h1 id="OPE"><a href="#OPE" class="headerlink" title="OPE"></a>OPE</h1><p>用 Ground Truth 中目标的位置初始化第一帧，然后运行跟踪算法得到精确率图和成功率图，这种方法被称为 One-Pass Evaluation (OPE)。</p>
<h1 id="SRE-和-TRE"><a href="#SRE-和-TRE" class="headerlink" title="SRE 和 TRE"></a>SRE 和 TRE</h1><p>SRE （Spatial Robustness Evaluation）通过从空间（Spatially，不同的 Bounding Box）上打乱再进行评估；TRE（Temporal Robustness Evaluation）通过从时间（Temporally，从不同帧起始）上打乱再进行评估。</p>
<p>在一个视频中，每个跟踪算法从不同的帧作为起始进行追踪（比如分别从第一帧开始进行跟踪，从第十帧开始进行跟踪等），初始化采用的 Bounding Box 即为对应帧标注的 Ground Truth. 最后对这些结果取平均值，得到 TRE score.</p>
<p>由于有些算法对初始化时给定的 Bounding Box 比较敏感，而目前测评用的 Ground Truth 都是人工标注的，因此可能会对某些跟踪算法产生影响。因此为了评估这些跟踪算法是否对初始化敏感，作者通过将 Ground Truth 轻微的平移和尺度的扩大与缩小来产生Bounding Box.平移的大小为目标物体大小的 10%，尺度变化范围为 Ground Truth 的 80% 到 120%，每 10% 依次增加。最后取这些结果的平均值作为SRE score.</p>
<h1 id="评估数据集"><a href="#评估数据集" class="headerlink" title="评估数据集"></a>评估数据集</h1><p>评估数据集对于目标跟踪算法同样很重要。常用的数据集包括 VOT（从 2013 年开始，每年一批数据集）, OTB（分为 OTB50、OTB100）, UAV, GOT-10k. 针对深度学习预训练数据集还包括 ImageNet, COCO 等。</p>
<p>评估数据集需要满足一些条件才能有效评估目标跟踪算法的优劣，如视频数量充足、目标类别丰富、以及标注信息准确等。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><p><a href="https://developer.aliyun.com/article/766769">视觉目标跟踪漫谈：从原理到应用</a></p>
</li>
<li><p><a href="https://blog.csdn.net/sinat_27318881/article/details/84350288">VOT中的EAO是如何计算的</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/83291192">视觉跟踪比赛VOT评价指标的计算</a></p>
</li>
<li><p><a href="https://blog.csdn.net/sinat_27318881/article/details/84350288">【技术向】VOT中的EAO是如何计算的</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/60262450">OTB评估指标</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>research</category>
        <category>object tracking</category>
      </categories>
      <tags>
        <tag>vot</tag>
        <tag>cv</tag>
        <tag>otb</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉目标跟踪的应用、原理和定义</title>
    <url>/2020/08/24/visual-object-tracking-definition/</url>
    <content><![CDATA[<p>计算机视觉（computer vision）是当前最热的人工智能应用领域之一，它包含图像分类、目标检测、目标跟踪、语义分割、实例分割等五大技术，其中视觉目标跟踪（visual object tracking，VOT，如无说明本篇目标跟踪均指视觉目标跟踪）是计算机视觉领域里相对最难、也是最为重要的研究问题之一。</p>
<a id="more"></a>

<h1 id="目标跟踪的应用领域"><a href="#目标跟踪的应用领域" class="headerlink" title="目标跟踪的应用领域"></a>目标跟踪的应用领域</h1><p>目标跟踪在以下领域有重要应用，包括但不限于</p>
<ol>
<li>安防领域，如车辆跟踪、人员活动识别与跟踪等</li>
<li>监控领域，如人脸识别、步态识别等</li>
<li>巡检领域，如机器人导航、无人机追踪等</li>
<li>人机交互、VR/AR等</li>
<li>交通流量监控、远程医疗或医学影像等</li>
</ol>
<p>总结起来，目标跟踪主要应用在对视频或者具有连续语义关联的图像的某一个或一些目标的空间位置、形状、尺寸等的获取。</p>
<h1 id="目标跟踪的基本原理"><a href="#目标跟踪的基本原理" class="headerlink" title="目标跟踪的基本原理"></a>目标跟踪的基本原理</h1><p>既然需要对某个目标在视频中进行定位和跟踪，那么就需要首先如何定义或怎么样界定需要跟踪的目标、其次如何在后续帧中定位该目标（locate）、然后如何将目标表示为计算机能够识别的信息（shape）、最后如何在后续帧找到最合适的目标位置（distinguish）。</p>
<h2 id="定义目标-bounding-box"><a href="#定义目标-bounding-box" class="headerlink" title="定义目标: bounding-box"></a>定义目标: bounding-box</h2><p>如何定义目标，即目标在图片（某一帧）上的位置、大小等，通常采用bounding-box（矩形框）来划定目标。除此之外，还包括骨架、椭圆、边界、阴影、关键点、重心等，但为了后续评价指标的定义，学术界通常采用矩形框的方式，因为这样不仅能够表示目标的位置、大小，而且只需要中心位置、长和宽等少数几个参数来表示目标，重要的是在评估算法性能时可以非常方便的使用IOU来计算准确率（Accuracy）和鲁棒性（Robustness）.</p>
<h2 id="后续帧候选框生成"><a href="#后续帧候选框生成" class="headerlink" title="后续帧候选框生成"></a>后续帧候选框生成</h2><p>在定义了目标的矩形框后，我们的目的是在后续帧能够准确的框出目标出现的位置和大小，即预测出矩形框的中心和长宽。一般而言，后续帧相对前一帧目标的位置一般不会变化太大（除非目标运动速度快和遮挡），那么我们的候选框的位置可以选择在前一帧的目标附近小范围搜索，大小也可以参考前一帧进行微小变化。这样在后续帧就会有很多个矩形框来近似目标，称这些矩形框为候选框。</p>
<h2 id="表示候选框"><a href="#表示候选框" class="headerlink" title="表示候选框"></a>表示候选框</h2><p>人类能够识别和理解的信息很多不能够直接转化为计算机能够计算的信息，所以，我们还需要把候选框和目标的信息转化为计算机能够进行计算的特征，即特征的提取。</p>
<h2 id="识别最匹配的候选框"><a href="#识别最匹配的候选框" class="headerlink" title="识别最匹配的候选框"></a>识别最匹配的候选框</h2><p>如何从前一帧的矩形框鉴别后续帧的目标。即找到最像前一帧中的目标的候选框。该步骤主要解决匹配问题，将后续帧中可能是目标的物体和前一帧的跟踪结果进行匹配，选择相似度最大的物体作为后续帧的跟踪结果。</p>
<h1 id="目标跟踪的定义"><a href="#目标跟踪的定义" class="headerlink" title="目标跟踪的定义"></a>目标跟踪的定义</h1><p>目标跟踪可以根据指定的任意目标来进行后续帧跟踪，其定义还不固定，大概有这些：</p>
<ol>
<li>跟踪是视频序列中识别感兴趣区域的过程</li>
<li>给定目标在视频中某一帧的状态（包括位置、尺寸等），跟踪是估计该目标在后续帧中的状态</li>
</ol>
<p>每一种定义都有共同之处，我定义目标跟踪为</p>
<p>目标跟踪就是在视频或图像序列中识别目标状态的过程。</p>
<h1 id="推广阅读"><a href="#推广阅读" class="headerlink" title="推广阅读"></a>推广阅读</h1><p><a href="https://blog.csdn.net/dQCFKyQDXYm3F8rB0/article/details/80016353">详解计算机视觉五大技术：图像分类、对象检测、目标跟踪、语义分割和实例分割</a></p>
<p><a href="https://developer.aliyun.com/article/766769">视觉目标跟踪漫谈：从原理到应用</a></p>
]]></content>
      <categories>
        <category>research</category>
        <category>object tracking</category>
      </categories>
      <tags>
        <tag>vot</tag>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title>通过VNC远程连接Ubuntu18.04的桌面</title>
    <url>/2020/08/20/vnc/</url>
    <content><![CDATA[<p>VNC 是虚拟网络计算（Virtual Network Computing），是一项允许使用远程帧缓冲协议（RFB）远程控制另一台计算机的技术。在这里，将介绍如何在 Ubuntu 18.04 LTS  和 CentOS 上安装和配置 VNC 服务器。本文默认使用用户 root</p>
<a id="more"></a>

<h1 id="安装-VNC-服务"><a href="#安装-VNC-服务" class="headerlink" title="安装 VNC 服务"></a>安装 VNC 服务</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> debian or ubuntu</span></span><br><span class="line">apt update</span><br><span class="line">apt -y install tightvncserver</span><br><span class="line"><span class="meta">#</span><span class="bash"> centos</span></span><br><span class="line">yum update -y</span><br><span class="line">yum install -y tigervnc-server xorg-x11-fonts-Type1</span><br></pre></td></tr></table></figure>

<h1 id="安装桌面环境"><a href="#安装桌面环境" class="headerlink" title="安装桌面环境"></a>安装桌面环境</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> debian or ubuntu</span></span><br><span class="line">apt install xfce4 xfce4-goodies</span><br><span class="line"><span class="meta">#</span><span class="bash"> centos</span></span><br><span class="line">yum install xfce4 xfce4-goodies -y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者 ubuntu 安装 gnome</span></span><br><span class="line">apt -y install ubuntu-gnome-desktop</span><br><span class="line">sudo systemctl start gdm</span><br><span class="line">sudo systemctl enable gdm</span><br><span class="line"><span class="meta">#</span><span class="bash"> centos</span></span><br><span class="line">yum -y groups install &quot;GNOME Desktop&quot;</span><br></pre></td></tr></table></figure>

<h1 id="配置-VNC-服务"><a href="#配置-VNC-服务" class="headerlink" title="配置 VNC 服务"></a>配置 VNC 服务</h1><h2 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vncpasswd</span><br></pre></td></tr></table></figure>

<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在 5901 端口</span></span><br><span class="line">vncserver :1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果使用 vncserver :2 则在 5902 端口</span></span><br></pre></td></tr></table></figure>

<h2 id="关闭服务"><a href="#关闭服务" class="headerlink" title="关闭服务"></a>关闭服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vncserver -kill :1</span><br></pre></td></tr></table></figure>

<h2 id="设置-VNC-服务桌面环境"><a href="#设置-VNC-服务桌面环境" class="headerlink" title="设置 VNC 服务桌面环境"></a>设置 VNC 服务桌面环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.vnc/xstartup</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加如下到末尾</span></span><br><span class="line">startxfce4 &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash"> gnome-session &amp;</span></span><br></pre></td></tr></table></figure>

<h2 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line"><span class="comment">#apt-get install locales</span></span><br><span class="line">dpkg-reconfigure locales</span><br><span class="line"><span class="comment"># 空格键是选择(如下面两个语言)，选择完了后Tab切换到OK，再ENTER确认</span></span><br><span class="line">en_US.UTF-8</span><br><span class="line">zh_CN UTF-8 UTF-8</span><br><span class="line"><span class="comment"># 如果进入后访问网页，中文还有显示为方块则需要装字体</span></span><br><span class="line">apt-get install ttf-wqy-zenhei</span><br><span class="line"><span class="comment"># 然后重启</span></span><br><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure>



<h1 id="连接远程-VNC-桌面"><a href="#连接远程-VNC-桌面" class="headerlink" title="连接远程 VNC 桌面"></a>连接远程 VNC 桌面</h1><p>首先，先在远程主机上打开 VNC 服务，更多参数如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vncserver :1 -geometry 800x600 -depth 24 </span><br><span class="line"><span class="meta">#</span><span class="bash"> Display number [1]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Screen resolution [800×600]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Color depth [24]</span></span><br></pre></td></tr></table></figure>

<p>其次，本地连接，推荐使用 <strong>MobaXterm</strong> 或 REALVNC ，连接方法如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开 Sessions，选择VNC</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 填写 Remote hostname or IP address</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择端口 5901，如果使用 vncserver :2,则端口是5902</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入设置的密码，登录</span></span><br></pre></td></tr></table></figure>

<p>此外，也可以使用 Linux 的 VNC 查看器，需要安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh &lt;username&gt;@&lt;vnsserverip&gt;  -C  -L 5901:127.0.0.1:5901</span><br><span class="line">sudo apt install tigervnc-viewer</span><br></pre></td></tr></table></figure>

<h1 id="配置自启-VNC-服务"><a href="#配置自启-VNC-服务" class="headerlink" title="配置自启 VNC 服务"></a>配置自启 VNC 服务</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vncserver -kill :1</span><br><span class="line">sudo vim /etc/systemd/system/vncserver@.service</span><br></pre></td></tr></table></figure>

<p>添加如下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Start TightVNC server at startup</span><br><span class="line">After=syslog.target network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">User=jinzhongxu</span><br><span class="line">Group=jinzhongxu</span><br><span class="line">WorkingDirectory=/home/jinzhongxu</span><br><span class="line"></span><br><span class="line">PIDFile=/home/jinzhongxu/.vnc/%H:%i.pid</span><br><span class="line">ExecStartPre=/usr/bin/vncserver -kill :%i &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">ExecStart=/usr/bin/vncserver -depth 24 -geometry 1280x800 :%i</span><br><span class="line">ExecStop=/usr/bin/vncserver -kill :%i</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>然后，开启自启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl enable --now vncserver@1</span><br><span class="line">systemctl status vncserver@1</span><br></pre></td></tr></table></figure>

<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://computingforgeeks.com/how-to-install-vnc-server-on-ubuntu-18-04-lts/">How To Install and Configure VNC Server on Ubuntu 18.04 LTS</a></p>
]]></content>
      <categories>
        <category>technology</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>vnc</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 远程连接 Ubuntu 桌面</title>
    <url>/2021/07/02/windows-access-remote-ubuntu-desktop/</url>
    <content><![CDATA[<p>想从 Windows 10 远程桌面访问 Ubuntu，通过使用 xrdp 来达成这一目的。</p>
<a id="more"></a>

<h1 id="Ubuntu-上安装软件"><a href="#Ubuntu-上安装软件" class="headerlink" title="Ubuntu 上安装软件"></a>Ubuntu 上安装软件</h1><p>安装远程桌面协议 (RDP) 服务器 xrdp</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install xrdp</span><br></pre></td></tr></table></figure>

<p>运行远程桌面共享服务器xrdp</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> --now xrdp</span><br></pre></td></tr></table></figure>

<p>为传入流量打开防火墙端口 3389</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ufw allow from any to any port 3389 proto tcp</span><br></pre></td></tr></table></figure>

<h1 id="Windows上远程连接"><a href="#Windows上远程连接" class="headerlink" title="Windows上远程连接"></a>Windows上远程连接</h1><p>移至 Windows 10 主机并打开远程桌面连接客户端。使用搜索框搜索远程关键字，然后单击打开按钮。</p>
<p>输入 Ubuntu 的 IP 地址和端口号 3389，验证连接</p>
<h1 id="可能问题"><a href="#可能问题" class="headerlink" title="可能问题"></a>可能问题</h1><p>在启动到 Xrdp 远程桌面协议 (RDP) 服务器的远程连接后，我有时会收到黑屏。虽然我不确定如何完全解决这个问题，但在建立远程连接之前从 Ubuntu 桌面注销至少暂时解决了这个问题。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://linuxconfig.org/ubuntu-20-04-remote-desktop-access-from-windows-10">Ubuntu 20.04 Remote Desktop Access from Windows 10</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>windows</tag>
        <tag>xrdp</tag>
        <tag>remote</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 10 Cmake error 解决方法</title>
    <url>/2020/08/03/windows-cmake-error/</url>
    <content><![CDATA[<p>使用 Windows10 开发 Python 程序时，有时候需要编译安装一些模块，如 dlib 等，需要用到 Cmake 在本地编译安装，但有时候总是会出现</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Error <span class="keyword">in</span> Cmake “The C compiler identification is unknown” </span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>这时候，主要是因为 Windows10 编译工具未有安装导致的，解决方法就是安装它。</p>
<h2 id="安装-Cmake"><a href="#安装-Cmake" class="headerlink" title="安装 Cmake"></a>安装 Cmake</h2><p>下载 Cmake，下载地址：<a href="https://cmake.org/download/">https://cmake.org/download/</a></p>
<p>下载后安装，并配置环境变量</p>
<h2 id="安装-visual-studio-build-tools"><a href="#安装-visual-studio-build-tools" class="headerlink" title="安装 visual studio build tools"></a>安装 visual studio build tools</h2><p>下载 visual studio build tools，下载地址：<a href="https://visualstudio.microsoft.com/zh-hans/visual-cpp-build-tools/">https://visualstudio.microsoft.com/zh-hans/visual-cpp-build-tools/</a></p>
<p>下载后，安装，可能需要一段时间安装</p>
<h2 id="测试安装-dlib"><a href="#测试安装-dlib" class="headerlink" title="测试安装 dlib"></a>测试安装 dlib</h2><p>安装完 Cmake 和 visual studio build tools 后，测试编译安装模块</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pip install dlib</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>cmake</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>安装 windows10 时出现无法创建分区</title>
    <url>/2019/12/20/windows10-diskpart/</url>
    <content><![CDATA[<p>在安装 windows10 时出现无法创建分区，一般是因为两个问题，一个是启动引导项未设置成 UEFI ；另一个原因是磁盘未格式化 GPT 格式。下面分别给出解决两者的方法。（UEFI 对应 GPT；Legacy 对应 MBR）</p>
<p>第一个问题解决方法，设置引导项为 UEFI</p>
<a id="more"></a>

<p>重启系统，长按 F2 进入 bios，选择 UEFI 作为引导项</p>
<p>第二个问题解决方法，格式化磁盘为 GPT</p>
<p>在系统安装界面，使用快捷键 SHIFT + F10 进入CMD，输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diskpart</span><br><span class="line">list disk</span><br><span class="line">select disk 0</span><br><span class="line">clean</span><br><span class="line">convert GPT</span><br></pre></td></tr></table></figure>

<p>至此，完成了磁盘0格式化为 GPT 格式。</p>
<p>这时候，再重新安装系统就可以了。推广参考 <a rel="noreferrer noopener" aria-label="csdn（在新窗口打开）" href="https://blog.csdn.net/abcdad/article/details/80273646" target="_blank">csdn</a> </p>
<p>经实际验证，安装Windows10系统时，使用UEFI+GPT；安装Ubuntu系统时，使用Legacy+MBR。</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>disk</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10 子系统 Ubuntu 在硬盘上的路径</title>
    <url>/2020/01/07/windows10-wsl-path/</url>
    <content><![CDATA[<p>Windows10 的 Linux 子系统 Ubuntu 非常好用，能够与Windows10非常融洽的结合使用，既保留了Windows系统优秀的用户交互式，又提供了Linux系统开发的便捷，可谓是集成了两种操作系统的优点于一身。那么，如何互相访问两者的文件呢？下面给出两者相互访问的方法。</p>
<a id="more"></a>

<h1 id="Ubuntu-访问-Windows-文件"><a href="#Ubuntu-访问-Windows-文件" class="headerlink" title="Ubuntu 访问 Windows 文件"></a>Ubuntu 访问 Windows 文件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt/c/Users/xujin/Downloads</span><br></pre></td></tr></table></figure>

<h1 id="Windows-访问-Ubuntu-文件"><a href="#Windows-访问-Ubuntu-文件" class="headerlink" title="Windows 访问 Ubuntu 文件"></a>Windows 访问 Ubuntu 文件</h1><p>Ubuntu 用户家目录在Windows的如下路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E:\Users\xujin\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\LocalState\rootfs\home\jinzhongxu</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 10 子系统 wsl 关闭和重启电脑方法</title>
    <url>/2020/09/28/windows10-wsl-shutdown/</url>
    <content><![CDATA[<p>使用 Windows 10 的子系统能够非常方便的体验到 Linux 系统的简洁美（方便开发），同时也能够体验到 Windows10 图形界面的直接美（方便使用常用软件）。Windows 10 结合 WSL 能够在一定程度上消除了装载虚拟机的时间。但 WSL 只有终端界面没有图形界面，那么如何通过 WSL 关闭 Windows 10呢？这里以 Ubuntu-18.04 为例介绍。</p>
<a id="more"></a>

<h1 id="System32"><a href="#System32" class="headerlink" title="System32"></a>System32</h1><p>首先需要通过终端进入 System32 目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt/c/Windows/System32</span><br></pre></td></tr></table></figure>

<h1 id="Shutdown"><a href="#Shutdown" class="headerlink" title="Shutdown"></a>Shutdown</h1><p>其次使用 shutdown.exe 进行管理计算机开机、重启、休眠等</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取消关机</span></span><br><span class="line">./shutdown.exe -a           </span><br><span class="line"><span class="comment"># 关机</span></span><br><span class="line">./shutdown.exe -s   </span><br><span class="line"><span class="comment"># 强行关闭应用程序</span></span><br><span class="line">./shutdown.exe -f            </span><br><span class="line"><span class="comment"># 控制远程计算机</span></span><br><span class="line">./shutdown.exe -m computer-name</span><br><span class="line"><span class="comment"># 显示远程关机图形用户界面，但必须是shutdown的第一个参数</span></span><br><span class="line">./shutdown.exe -i</span><br><span class="line"><span class="comment"># 注销当前用户</span></span><br><span class="line">./shutdown.exe -l</span><br><span class="line"><span class="comment"># 关机并重启，默认1分钟后关机</span></span><br><span class="line">./shutdown.exe -r</span><br><span class="line"><span class="comment"># 设置关机倒计时</span></span><br><span class="line">./shutdown.exe -s -t time</span><br><span class="line"><span class="comment"># 休眠，休眠后需要按一下开机键才能唤醒主机</span></span><br><span class="line">./shutdown.exe -h</span><br></pre></td></tr></table></figure>

<p>例子如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 30秒后关机</span></span><br><span class="line">./shutdown.exe -s -t 30</span><br><span class="line"><span class="comment"># 如果不想关机，可以取消关机</span></span><br><span class="line">./shutdown.exe -a</span><br><span class="line"><span class="comment"># 关机前先关闭软件</span></span><br><span class="line">./shutdown.exe -f</span><br><span class="line"><span class="comment"># 1秒后关机并重启，近似实时关机重启</span></span><br><span class="line">./shutdown.exe -r -t 1</span><br></pre></td></tr></table></figure>

<p>如果想打开 Windows 10 上面的软件，同样也可以，如打开 teamviewer</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt/c/Program\ Files\ \(x86\)/TeamViewer</span><br><span class="line">./TeamViewer.exe</span><br><span class="line"><span class="comment"># 打开后，可以按 ctrl + c 返回 terminal，不会影响已经打开的 teamviewer</span></span><br></pre></td></tr></table></figure>

<p>参考</p>
<p><a href="https://jingyan.baidu.com/article/48b558e30df4947f39c09a42.html">win10系统如何CMD中进行电脑关机或重启</a></p>
]]></content>
      <categories>
        <category>technology</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>开启 wsl 上的 cron 服务</title>
    <url>/2022/01/08/wsl-cron/</url>
    <content><![CDATA[<p>wsl 是 windows 的 linux 子系统，使得在 windows 上使用 linux 非常丝滑，而不用安装虚拟机。但是，有些服务在 wsl 默认是关闭的，需要设置才能使用。下面介绍如何在 wsl ubuntu 上开启使用 cron，cron 能够进行定时任务的执行。</p>
<a id="more"></a>

<h1 id="用户添加到-crontab-组"><a href="#用户添加到-crontab-组" class="headerlink" title="用户添加到 crontab 组"></a>用户添加到 crontab 组</h1><p>命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo usermod -a -G crontab jinzhongxu</span><br></pre></td></tr></table></figure>

<h1 id="开启-cron-服务"><a href="#开启-cron-服务" class="headerlink" title="开启 cron 服务"></a>开启 cron 服务</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service cron start</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">sudo /etc/init.d/cron start</span><br></pre></td></tr></table></figure>

<h1 id="设置开机自启-cron-服务"><a href="#设置开机自启-cron-服务" class="headerlink" title="设置开机自启 cron 服务"></a>设置开机自启 cron 服务</h1><p>访问我的另一篇博文: <a href="https://xujinzh.github.io/2020/07/20/wsl-shell-startup/">Windows10 子系统开机自启动SSH等服务</a>，把如下命令添加到 wsl.vbs 中:</p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line">ws.run <span class="string">&quot;wsl -d Ubuntu -u root /etc/init.d/cron start&quot;</span>, vbhide</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>wsl</tag>
        <tag>cron</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL 开启SSH</title>
    <url>/2020/07/24/wsl-open-ssh/</url>
    <content><![CDATA[<p>​    Windows10 安装Linux子系统后，如何开启SSH服务，使得远程可以连接该WSL呢？下面介绍这一过程。</p>
<a id="more"></a>

<h2 id="Windows10-打开22端口"><a href="#Windows10-打开22端口" class="headerlink" title="Windows10 打开22端口"></a>Windows10 打开22端口</h2><ol>
<li>Windows键 + r 打开运行，输入 control，回车打开控制面板</li>
<li>找到“系统和安全”，注意右上角查看方式为“类别”，点进去找到防火墙。或者直接改变查看方式为“大图标”，找到防火墙</li>
<li>进入防火墙，找到左边的“高级设置”</li>
<li>找到左上角的“入站规则”，点击进入，找到右上角的新建规则，选端口，然后输入需要打开的端口，这里是22，然后是运行连接，最后，填写名称SSH</li>
<li>出站规则同样</li>
</ol>
<h2 id="WSL-安装SSH服务"><a href="#WSL-安装SSH服务" class="headerlink" title="WSL 安装SSH服务"></a>WSL 安装SSH服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install openssh-server openssh-client</span><br></pre></td></tr></table></figure>

<p>开启sshd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/ssh restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果出现如下内容，说明没有开启成功，需要生成相应的密钥</span></span><br><span class="line">$ sudo /etc/init.d/ssh restart</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_rsa_key</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_ed25519_key</span><br><span class="line">* Restarting OpenBSD Secure Shell server sshd</span><br><span class="line"> Could not load host key: /etc/ssh/ssh_host_rsa_key</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_ed25519_key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看/etc/ssh目录下文件名，发现真的确实相应的密钥</span></span><br><span class="line">$ ls -l /etc/ssh</span><br><span class="line">total 552</span><br><span class="line">-rw-r--r-- 1 root root 553122 Mar  4  2019 moduli</span><br><span class="line">-rw-r--r-- 1 root root   1580 Mar  4  2019 ssh_config</span><br><span class="line">-rw-r--r-- 1 root root    338 Mar  5 00:01 ssh_import_id</span><br><span class="line">-rw-r--r-- 1 root root   3261 Jul 24 16:57 sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成密钥，注意以root身份，或者可以使用 sudo dpkg-reconfigure openssh-server，参考连接2</span></span><br><span class="line">ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key</span><br><span class="line">ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line">ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看/etc/ssh目录</span></span><br><span class="line">$ ls -l /etc/ssh</span><br><span class="line">total 556</span><br><span class="line">-rw-r--r-- 1 root root 553122 Mar  4  2019 moduli</span><br><span class="line">-rw-r--r-- 1 root root   1580 Mar  4  2019 ssh_config</span><br><span class="line">-rw------- 1 root root    227 Jul 24 17:09 ssh_host_ecdsa_key</span><br><span class="line">-rw-r--r-- 1 root root    182 Jul 24 17:09 ssh_host_ecdsa_key.pub</span><br><span class="line">-rw------- 1 root root    411 Jul 24 17:09 ssh_host_ed25519_key</span><br><span class="line">-rw-r--r-- 1 root root    102 Jul 24 17:09 ssh_host_ed25519_key.pub</span><br><span class="line">-rw------- 1 root root   1675 Jul 24 17:08 ssh_host_rsa_key</span><br><span class="line">-rw-r--r-- 1 root root    402 Jul 24 17:08 ssh_host_rsa_key.pub</span><br><span class="line">-rw-r--r-- 1 root root    338 Mar  5 00:01 ssh_import_id</span><br><span class="line">-rw-r--r-- 1 root root   3261 Jul 24 16:57 sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后，开启sshd</span></span><br><span class="line">sudo /etc/init.d/ssh restart</span><br></pre></td></tr></table></figure>

<p>注意，如果使用putty等连接wsl出现：Remote side unexpectedly closed network connection，那么很可能就是上面的密钥导致的sshd无法启动的问题。</p>
<h2 id="无需回车生成秘钥"><a href="#无需回车生成秘钥" class="headerlink" title="无需回车生成秘钥"></a>无需回车生成秘钥</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -N <span class="string">&#x27;&#x27;</span> -f ~/.ssh/id_rsa &lt;&lt;&lt; y</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a href="https://www.cnblogs.com/netonline/p/7410586.html">启动sshd时，报“Could not load host key”错</a></li>
<li><a href="https://www.jianshu.com/p/bf7daa4250b6">修复“sshd error: could not load host key”</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>windows</tag>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10 子系统开机自启动SSH等服务</title>
    <url>/2020/07/20/wsl-shell-startup/</url>
    <content><![CDATA[<p>WSL 是 Windows10 Linux 子系统，它可以让Windows10用户无需安装虚拟机就可以使用Linux系统，非常的方便。但是，默认WSL不开启sshd服务，因此，会降低使用的便捷性，这里给出如何开启该服务，以及如何设置开机自启动其他服务，如 frp 等</p>
<a id="more"></a>

<ol>
<li><p>在 Windows10 上，使用 <strong>windows + r</strong> 键，调出运行，输入 <strong>shell:startup</strong> 进入开机启动项文件夹</p>
</li>
<li><p>新建文件：<strong>wsl.vbs</strong>，名字自定义，但必须使用 vbs 作为扩展名</p>
</li>
<li><p>添加如下内容：（可以使用 notepad++ 打开）</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Set</span> ws = <span class="built_in">CreateObject</span>(<span class="string">&quot;Wscript.Shell&quot;</span>)</span><br><span class="line">ws.run <span class="string">&quot;wsl -d Ubuntu-18.04 -u root /etc/init.d/ssh start&quot;</span>, vbhide</span><br><span class="line">ws.run <span class="string">&quot;wsl -d Ubuntu-18.04 -u root ~jinzhongxu/.frp.local/frpc -c ~jinzhongxu/.frp.local/frpc.ini&quot;</span>, vbhide</span><br><span class="line">ws.run <span class="string">&quot;wsl -d Ubuntu-18.04 -u root /etc/init.d/zabbix-agent start&quot;</span>, vbhide</span><br><span class="line">ws.run <span class="string">&quot;wsl -d Ubuntu-18.04 -u root cd ~jinzhongxu/.jan &amp;&amp; ./jan&quot;</span>, vbhide</span><br></pre></td></tr></table></figure>
</li>
<li><p>其中的 “Ubuntu-18.04” 为默认的 WSL 名称，可以使用 cmd 命令: </p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl <span class="literal">-l</span></span><br><span class="line">// 结果如下：</span><br><span class="line">适用于 Linux 的 Windows 子系统:</span><br><span class="line">Ubuntu<span class="literal">-18</span>.<span class="number">04</span> (默认)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>扩展内容：可以在cmd中直接输入 <strong>wsl</strong> 进入Linux子系统shell</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 xrdp 远程连接 Ubuntu</title>
    <url>/2021/04/07/xrdp-remote-connection-ubuntu/</url>
    <content><![CDATA[<p>我这里有一个需求就是使用 Windows10 远程连接 Ubuntu 的桌面系统，但是，Ubuntu 服务器在机房且没有连接显示器，只能通过终端 SSH 远程连接。然而，处于一些需求，需要远程连接，而 Teamviewer 在远程服务器没有连接显示器的情况下会出现灰屏，无法使用。因此，使用如下方法来解决。</p>
<a id="more"></a>

<h1 id="安装-xrdp"><a href="#安装-xrdp" class="headerlink" title="安装 xrdp"></a>安装 xrdp</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt -y upgrade</span><br><span class="line">sudo apt install xrdp</span><br></pre></td></tr></table></figure>

<h1 id="安装-xfce"><a href="#安装-xfce" class="headerlink" title="安装 xfce"></a>安装 xfce</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install -y xfce4</span><br><span class="line">sudo apt install -y xfce4-goodies</span><br></pre></td></tr></table></figure>

<h1 id="配置-xrdp"><a href="#配置-xrdp" class="headerlink" title="配置 xrdp"></a>配置 xrdp</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/xrdp/xrdp.ini /etc/xrdp/xrdp.ini.bak</span><br><span class="line">sudo sed -i <span class="string">&#x27;s/3389/3390/g&#x27;</span> /etc/xrdp/xrdp.ini</span><br><span class="line">sudo sed -i <span class="string">&#x27;s/max_bpp=32/#max_bpp=32\nmax_bpp=128/g&#x27;</span> /etc/xrdp/xrdp.ini</span><br><span class="line">sudo sed -i <span class="string">&#x27;s/xserverbpp=24/#xserverbpp=24\nxserverbpp=128/g&#x27;</span> /etc/xrdp/xrdp.ini</span><br><span class="line"><span class="built_in">echo</span> xfce4-session &gt; ~/.xsession</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑启动方式为 xfce4</span></span><br><span class="line">sudo vim /etc/xrdp/startwm.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># test -x /etc/X11/Xsession &amp;&amp; exec /etc/X11/Xsession</span></span><br><span class="line"><span class="comment"># exec /bin/sh /etc/X11/Xsession</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># xfce</span></span><br><span class="line">startxfce4</span><br></pre></td></tr></table></figure>

<h1 id="启动-xrdp"><a href="#启动-xrdp" class="headerlink" title="启动 xrdp"></a>启动 xrdp</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl status xrdp.service</span><br><span class="line">sudo systemctl stop xrdp.service</span><br><span class="line">sudo systemctl start xrdp.service</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> xrdp.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">/etc/init.d/xrdp status</span><br><span class="line">/etc/init.d/xrdp stop</span><br><span class="line">/etc/init.d/xrdp start</span><br></pre></td></tr></table></figure>

<h1 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h1><p>在 Windows10 上打开远程桌面连接，输入 Ubuntu 服务器的 IP 和 端口，如下示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.2.3.4:3389</span><br></pre></td></tr></table></figure>

<p>然后，输入SSH 连接时的用户名和密码即可连接。</p>
]]></content>
      <categories>
        <category>technology</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>xrdp</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix 监控系统安装与简单设置</title>
    <url>/2020/06/08/zabbix-install-tutorial/</url>
    <content><![CDATA[<p>Zabbix 是一款开源免费的企业级监控软件，原作者是 Alexei Vladishev，编程语言是C（Server 端）和PHP（frontend），跨平台，可以用于集群网络监控、管理系统等。下面简单记录一下Zabbix服务的安装和利用Zabbix监控Linux服务器。服务器采用Ubuntu 18.04，把Zabbix Server 安装在box0，负责监控box1和box2等</p>
<a id="more"></a>

<h1 id="安装Zabbix"><a href="#安装Zabbix" class="headerlink" title="安装Zabbix"></a>安装Zabbix</h1><p>访问网址：<a href="https://www.zabbix.com/download?zabbix=5.0&os_distribution=ubuntu&os_version=20.04_focal&db=mysql&ws=apache">Zabbix</a> ，选择Install from Packages</p>
<h2 id="选择系统（Choose-your-platform）"><a href="#选择系统（Choose-your-platform）" class="headerlink" title="选择系统（Choose your platform）"></a>选择系统（Choose your platform）</h2><p>这里选择 ZABBIX VERSION: 5.0 LTS, OS DISTRIBUTION: Ubuntu, OS VERSION: 18.04 (Bionic), DATABASE: MySQL, WEB SERVER: Apache</p>
<h2 id="安装Zabbix-服务（Install-and-configure-Zabbix-server-for-your-platform）"><a href="#安装Zabbix-服务（Install-and-configure-Zabbix-server-for-your-platform）" class="headerlink" title="安装Zabbix 服务（Install and configure Zabbix server for your platform）"></a>安装Zabbix 服务（Install and configure Zabbix server for your platform）</h2><p><em>注意：所有命令以<font color='dd0000'> root </font>身份运行</em></p>
<h3 id="安装Zabbix仓库（Install-Zabbix-repository）"><a href="#安装Zabbix仓库（Install-Zabbix-repository）" class="headerlink" title="安装Zabbix仓库（Install Zabbix repository）"></a>安装Zabbix仓库（Install Zabbix repository）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://repo.zabbix.com/zabbix/5.0/ubuntu/pool/main/z/zabbix-release/zabbix-release_5.0-1+bionic_all.deb</span><br><span class="line">dpkg -i zabbix-release_5.0-1+bionic_all.deb</span><br><span class="line">apt update</span><br></pre></td></tr></table></figure>

<h3 id="安装Zabbix服务，前端和代理-（Install-Zabbix-server-frontend-agent）"><a href="#安装Zabbix服务，前端和代理-（Install-Zabbix-server-frontend-agent）" class="headerlink" title="安装Zabbix服务，前端和代理 （Install Zabbix server, frontend, agent）"></a>安装Zabbix服务，前端和代理 （Install Zabbix server, frontend, agent）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install zabbix-server-mysql zabbix-frontend-php zabbix-apache-conf zabbix-agent</span><br></pre></td></tr></table></figure>

<h3 id="建立初始化数据库（Create-initial-database）"><a href="#建立初始化数据库（Create-initial-database）" class="headerlink" title="建立初始化数据库（Create initial database）"></a>建立初始化数据库（Create initial database）</h3><p><em>注意：’<font color='dd0000'>password</font>‘ 修改成自己喜欢的密码</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入秘密</span></span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create database zabbix character <span class="built_in">set</span> utf8 collate utf8_bin;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create user zabbix@localhost identified by <span class="string">&#x27;password&#x27;</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> grant all privileges on zabbix.* to zabbix@localhost;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> quit;</span></span><br><span class="line"></span><br><span class="line">zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -p zabbix</span><br></pre></td></tr></table></figure>

<h3 id="配置数据库（Configure-the-database-for-Zabbix-server）"><a href="#配置数据库（Configure-the-database-for-Zabbix-server）" class="headerlink" title="配置数据库（Configure the database for Zabbix server）"></a>配置数据库（Configure the database for Zabbix server）</h3><p>编辑 /etc/zabbix/zabbix_server.conf，修改成前面一步设置的密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DBPassword=password</span><br></pre></td></tr></table></figure>

<h3 id="配置PHP前端（Configure-PHP-for-Zabbix-frontend）"><a href="#配置PHP前端（Configure-PHP-for-Zabbix-frontend）" class="headerlink" title="配置PHP前端（Configure PHP for Zabbix frontend）"></a>配置PHP前端（Configure PHP for Zabbix frontend）</h3><p><em>注意：这里需要校对时间，方法如下：</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date</span><br><span class="line">apt install ntpdate</span><br><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">ntpdate us.pool.ntp.org</span><br><span class="line">date</span><br></pre></td></tr></table></figure>

<p>编辑  /etc/zabbix/apache.conf, 找到时区，并取消注释和修改时区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">php_value date.timezone Asia/Shanghai</span><br></pre></td></tr></table></figure>

<h3 id="启动Zabbix-服务（Start-Zabbix-server-and-agent-processes）"><a href="#启动Zabbix-服务（Start-Zabbix-server-and-agent-processes）" class="headerlink" title="启动Zabbix 服务（Start Zabbix server and agent processes）"></a>启动Zabbix 服务（Start Zabbix server and agent processes）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart zabbix-server zabbix-agent apache2</span><br><span class="line">systemctl enable zabbix-server zabbix-agent apache2</span><br></pre></td></tr></table></figure>

<h3 id="配置Zabbix前端（Configure-Zabbix-frontend）"><a href="#配置Zabbix前端（Configure-Zabbix-frontend）" class="headerlink" title="配置Zabbix前端（Configure Zabbix frontend）"></a>配置Zabbix前端（Configure Zabbix frontend）</h3><p>打开网址：<a href="http://box0/zabbix%EF%BC%8C%E9%85%8D%E7%BD%AEZabbix">http://box0/zabbix，配置Zabbix</a>.</p>
<p><em>注意：密码为前面设置的MySQL数据库的Zabbix用户的密码；配置后，使用用户名：Admin，密码: <font color='dd000'>password</font></em></p>
<h2 id="Zabbix-Agent-安装"><a href="#Zabbix-Agent-安装" class="headerlink" title="Zabbix Agent 安装"></a>Zabbix Agent 安装</h2><p>下面开始依次在 box1 和 box2 上安装需要被监控的Linux服务器上的Zabbix Agent，这个比较简单，基本步骤同Server，不过需要配置一下参数。这里以 box1 为例，box2 类似</p>
<h3 id="下载安装源并安装Zabbix-Agent"><a href="#下载安装源并安装Zabbix-Agent" class="headerlink" title="下载安装源并安装Zabbix Agent"></a>下载安装源并安装Zabbix Agent</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://repo.zabbix.com/zabbix/5.0/ubuntu/pool/main/z/zabbix-release/zabbix-release_5.0-1+bionic_all.deb</span><br><span class="line">dpkg -i zabbix-release_5.0-1+bionic_all.deb</span><br><span class="line">apt install zabbix-agent</span><br></pre></td></tr></table></figure>

<h3 id="设置时区同Zabbix-Server"><a href="#设置时区同Zabbix-Server" class="headerlink" title="设置时区同Zabbix Server"></a>设置时区同Zabbix Server</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install ntpdate</span><br><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">ntpdate us.pool.ntp.org</span><br></pre></td></tr></table></figure>

<h3 id="设置开机自启动"><a href="#设置开机自启动" class="headerlink" title="设置开机自启动"></a>设置开机自启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">update-rc.d zabbix-server defaults</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> centos 方法如下</span></span><br><span class="line">chkconfig zabbix-agent on</span><br></pre></td></tr></table></figure>

<h3 id="设置开机不启动防火墙"><a href="#设置开机不启动防火墙" class="headerlink" title="设置开机不启动防火墙"></a>设置开机不启动防火墙</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">update-rc.d ufw remove</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> centos 方法如下</span></span><br><span class="line">chkconfig iptables off</span><br></pre></td></tr></table></figure>

<h3 id="配置Zabbix-Agent-参数"><a href="#配置Zabbix-Agent-参数" class="headerlink" title="配置Zabbix Agent 参数"></a>配置Zabbix Agent 参数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/zabbix/zabbix_agentd.conf</span><br></pre></td></tr></table></figure>

<p>修改</p>
<p>（<em>注意：Hostname=box1，不然，zabbix-agent日志会报错找不到hostname，通过 tail /var/log/zabbix-agent/zabbix_agentd.log查看</em>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Server&#x3D;box0</span><br><span class="line">ServerActive&#x3D;box0</span><br><span class="line">Hostname&#x3D;box1</span><br></pre></td></tr></table></figure>

<h3 id="重启Zabbix-Agent并设置开机自启"><a href="#重启Zabbix-Agent并设置开机自启" class="headerlink" title="重启Zabbix Agent并设置开机自启"></a>重启Zabbix Agent并设置开机自启</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/zabbix-agent status</span><br><span class="line">/etc/init.d/zabbix-agent stop</span><br><span class="line">/etc/init.d/zabbix-agent start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置开机自启</span></span><br><span class="line">update-rc.d zabbix-agent defaults</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者使用如下命令设置</span></span><br><span class="line">systemctl enable zabbix-agent</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看是否设置成功开机自启</span></span><br><span class="line">systemctl list-unit-files | grep enabled | grep zabbix</span><br></pre></td></tr></table></figure>

<p>类似设置 box1 etc.</p>
<h1 id="配置-Hosts"><a href="#配置-Hosts" class="headerlink" title="配置 Hosts"></a>配置 Hosts</h1><p>点击 Configuration –&gt; Hosts –&gt; Create host –&gt; Host name(ip or hostname，这里输入box1) –&gt; Visible name(Zabbix界面上可见名字) –&gt; Groups(选择 Linux servers) –&gt; Interfaces，Agent（IP address：box1）</p>
<h1 id="配置-Templates"><a href="#配置-Templates" class="headerlink" title="配置 Templates"></a>配置 Templates</h1><p>点击 Templates –&gt; Link new templates –&gt; (输入linux) Templates OS Linux by Zabbix agent –&gt; Add</p>
<p>点击 Monitoring–&gt;Hosts，可以查看添加的服务器，选择右边的Graphs，可以查看系统运行情况</p>
<p>类似设置 box1 etc.</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>youtube-dl 下载视频方法</title>
    <url>/2020/07/11/youtube-dl/</url>
    <content><![CDATA[<p>youtube-dl 能够方便的下载网页视频，虽然不是所有网站视频都可以下载，但已经能够覆盖很多网站。这里介绍一下如何使用youtube-dl有效下载视频。</p>
<a id="more"></a>

<h2 id="安装youtube-dl"><a href="#安装youtube-dl" class="headerlink" title="安装youtube-dl"></a>安装youtube-dl</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install youtube-dl --upgrade</span><br></pre></td></tr></table></figure>

<h2 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><p>如果使用了代理，可以使用如下配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开本地配置文件</span></span><br><span class="line">vim .bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加如下内容</span></span><br><span class="line">alias youtube = &quot;youtube-dl --no-check-certificate --proxy socks5://127.0.0.1:1080&quot;</span><br></pre></td></tr></table></figure>

<h2 id="列出有哪些格式视频"><a href="#列出有哪些格式视频" class="headerlink" title="列出有哪些格式视频"></a>列出有哪些格式视频</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">youtube-dl --list-formats https://www.yyy.com/video/BV1TW411g7Tf/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">youtube-dl -F https://www.yyy.com/video/BV1TW411g7Tf/</span><br></pre></td></tr></table></figure>

<h2 id="下载指定格式视频和音频"><a href="#下载指定格式视频和音频" class="headerlink" title="下载指定格式视频和音频"></a>下载指定格式视频和音频</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">youtube-dl -f22+140 https://www.yyy.com/video/BV1TW411g7Tf/</span><br></pre></td></tr></table></figure>

<h2 id="下载所有格式视频"><a href="#下载所有格式视频" class="headerlink" title="下载所有格式视频"></a>下载所有格式视频</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">youtube-dl --all-formats https://www.yyy.com/video/BV1TW411g7Tf/</span><br></pre></td></tr></table></figure>

<h2 id="下载视频和字幕"><a href="#下载视频和字幕" class="headerlink" title="下载视频和字幕"></a>下载视频和字幕</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">youtube-dl --write-sub --all-subs https://www.yyy.com/video/BV1TW411g7Tf/</span><br></pre></td></tr></table></figure>

<h2 id="下载最高清的视频"><a href="#下载最高清的视频" class="headerlink" title="下载最高清的视频"></a>下载最高清的视频</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">youtube-dl -f bestvideo+bestaudio https://www.yyy.com/video/BV1TW411g7Tf/</span><br></pre></td></tr></table></figure>

<h2 id="下载多个视频"><a href="#下载多个视频" class="headerlink" title="下载多个视频"></a>下载多个视频</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首先将视频地址写入文件中，注意，如果是一个视频集合，这里只需要输入第一个视频的链接，就可以下载整部视频</span></span><br><span class="line">cat https://www.yyy.com/video/BV1TW411g7Tf/ &gt;&gt; video.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后，从文件中获取链接下载视频</span></span><br><span class="line">youtube-dl -a video.txt</span><br></pre></td></tr></table></figure>

<h2 id="下载多个最高清带有字幕的视频"><a href="#下载多个最高清带有字幕的视频" class="headerlink" title="下载多个最高清带有字幕的视频"></a>下载多个最高清带有字幕的视频</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">youtube-dl -f bestvideo+bestaudio --write-sub --all-subs -a video.txt</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>youtube-dl</tag>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu14.04机器上安装 Zabbix 监控</title>
    <url>/2020/06/12/zabbix-ubuntu14/</url>
    <content><![CDATA[<p>Zabbix 在 Ubuntu14.04 上使用会收到一些限制，特别是，在本地集群，无法连接互联网时，安装可能会遇到一些坑，下面简单记录一下，并给出解决方案</p>
<a id="more"></a>

<ol>
<li>参考<a href="https://www.zabbix.com/download?zabbix=5.0&os_distribution=ubuntu&os_version=14.04_trusty&db=mysql&ws=apache">官网安装教程</a></li>
<li>下载 wget <a href="https://repo.zabbix.com/zabbix/5.0/ubuntu/pool/main/z/zabbix-release/zabbix-release_5.0-1+trusty_all.deb">https://repo.zabbix.com/zabbix/5.0/ubuntu/pool/main/z/zabbix-release/zabbix-release_5.0-1+trusty_all.deb</a></li>
<li>拷贝 zabbix-release_5.0-1+bionic_all.deb 到需要安装 zabbix server 和 zabbix agent 的Ubuntu14.04服务器上</li>
</ol>
<h2 id="安装-zabbix-server"><a href="#安装-zabbix-server" class="headerlink" title="安装 zabbix-server"></a>安装 zabbix-server</h2><p>方法如下：(注意，以root身份运行，它会自动创建zabbix用户和zabbix用户组，无家目录)，假设安装zabbix-server服务器的IP=1.1.1.0</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dpkg -i zabbix-release_5.0-1+bionic_all.deb</span><br><span class="line">apt update</span><br><span class="line"><span class="meta">#</span><span class="bash"> 不像 ubuntu18.04，需要安装最新的 zabbix-frontend-php、 zabbix-apache-conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结果就是界面比较老旧，虽然选择的是 zabbix5.0.0，其实按照成果后显示 zabbix2.2.2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这是因为 ubuntu14.04 系统 php 版本低的问题，ubuntu16.04 也是这样</span></span><br><span class="line">apt install zabbix-server-mysql zabbix-agent</span><br><span class="line"></span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入 root 用户密码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在创建 mysql 的 zabbix 用户时，请自己替换成自己的 zabbix 数据库密码</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create database zabbix character <span class="built_in">set</span> utf8 collate utf8_bin;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create user zabbix@localhost identified by <span class="string">&#x27;password&#x27;</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> grant all privileges on zabbix.* to zabbix@localhost;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> quit;</span></span><br><span class="line"></span><br><span class="line">zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -p zabbix</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim etc/zabbix/zabbix_server.conf，将上面设置的 zabbix 数据库的密码填写下面</span></span><br><span class="line">DBPassword=password</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置开机自启动</span></span><br><span class="line">service zabbix-server start</span><br><span class="line">update-rc.d zabbix-server enable</span><br><span class="line">service zabbix-agent restart</span><br><span class="line">update-rc.d zabbix-agent enable</span><br><span class="line">service apache2 restart</span><br><span class="line">update-rc.d apache2 enable</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打开网址 http://server_ip_or_name/zabbix，安装设置 zabbix Web</span></span><br></pre></td></tr></table></figure>

<p>遇到的问题：</p>
<ol>
<li><p>apt install zabbix-server zabbix agent 出错？</p>
<p>解决方法：更新 /etc/apt/sources.list；或者 apt-get autoremove -f、dpkg –configure -a；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 或者可能需要添加如下内容到 /etc/apt/sources.list</span></span><br><span class="line"></span><br><span class="line">I just wanted to say that this got me on the right track. I had to add the following lines to the /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##### Ubuntu Main Repos</span></span></span><br><span class="line"></span><br><span class="line">deb http://us.archive.ubuntu.com/ubuntu/ bionic main universe</span><br><span class="line">deb-src http://us.archive.ubuntu.com/ubuntu/ bionic main universe</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##### Ubuntu Update Repos</span></span></span><br><span class="line"></span><br><span class="line">deb http://us.archive.ubuntu.com/ubuntu/ bionic-security main universe</span><br><span class="line">deb http://us.archive.ubuntu.com/ubuntu/ bionic-updates main universe</span><br><span class="line">deb-src http://us.archive.ubuntu.com/ubuntu/ bionic-security main universe</span><br><span class="line">deb-src http://us.archive.ubuntu.com/ubuntu/ bionic-updates main universe</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>使用mysql创建zabbix用户时出错？</p>
<p>解决方法：以root用户进入mysql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop user admin@localhost;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>然后，再重新创建zabbix数据库，并分配权限；注意，打开mysqld服务</p>
</li>
<li><p>将模板数据库sql语句写入zabbix数据库时，无相应模板（zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -p zabbix）？</p>
<p>解决方法：下载<a href="https://www.zabbix.com/download_sources">zabbix源文件</a>，将里面mysql数据库里面的sql模板写入mysql的zabbix数据库。可能该模板不是以.gz为结尾的压缩文件，可以使用 gzip data.sql 压缩为 data.sql.gz，然后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注意不能先写data.sql.gz，会报错不成功</span></span><br><span class="line">zcat ./schema.sql.gz | mysql -uzabbix -p zabbix</span><br><span class="line">zcat ./images.sql.gz | mysql -uzabbix -p zabbix</span><br><span class="line">zcat ./data.sql.gz | mysql -uzabbix -p zabbix</span><br></pre></td></tr></table></figure>

<p>正常通过apt install zabbix-server安装后，/usr/share/doc/zabbix-server-mysql 文件夹中会包含相应的模板文件的。</p>
</li>
<li><p>设置开机自启 update-rc.d zabbix-server enable 时报错？</p>
<p>解决方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">update-rc.d zabbix-server defaults 88</span><br><span class="line">update-rc.d zabbix-server enable</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 zabbix web 时出现问题，比如，php time_zone？</p>
<p>解决方法：打开php.ini 或/etc/zabbix/apache.conf，设置 php_value date.timezone Asia/Shanghai</p>
</li>
</ol>
<h2 id="安装Zabbix-agent"><a href="#安装Zabbix-agent" class="headerlink" title="安装Zabbix-agent"></a>安装Zabbix-agent</h2><p>方法如下，（注意：也是以root身份），假设安装zabbix-agent的服务器的IP=1.1.1.1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dpkg -i zabbix-release_5.0-1+bionic_all.deb</span><br><span class="line">apt update</span><br><span class="line">apt install zabbix-agent</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 先关闭zabbix-agent服务，因默认安装自启</span></span><br><span class="line">service zabbix-agent stop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/zabbix/zabbix_agentd.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改如下内容，注意1.1.1.0为zabbix-server所在服务器的 IP addr</span></span><br><span class="line">Server=1.1.1.0</span><br><span class="line">ServerActive=1.1.1.0</span><br><span class="line">Hostname=1.1.1.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后重启zabbix-agent服务</span></span><br><span class="line">service zabbix-agent start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看日志文件，是否启动有错误</span></span><br><span class="line">tail /var/log/zabbix-agent/zabbix_agentd.log</span><br></pre></td></tr></table></figure>

<p>遇到的问题：</p>
<ol>
<li><p>安装出错？</p>
<p>解决方法：同zabbix-server</p>
</li>
<li><p>日志文件中出现hostname no found?</p>
<p>解决方法：查看并修改 /etc/zabbix/zabbix_agentd.conf 中的 Hostname 为zabbix-agent所在的服务器的ip</p>
</li>
<li><p>在zabbix web添加hosts时，显示的数据同zabbix-server所在机器的zabbix-agent一样？</p>
<p>解决方法：这是在添加hosts时，设置Interfaces–&gt; agent ip 时设置为127.0.0.1导致的，默认收集zabbix-server所在服务器的运行信息</p>
</li>
</ol>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ol>
<li>为zabbix监控系统添加邮件报警，如果服务器可以连接互联网，可以选择使用 <a href="https://service.mail.qq.com/cgi-bin/help?id=28&no=371&subtype=1">常用邮件客户端软件设置</a> ，来设置EMAIL</li>
<li>监控–&gt; Maps 中，可以自己编辑设置需要关注的服务器连接情况，可以添加删减，在两个服务器间连线（使用CTRL），查看两个服务器之间的带宽情况</li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 压缩(解压缩)命令 zip(unzip) 和 rar(unrar)</title>
    <url>/2019/12/20/zip-and-rar/</url>
    <content><![CDATA[<p>zip 和 rar 都是常有的压缩命令，特别是在 Windows 上压缩的 zip 或 rar 文件，上传到 Linux 系统上时，需要解压缩，下面介绍如何在 Linux 上使用命令 zip (unzip) 和 rar (unrar) 进行压缩和解压缩。</p>
<a id="more"></a>

<h1 id="zip压缩"><a href="#zip压缩" class="headerlink" title="zip压缩 "></a><font size=7 color=red>zip压缩 </font></h1><h2 id="zip-压缩多个文件或目录到一个压缩包"><a href="#zip-压缩多个文件或目录到一个压缩包" class="headerlink" title="zip 压缩多个文件或目录到一个压缩包"></a>zip 压缩多个文件或目录到一个压缩包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip -r file.zip wordcount.jar /home/jayzonxu/flink</span><br></pre></td></tr></table></figure>

<h2 id="zip-压缩同后缀的文件到一个压缩包"><a href="#zip-压缩同后缀的文件到一个压缩包" class="headerlink" title="zip 压缩同后缀的文件到一个压缩包"></a>zip 压缩同后缀的文件到一个压缩包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip file.zip *.jpeg</span><br></pre></td></tr></table></figure>

<h1 id="unzip-解压缩"><a href="#unzip-解压缩" class="headerlink" title="unzip 解压缩"></a><font size=7 color=orange>unzip 解压缩</font></h1><h2 id="unzip-解压缩文件"><a href="#unzip-解压缩文件" class="headerlink" title="unzip 解压缩文件"></a>unzip 解压缩文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip file.zip</span><br></pre></td></tr></table></figure>

<h1 id="rar-压缩"><a href="#rar-压缩" class="headerlink" title="rar 压缩"></a><font size=7 color=red>rar 压缩</font></h1><h2 id="编译安装-rar"><a href="#编译安装-rar" class="headerlink" title="编译安装 rar"></a>编译安装 rar</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://www.rarlab.com/rar/rarlinux-x64-6.0.2.tar.gz</span><br><span class="line">tar -xzf rarlinux-x64-6.0.2.tar.gz</span><br><span class="line"><span class="built_in">cd</span> rar</span><br><span class="line">sudo make</span><br></pre></td></tr></table></figure>



<h2 id="把所有文件压缩到-all-rar"><a href="#把所有文件压缩到-all-rar" class="headerlink" title="把所有文件压缩到 all.rar"></a>把所有文件压缩到 all.rar</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rar a file.rar *.jpeg filename.zip wordcount.jar /home/jayzonxu/flink</span><br></pre></td></tr></table></figure>

<h1 id="unrar-解压缩"><a href="#unrar-解压缩" class="headerlink" title="unrar 解压缩"></a><font size=7 color=orange>unrar 解压缩</font></h1><h2 id="unrar-解压缩文件"><a href="#unrar-解压缩文件" class="headerlink" title="unrar 解压缩文件"></a>unrar 解压缩文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unrar e file.rar</span><br><span class="line">unrar x file.rar</span><br></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://www.cnblogs.com/findumars/p/8244997.html">Linux中如何安装RAR</a></li>
</ol>
]]></content>
      <categories>
        <category>technology</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>debian</tag>
        <tag>zip</tag>
        <tag>rar</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper集群部署</title>
    <url>/2020/03/03/zookeeper-cluster-deployment/</url>
    <content><![CDATA[<p>Zookeeper 来源于雅虎的一个研究小组，开发其用以提供分布式协调服务。<strong>分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</strong></p>
<a id="more"></a>

<p>关于Zookeeper集群部署的一点建议：1、最好将Zookeeper部署在多于一台的集群上，即采用集群部署而不是单台服务器的standalone；2、最好部署在奇数(2N+1)台服务器上，因为Zookeeper通过多数大于少数来保证可用性，当N个节点不能访问时，整个Zookeeper集群仍然是可用的。</p>
<p>下面以3台服务器为例，来部署Zookeeper集群，假设它们的IP地址分别是1.1.1.0， 1.1.1.1， 1.1.1.2. 各步骤以1.1.1.0为默认机器演示。</p>
<h1 id="下载Zookeeper"><a href="#下载Zookeeper" class="headerlink" title="下载Zookeeper"></a>下载Zookeeper</h1><p>从官网下载<a href="http://mirror.bit.edu.cn/apache/zookeeper/">Zookeeper</a> ，这里下载3.4.14版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz</span><br></pre></td></tr></table></figure>

<h1 id="安装Zookeeper"><a href="#安装Zookeeper" class="headerlink" title="安装Zookeeper"></a>安装Zookeeper</h1><p>直接解压缩</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzf zookeeper-3.4.14.tar.gz</span><br></pre></td></tr></table></figure>

<p>也可以选择解压缩到指定的目录，比如Documents</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzf zookeeper-3.4.14.tar.gz -C ~/Documents/.</span><br></pre></td></tr></table></figure>

<h1 id="配置Zookeeper"><a href="#配置Zookeeper" class="headerlink" title="配置Zookeeper"></a>配置Zookeeper</h1><p>配置zookeeper很关键，首先进入zookeeper配置文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> zookeeper-3.4.14/conf/</span><br></pre></td></tr></table></figure>

<p>然后，利用模板创建配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>

<p>最好，修改配置参数，在此之前，我们需要创建文件夹用于存储数据和日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> zookeeper-3.4.14</span><br><span class="line">mkdir data</span><br><span class="line">mkdir <span class="built_in">log</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /data/myid</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim zoo.cfg</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dataDir=/home/jinzhongxu/zookeeper-3.4.14/data</span><br><span class="line">dataLogDir=/home/jinzhongxu/zookeeper-3.4.14/log</span><br><span class="line"></span><br><span class="line">server.1=0.0.0.0:2888:3888</span><br><span class="line">server.2=1.1.1.1:2888:3888</span><br><span class="line">server.3=1.1.1.2:2888:3888</span><br></pre></td></tr></table></figure>

<p>将zookeeper文件夹拷贝到其他机器1.1.1.1和1.1.1.2上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r zookeeper-3.4.14 1.1.1.1:/home/jinzhongxu/.</span><br><span class="line">scp -r zookeeper-3.4.14 1.1.1.2:/home/jinzhongxu/.</span><br></pre></td></tr></table></figure>

<p>并分别进入机器1.1.1.1中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 2 &gt; zookeeper-3.4.14/data/myid</span><br></pre></td></tr></table></figure>

<p>并修改配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /conf/zoo.cfg</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server.1=1.1.1.0:2888:3888</span><br><span class="line">server.2=0.0.0.0:2888:3888</span><br><span class="line">server.3=1.1.1.2:2888:3888</span><br></pre></td></tr></table></figure>

<p>机器1.1.1.2中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 3 &gt; zookeeper-3.4.14/data/myid</span><br></pre></td></tr></table></figure>

<p>并修改配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /conf/zoo.cfg</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server.1=1.1.1.0:2888:3888</span><br><span class="line">server.2=1.1.1.1:2888:3888</span><br><span class="line">server.3=0.0.0.0:2888:3888</span><br></pre></td></tr></table></figure>

<p>在上面的配置中，也可以将IP地址换成 /etc/hosts 映射的 hostname上，但是，当/etc/hosts中出现</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.1.1       box0</span><br><span class="line"></span><br><span class="line">1.1.1.255     host</span><br><span class="line">1.1.1.0     box0</span><br><span class="line">1.1.1.1     box1</span><br><span class="line">1.1.1.2     box2</span><br></pre></td></tr></table></figure>

<p>此时，在 boxi 上必须使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.i&#x3D;0.0.0.0:2888:3888</span><br></pre></td></tr></table></figure>

<p>或者，注销掉 127.0.1.1，建议使用上面方法，不改变 /etc/hosts 里的 127.0.1.1       box0</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">127.0.1.1       box0</span></span><br><span class="line"></span><br><span class="line">1.1.1.255     host</span><br><span class="line">1.1.1.0     box0</span><br><span class="line">1.1.1.1     box1</span><br><span class="line">1.1.1.2     box2</span><br></pre></td></tr></table></figure>

<h1 id="启动zookeeper"><a href="#启动zookeeper" class="headerlink" title="启动zookeeper"></a>启动zookeeper</h1><p><strong>分别在每个机器上</strong>运行如下命令，<strong>注意，分别启动完每个机器上的zkServer.sh后，再查看状态，因为zookeeper是选举机制，只启动1个就查看状态，一般是不成功的。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> zookeeper-3.4.14</span><br><span class="line">/bin/zkServer.sh start</span><br></pre></td></tr></table></figure>

<p>启动<strong>所有机器上</strong>的Zookeeper，查看zookeeper启动情况，运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/zkServer.sh status</span><br></pre></td></tr></table></figure>

<p>运行成功结果显示这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /home/jinzhongxu/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Mode: leader</span><br></pre></td></tr></table></figure>

<p>关闭Zookeeper，运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/zkServer.sh stop</span><br></pre></td></tr></table></figure>

<h1 id="Zookeeper相关知识"><a href="#Zookeeper相关知识" class="headerlink" title="Zookeeper相关知识"></a>Zookeeper相关知识</h1><ul>
<li><a href="https://www.cnblogs.com/wxisme/p/5178211.html">Zookeeper集群部署</a></li>
<li><a href="https://www.w3cschool.cn/zookeeper/">Zookeeper教程</a></li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li><p>从版本3.4.0开始，Zookeeper提供了自动清理快照和事务日志的功能，该配置在zoo.cfg里：</p>
<ol>
<li>autopurge.purgeInterval=1</li>
<li>autopurge.snapRetainCount=3</li>
</ol>
<p>autopurge.purgeInterval：这个参数指定了持久化日志清理频率，单位是小时，默认是0，即不开启自动清理功能。</p>
<p>autopurge.snapRetainCount：这个参数和上面的参数搭配，用于指定需要保留的持久化日志文件数目，默认是3个。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>big data</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 Hexo 和 Github/gitee/云服务器搭建个人博客</title>
    <url>/2019/12/20/%E4%BD%BF%E7%94%A8GitHub%20%E4%B8%8E%20Hexo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>使用 Hexo 搭建静态网站，结合 Git 命令和 Markdown 编辑文章，将会使得个人记录灵感、撰写笔记非常自然。</p>
<a id="more"></a>

<h1 id="安装-Node-js-Hexo"><a href="#安装-Node-js-Hexo" class="headerlink" title="安装 Node.js + Hexo"></a>安装 Node.js + Hexo</h1><p>此部分参考 <a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程</a> </p>
<h2 id="安装-nodejs-和-npm"><a href="#安装-nodejs-和-npm" class="headerlink" title="安装 nodejs 和 npm"></a>安装 nodejs 和 npm</h2><p>hexo 的安装需要 nodejs（即 javascript 的一种运行环境，对 Google V8 引擎进行的封装。同时也是一个服务器端的 javascript 的解释器）。而 npm 是 nodejs 的包管理器（package manager）。</p>
<p>需要注意的是，安装 nodejs 后，npm 自动安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以Ubuntu 18.04 为例</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install nodejs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查是否安装成功</span></span><br><span class="line">node --version</span><br><span class="line">npm --version</span><br></pre></td></tr></table></figure>

<h2 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 npm 命令安装 Hexo，可以认为 hexo 是 nodejs 的一个包</span></span><br><span class="line"><span class="comment"># 全局安装</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者局部安装 hexo 包</span></span><br><span class="line">npm install hexo</span><br></pre></td></tr></table></figure>

<h1 id="利用-hexo-创建本地博客"><a href="#利用-hexo-创建本地博客" class="headerlink" title="利用 hexo 创建本地博客"></a>利用 hexo 创建本地博客</h1><p>可以参考 hexo 官网：<a href="https://hexo.io/zh-cn/docs/setup.html">建站</a> </p>
<p>中文网站：<a href="https://hexo.io/zh-cn/">hexo.io</a> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init blog.source</span><br><span class="line"><span class="built_in">cd</span> blog.source</span><br><span class="line">npm install</span><br><span class="line">hexo server </span><br><span class="line"><span class="comment"># 此时，打开本地浏览器，输入 http://localhost:4000 就可以打开博客网页，不过现在是部署在本地的，可以利用 Git 上传到代码托管仓库或者私人云服务器上，继续下面将进行介绍</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建完成后，blog.source 文件夹的目录如下：</span></span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── <span class="built_in">source</span></span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<h1 id="更换成-next-主题"><a href="#更换成-next-主题" class="headerlink" title="更换成 next 主题"></a>更换成 next 主题</h1><p>如果你不喜欢默认的 landscape 主题，可以下载自己喜欢的主题。使用下面的命令，默认是 clone 到 blog.source\themes 目录下，我这里下载 <a href="https://github.com/theme-next/hexo-theme-next">next 主题</a> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog.source</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/next-theme/hexo-theme-next.git</span><br></pre></td></tr></table></figure>

<p>下载后，需要下面的修改配置，更改为 <a href="https://github.com/next-theme/hexo-theme-next">next</a> 主题</p>
<h1 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h1><p>修改 _config.yml 文件部分内容，并保存</p>
<ul>
<li>1、 更改站点信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Site</span></span><br><span class="line">title: J Blog</span><br><span class="line">subtitle: &#x27;&#x27;</span><br><span class="line">description: &#x27;个人技术网址：人工智能和数学&#x27;</span><br><span class="line">keywords:</span><br><span class="line">author: Jinzhong Xu</span><br><span class="line">language: en</span><br><span class="line">timezone: &#x27;Asia/Shanghai&#x27;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、 更改URL</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> URL</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span></span><br><span class="line">url: https://xujinzh.github.io</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br></pre></td></tr></table></figure>
<ul>
<li>3 、修改主题</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Extensions</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Plugins: https://hexo.io/plugins/</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Themes: https://hexo.io/themes/</span></span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<ul>
<li>4、更改部署</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  repo: </span><br><span class="line">  	github: git@github.com:xujinzh/xujinzh.github.io.git,master</span><br><span class="line">  	gitee: git@gitee.com:xu-jinzhong/xu-jinzhong.git,master</span><br><span class="line">  	hexo: git@1.1.1.1:/home/git/hexo.git,master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里添加了两个代码托管网址，分别是国外的 github 和国内的 gitee，而且使用的是 SSH，所以建议首先将本地电脑的 SSH 公钥添加到自己的 github 和 gitee 上，并分别创建仓库。这样每次部署时，都会在两个仓库生成静态网站。需要注意的是 gitee 需要进到网站仓库（下面仓库名）里，找到服务--&gt; Gitee Pages 手动更新网站，自动更新需要收费。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 个人云服务器配置请参考下面介绍</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># github 上创建仓库：</span></span><br><span class="line">仓库名：xujinzh.github.io</span><br><span class="line">其他默认。注意为了保持一级域名:https://xu-jinzhong.gitee.io/, 仓库名需使用github用户名xujinzh</span><br><span class="line"><span class="comment"># gitee 上创建仓库：</span></span><br><span class="line">仓库名：xu-jinzhong</span><br><span class="line">其他默认：注意为了保持一级域名:https://xujinzh.github.io/, 仓库名需使用gitee用户名xu-jinzhong</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想要使用 git 更新部署，还需要安装下面的 git 部署命令</span></span><br></pre></td></tr></table></figure>

<h1 id="安装-git-部署命令"><a href="#安装-git-部署命令" class="headerlink" title="安装 git 部署命令"></a>安装 git 部署命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装成功后，就可以上传到代码托管网站上了，如GitHub, gitee，个人云服务器（需要下面的配置）</span></span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br><span class="line"><span class="comment"># 其中 hexo g 可以代替 hexo generate; hexo d 可以代替 hexo deploy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然，也可以先在本地查看网页情况，没有问题再部署到远程仓库上，方法如下</span></span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其中 hexo s 可以代替 hexo server</span></span><br><span class="line"><span class="comment"># 成功后，会在地址：http://localhost:4000 访问到本地博客网页</span></span><br></pre></td></tr></table></figure>

<h1 id="安装搜索插件"><a href="#安装搜索插件" class="headerlink" title="安装搜索插件"></a>安装搜索插件</h1><p>搜索插件很重要，因为当网站上书写的博文比较多时，想要找到之前的某篇文章，最好使用搜索</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>在文件 _config.yml 中添加如下代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Local search</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Dependencies: https://github.com/flashlab/hexo-generator-search</span></span><br><span class="line"></span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>进一步修改如下代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line"><span class="meta">  #</span><span class="bash"> If auto, trigger search by changing input.</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  trigger: auto</span><br><span class="line"><span class="meta">  #</span><span class="bash"> Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  top_n_per_article: 1</span><br><span class="line"><span class="meta">  #</span><span class="bash"> Unescape html strings to the readable one.</span></span><br><span class="line">  unescape: false</span><br><span class="line"><span class="meta">  #</span><span class="bash"> Preload the search data when the page loads.</span></span><br><span class="line">  preload: true</span><br></pre></td></tr></table></figure>
<p>记得保存文件 \themes\next_config.yml，该节可参考 <a href="%5Bhttps://yashuning.github.io/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/#comments%5D(https://yashuning.github.io/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/#comments)">hexo - Next 主题添加搜索功能</a> </p>
<h1 id="添加页面"><a href="#添加页面" class="headerlink" title="添加页面"></a>添加页面</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br><span class="line">hexo new page tags</span><br><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>
<p>编辑 \source\tags\index.md，categories 类似， about 直接在 markdown 里增加需要的内容就好，不需要修改文件头部信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-12-20 15:59:36</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>其他标签类似。更多个性化设置请参考 <a href="https://blog.guanqr.com/study/blog/hexo-theme-next-customization/#">Hexo-NexT 主题个性优化</a> </p>
<h1 id="个人偏好设置"><a href="#个人偏好设置" class="headerlink" title="个人偏好设置"></a>个人偏好设置</h1><p>此处是在 themes/next 主题下的配置文件中修改</p>
<ul>
<li><p>1、主题设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ---------------------------------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Scheme Settings</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Schemes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">scheme: Muse</span></span><br><span class="line"><span class="meta">#</span><span class="bash">scheme: Mist</span></span><br><span class="line">scheme: Pisces</span><br><span class="line"><span class="meta">#</span><span class="bash">scheme: Gemini</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>2、菜单设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line"><span class="meta">  #</span><span class="bash">schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">commonweal: /404/ || fa fa-heartbeat</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="云服务器部署博客"><a href="#云服务器部署博客" class="headerlink" title="云服务器部署博客"></a>云服务器部署博客</h1><p>当不习惯使用或者其他原因（比如仓库是公开的）不喜欢使用代码托管网站时，可以自己搭建代码托管服务器</p>
<h2 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h2><p>此部分以个人喜好，目前云服务器厂家特别多，建议购买大厂的，一般20G左右的硬盘足够写博文了，考虑到后期的访问量，最好1G内存吧，系统可以选择 Ubuntu、CentOS 等，本文以 Ubuntu为例</p>
<h2 id="静态服务器-nginx"><a href="#静态服务器-nginx" class="headerlink" title="静态服务器 nginx"></a>静态服务器 nginx</h2><p>nginx 是一款静态 http 服务软件，可以将服务器上的静态资源（如 HTML、图片）通过 http 协议展现到网页上。</p>
<p>安装 nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nginx</span><br><span class="line">nginx -v</span><br></pre></td></tr></table></figure>

<p>此时，如果将云服务器的外网 IP 输入浏览器上访问，能够看到 nginx 安装成功的欢迎页</p>
<h2 id="代码版本控制系统-Git"><a href="#代码版本控制系统-Git" class="headerlink" title="代码版本控制系统 Git"></a>代码版本控制系统 Git</h2><p>使用 Git 进行版本控制将是非常方便的，能够通过 Git 更新博文</p>
<p>安装 Git</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install git</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p>配置 Git</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;jinzhongxu&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;jinzhongxu@outlook.com&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置静态网页"><a href="#配置静态网页" class="headerlink" title="配置静态网页"></a>配置静态网页</h2><p>一般 nginx 的静态网页内容放在云服务器的 /var/www/html 目录下，我们需要将托管到 GitHub/gitee 上的博客克隆到该目录下，因目录 /var/www/html 所有者是 root，所以，需要切换到 root 用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -i</span><br><span class="line"><span class="built_in">cd</span> /var/www/html</span><br><span class="line">rm index.nginx-debian.html</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/j/j.github.io.git</span><br><span class="line">cp -r j.github.io/* .</span><br></pre></td></tr></table></figure>

<p>此时再次访问网页，发现已经是自己克隆的博文了</p>
<p>如果不想将博文放到目录 /var/www/html 下，可以修改配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx/sites-available</span><br><span class="line">vim default</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改如下的目录为你喜欢的目录，不过注意的是，因为要别人通过网页查看博文但又不能随便修改博文，所以需要设置存放博文的目录权限</span></span><br><span class="line">root /var/www/html;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如 /var/www/html 的默认权限</span></span><br><span class="line"> /var/www/</span><br><span class="line">total 12</span><br><span class="line">drwxr-xr-x  3 root root 4096 Sep  1 02:05 ./</span><br><span class="line">drwxr-xr-x 14 root root 4096 Sep  1 02:05 ../</span><br><span class="line">drwxr-xr-x 13 root root 4096 Sep  1 02:19 html/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 html 文件夹所有者和所有组为 git， git</span></span><br><span class="line">chown -R git:git /var/www/html</span><br></pre></td></tr></table></figure>

<h2 id="利用-Git-发表新博文"><a href="#利用-Git-发表新博文" class="headerlink" title="利用 Git 发表新博文"></a>利用 Git 发表新博文</h2><p>创建 git 用户(root身份创建新用户)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -i</span><br><span class="line">adduser git</span><br><span class="line"><span class="comment"># 如果是 CentOS 用户，记得使用 passwd git 设置 git 用户的密码</span></span><br><span class="line">usermod -aG sudo git</span><br></pre></td></tr></table></figure>

<p>创建裸仓</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到 git 用户</span></span><br><span class="line">su git</span><br><span class="line"><span class="comment"># 配置 ssh， 将本地的公钥 id_rsa.pub 写入云服务器的 authorized_keys</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 切换到本地机器，</span></span><br><span class="line"><span class="comment"># 这个命令是在本地机器上使用，如本地的 wsl</span></span><br><span class="line">ssh-copy-id git@1.1.1.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到远程云服务器，生成裸仓</span></span><br><span class="line"><span class="built_in">cd</span></span><br><span class="line">git init --bare hexo.git</span><br></pre></td></tr></table></figure>

<h2 id="配置仓库"><a href="#配置仓库" class="headerlink" title="配置仓库"></a>配置仓库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo.git/hooks/</span><br><span class="line">vim post-receive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加如下内容</span></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">git --work-tree=/var/www/html --git-dir=/home/git/hexo.git checkout -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加文件 post-receive 的执行权限</span></span><br><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure>

<h2 id="配置本地博客"><a href="#配置本地博客" class="headerlink" title="配置本地博客"></a>配置本地博客</h2><p>如果上面配置博客时，没有添加云服务器仓库，这里添加最后一行，配置后显示如下，根据自己情况替换我的仓库名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Deployment</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Docs: https://hexo.io/docs/deployment.html</span></span></span><br><span class="line">deploy:</span><br><span class="line">  type: &#x27;git&#x27;</span><br><span class="line">  repo: </span><br><span class="line">  	github: git@github.com:xujinzh/xujinzh.github.io.git,master</span><br><span class="line">  	gitee: git@gitee.com:xu-jinzhong/xu-jinzhong.git,master</span><br><span class="line">  	hexo: git@1.1.1.1:/home/git/hexo.git,master</span><br></pre></td></tr></table></figure>



<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="在-post-的下一个中显示为-lt-i-class-”fa-fa-angle-right”-gt-lt-i-gt"><a href="#在-post-的下一个中显示为-lt-i-class-”fa-fa-angle-right”-gt-lt-i-gt" class="headerlink" title="在 post 的下一个中显示为 &lt;i class=”fa fa-angle-right”&gt;&lt;i&gt;"></a>在 post 的下一个中显示为 &lt;i class=”fa fa-angle-right”&gt;&lt;i&gt;</h2><p>解决方案：</p>
<p>修改 /themes/next/layout/_partials/pagination.swig</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;%- if page.prev or page.next %&#125;</span><br><span class="line"> <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;pagination&quot;</span>&gt;</span></span><br><span class="line">   &#123;&#123;</span><br><span class="line">     paginator(&#123;</span><br><span class="line">       prev_text: &#x27;<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-angle-left&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;&#x27;+__(&#x27;accessibility.prev_page&#x27;)+&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#x27;,</span><br><span class="line">       next_text: &#x27;<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-angle-right&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;&#x27;+__(&#x27;accessibility.next_page&#x27;)+&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#x27;,</span><br><span class="line">       mid_size: 1,</span><br><span class="line">       escape: false</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;&#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>个人简介</title>
    <url>/about/index.html</url>
    <content><![CDATA[<p>Jinzhong Xu, 科研工作者，专注于数学与应用数学、计算机应用技术，特别是在分析、代数与几何、大数据分析、计算机视觉等。常用编程语言有 Python、C、Java 等。</p>
<h1 id="座右铭"><a href="#座右铭" class="headerlink" title="座右铭"></a>座右铭</h1><ol>
<li>学习的最好方法就是沉迷；</li>
<li>天道酬勤，地道酬善，人道酬诚，商道酬信，业道酬精；</li>
<li>天下难事，必做于易；天下大事，必做于细；</li>
<li>认真就是水平，实干才是能力；</li>
<li>自胜者强；</li>
<li>沉着冷静，理性稳重，万无一失；</li>
</ol>
<!-- ![](https://xu-jinzhong.gitee.io/images/silence.jpg) -->
]]></content>
  </entry>
</search>
